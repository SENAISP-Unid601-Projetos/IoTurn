
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model InteracaoIA
 * 
 */
export type InteracaoIA = $Result.DefaultSelection<Prisma.$InteracaoIAPayload>
/**
 * Model HyperparameterArm
 * 
 */
export type HyperparameterArm = $Result.DefaultSelection<Prisma.$HyperparameterArmPayload>
/**
 * Model Client
 * Representa a empresa cliente que contrata o serviço IoTurn.
 */
export type Client = $Result.DefaultSelection<Prisma.$ClientPayload>
/**
 * Model User
 * Usuários que podem acessar a plataforma, associados a um cliente.
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Machine
 * Representa uma máquina industrial monitorada.
 */
export type Machine = $Result.DefaultSelection<Prisma.$MachinePayload>
/**
 * Model UnifiedMachineState
 * 
 */
export type UnifiedMachineState = $Result.DefaultSelection<Prisma.$UnifiedMachineStatePayload>
/**
 * Model Device
 * 
 */
export type Device = $Result.DefaultSelection<Prisma.$DevicePayload>
/**
 * Model Gateway
 * Representa o hardware físico do Gateway (ESP32 com Wi-Fi).
 */
export type Gateway = $Result.DefaultSelection<Prisma.$GatewayPayload>
/**
 * Model RpmReading
 * Armazena as leituras dos sensores de uma máquina em um ponto no tempo.
 */
export type RpmReading = $Result.DefaultSelection<Prisma.$RpmReadingPayload>
/**
 * Model OilTemperatureReading
 * 
 */
export type OilTemperatureReading = $Result.DefaultSelection<Prisma.$OilTemperatureReadingPayload>
/**
 * Model OilLevelReading
 * 
 */
export type OilLevelReading = $Result.DefaultSelection<Prisma.$OilLevelReadingPayload>
/**
 * Model CurrentReading
 * 
 */
export type CurrentReading = $Result.DefaultSelection<Prisma.$CurrentReadingPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Status: {
  ACTIVE: 'ACTIVE',
  SUSPENDED: 'SUSPENDED',
  CANCELED: 'CANCELED'
};

export type Status = (typeof Status)[keyof typeof Status]


export const UserType: {
  ADMIN: 'ADMIN',
  TECHNICIAN: 'TECHNICIAN',
  VIEWER: 'VIEWER'
};

export type UserType = (typeof UserType)[keyof typeof UserType]


export const DeviceStatus: {
  ONLINE: 'ONLINE',
  OFFLINE: 'OFFLINE',
  PROVISIONING: 'PROVISIONING',
  ERROR: 'ERROR',
  CANCELED: 'CANCELED'
};

export type DeviceStatus = (typeof DeviceStatus)[keyof typeof DeviceStatus]

}

export type Status = $Enums.Status

export const Status: typeof $Enums.Status

export type UserType = $Enums.UserType

export const UserType: typeof $Enums.UserType

export type DeviceStatus = $Enums.DeviceStatus

export const DeviceStatus: typeof $Enums.DeviceStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more InteracaoIAS
 * const interacaoIAS = await prisma.interacaoIA.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more InteracaoIAS
   * const interacaoIAS = await prisma.interacaoIA.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.interacaoIA`: Exposes CRUD operations for the **InteracaoIA** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InteracaoIAS
    * const interacaoIAS = await prisma.interacaoIA.findMany()
    * ```
    */
  get interacaoIA(): Prisma.InteracaoIADelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.hyperparameterArm`: Exposes CRUD operations for the **HyperparameterArm** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HyperparameterArms
    * const hyperparameterArms = await prisma.hyperparameterArm.findMany()
    * ```
    */
  get hyperparameterArm(): Prisma.HyperparameterArmDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.client`: Exposes CRUD operations for the **Client** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clients
    * const clients = await prisma.client.findMany()
    * ```
    */
  get client(): Prisma.ClientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.machine`: Exposes CRUD operations for the **Machine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Machines
    * const machines = await prisma.machine.findMany()
    * ```
    */
  get machine(): Prisma.MachineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.unifiedMachineState`: Exposes CRUD operations for the **UnifiedMachineState** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UnifiedMachineStates
    * const unifiedMachineStates = await prisma.unifiedMachineState.findMany()
    * ```
    */
  get unifiedMachineState(): Prisma.UnifiedMachineStateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.device`: Exposes CRUD operations for the **Device** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Devices
    * const devices = await prisma.device.findMany()
    * ```
    */
  get device(): Prisma.DeviceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gateway`: Exposes CRUD operations for the **Gateway** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Gateways
    * const gateways = await prisma.gateway.findMany()
    * ```
    */
  get gateway(): Prisma.GatewayDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rpmReading`: Exposes CRUD operations for the **RpmReading** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RpmReadings
    * const rpmReadings = await prisma.rpmReading.findMany()
    * ```
    */
  get rpmReading(): Prisma.RpmReadingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.oilTemperatureReading`: Exposes CRUD operations for the **OilTemperatureReading** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OilTemperatureReadings
    * const oilTemperatureReadings = await prisma.oilTemperatureReading.findMany()
    * ```
    */
  get oilTemperatureReading(): Prisma.OilTemperatureReadingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.oilLevelReading`: Exposes CRUD operations for the **OilLevelReading** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OilLevelReadings
    * const oilLevelReadings = await prisma.oilLevelReading.findMany()
    * ```
    */
  get oilLevelReading(): Prisma.OilLevelReadingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.currentReading`: Exposes CRUD operations for the **CurrentReading** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CurrentReadings
    * const currentReadings = await prisma.currentReading.findMany()
    * ```
    */
  get currentReading(): Prisma.CurrentReadingDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.18.0
   * Query Engine version: 34b5a692b7bd79939a9a2c3ef97d816e749cda2f
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    InteracaoIA: 'InteracaoIA',
    HyperparameterArm: 'HyperparameterArm',
    Client: 'Client',
    User: 'User',
    Machine: 'Machine',
    UnifiedMachineState: 'UnifiedMachineState',
    Device: 'Device',
    Gateway: 'Gateway',
    RpmReading: 'RpmReading',
    OilTemperatureReading: 'OilTemperatureReading',
    OilLevelReading: 'OilLevelReading',
    CurrentReading: 'CurrentReading'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "interacaoIA" | "hyperparameterArm" | "client" | "user" | "machine" | "unifiedMachineState" | "device" | "gateway" | "rpmReading" | "oilTemperatureReading" | "oilLevelReading" | "currentReading"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      InteracaoIA: {
        payload: Prisma.$InteracaoIAPayload<ExtArgs>
        fields: Prisma.InteracaoIAFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InteracaoIAFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteracaoIAPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InteracaoIAFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteracaoIAPayload>
          }
          findFirst: {
            args: Prisma.InteracaoIAFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteracaoIAPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InteracaoIAFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteracaoIAPayload>
          }
          findMany: {
            args: Prisma.InteracaoIAFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteracaoIAPayload>[]
          }
          create: {
            args: Prisma.InteracaoIACreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteracaoIAPayload>
          }
          createMany: {
            args: Prisma.InteracaoIACreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InteracaoIACreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteracaoIAPayload>[]
          }
          delete: {
            args: Prisma.InteracaoIADeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteracaoIAPayload>
          }
          update: {
            args: Prisma.InteracaoIAUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteracaoIAPayload>
          }
          deleteMany: {
            args: Prisma.InteracaoIADeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InteracaoIAUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InteracaoIAUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteracaoIAPayload>[]
          }
          upsert: {
            args: Prisma.InteracaoIAUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteracaoIAPayload>
          }
          aggregate: {
            args: Prisma.InteracaoIAAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInteracaoIA>
          }
          groupBy: {
            args: Prisma.InteracaoIAGroupByArgs<ExtArgs>
            result: $Utils.Optional<InteracaoIAGroupByOutputType>[]
          }
          count: {
            args: Prisma.InteracaoIACountArgs<ExtArgs>
            result: $Utils.Optional<InteracaoIACountAggregateOutputType> | number
          }
        }
      }
      HyperparameterArm: {
        payload: Prisma.$HyperparameterArmPayload<ExtArgs>
        fields: Prisma.HyperparameterArmFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HyperparameterArmFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HyperparameterArmPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HyperparameterArmFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HyperparameterArmPayload>
          }
          findFirst: {
            args: Prisma.HyperparameterArmFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HyperparameterArmPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HyperparameterArmFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HyperparameterArmPayload>
          }
          findMany: {
            args: Prisma.HyperparameterArmFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HyperparameterArmPayload>[]
          }
          create: {
            args: Prisma.HyperparameterArmCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HyperparameterArmPayload>
          }
          createMany: {
            args: Prisma.HyperparameterArmCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HyperparameterArmCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HyperparameterArmPayload>[]
          }
          delete: {
            args: Prisma.HyperparameterArmDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HyperparameterArmPayload>
          }
          update: {
            args: Prisma.HyperparameterArmUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HyperparameterArmPayload>
          }
          deleteMany: {
            args: Prisma.HyperparameterArmDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HyperparameterArmUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HyperparameterArmUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HyperparameterArmPayload>[]
          }
          upsert: {
            args: Prisma.HyperparameterArmUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HyperparameterArmPayload>
          }
          aggregate: {
            args: Prisma.HyperparameterArmAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHyperparameterArm>
          }
          groupBy: {
            args: Prisma.HyperparameterArmGroupByArgs<ExtArgs>
            result: $Utils.Optional<HyperparameterArmGroupByOutputType>[]
          }
          count: {
            args: Prisma.HyperparameterArmCountArgs<ExtArgs>
            result: $Utils.Optional<HyperparameterArmCountAggregateOutputType> | number
          }
        }
      }
      Client: {
        payload: Prisma.$ClientPayload<ExtArgs>
        fields: Prisma.ClientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findFirst: {
            args: Prisma.ClientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findMany: {
            args: Prisma.ClientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          create: {
            args: Prisma.ClientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          createMany: {
            args: Prisma.ClientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          delete: {
            args: Prisma.ClientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          update: {
            args: Prisma.ClientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          deleteMany: {
            args: Prisma.ClientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClientUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          upsert: {
            args: Prisma.ClientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          aggregate: {
            args: Prisma.ClientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClient>
          }
          groupBy: {
            args: Prisma.ClientGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientCountArgs<ExtArgs>
            result: $Utils.Optional<ClientCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Machine: {
        payload: Prisma.$MachinePayload<ExtArgs>
        fields: Prisma.MachineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MachineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MachineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachinePayload>
          }
          findFirst: {
            args: Prisma.MachineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MachineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachinePayload>
          }
          findMany: {
            args: Prisma.MachineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachinePayload>[]
          }
          create: {
            args: Prisma.MachineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachinePayload>
          }
          createMany: {
            args: Prisma.MachineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MachineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachinePayload>[]
          }
          delete: {
            args: Prisma.MachineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachinePayload>
          }
          update: {
            args: Prisma.MachineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachinePayload>
          }
          deleteMany: {
            args: Prisma.MachineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MachineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MachineUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachinePayload>[]
          }
          upsert: {
            args: Prisma.MachineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachinePayload>
          }
          aggregate: {
            args: Prisma.MachineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMachine>
          }
          groupBy: {
            args: Prisma.MachineGroupByArgs<ExtArgs>
            result: $Utils.Optional<MachineGroupByOutputType>[]
          }
          count: {
            args: Prisma.MachineCountArgs<ExtArgs>
            result: $Utils.Optional<MachineCountAggregateOutputType> | number
          }
        }
      }
      UnifiedMachineState: {
        payload: Prisma.$UnifiedMachineStatePayload<ExtArgs>
        fields: Prisma.UnifiedMachineStateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnifiedMachineStateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnifiedMachineStatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnifiedMachineStateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnifiedMachineStatePayload>
          }
          findFirst: {
            args: Prisma.UnifiedMachineStateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnifiedMachineStatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnifiedMachineStateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnifiedMachineStatePayload>
          }
          findMany: {
            args: Prisma.UnifiedMachineStateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnifiedMachineStatePayload>[]
          }
          create: {
            args: Prisma.UnifiedMachineStateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnifiedMachineStatePayload>
          }
          createMany: {
            args: Prisma.UnifiedMachineStateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UnifiedMachineStateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnifiedMachineStatePayload>[]
          }
          delete: {
            args: Prisma.UnifiedMachineStateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnifiedMachineStatePayload>
          }
          update: {
            args: Prisma.UnifiedMachineStateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnifiedMachineStatePayload>
          }
          deleteMany: {
            args: Prisma.UnifiedMachineStateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnifiedMachineStateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UnifiedMachineStateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnifiedMachineStatePayload>[]
          }
          upsert: {
            args: Prisma.UnifiedMachineStateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnifiedMachineStatePayload>
          }
          aggregate: {
            args: Prisma.UnifiedMachineStateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnifiedMachineState>
          }
          groupBy: {
            args: Prisma.UnifiedMachineStateGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnifiedMachineStateGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnifiedMachineStateCountArgs<ExtArgs>
            result: $Utils.Optional<UnifiedMachineStateCountAggregateOutputType> | number
          }
        }
      }
      Device: {
        payload: Prisma.$DevicePayload<ExtArgs>
        fields: Prisma.DeviceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeviceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeviceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          findFirst: {
            args: Prisma.DeviceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeviceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          findMany: {
            args: Prisma.DeviceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>[]
          }
          create: {
            args: Prisma.DeviceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          createMany: {
            args: Prisma.DeviceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeviceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>[]
          }
          delete: {
            args: Prisma.DeviceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          update: {
            args: Prisma.DeviceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          deleteMany: {
            args: Prisma.DeviceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeviceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeviceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>[]
          }
          upsert: {
            args: Prisma.DeviceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          aggregate: {
            args: Prisma.DeviceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDevice>
          }
          groupBy: {
            args: Prisma.DeviceGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeviceGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeviceCountArgs<ExtArgs>
            result: $Utils.Optional<DeviceCountAggregateOutputType> | number
          }
        }
      }
      Gateway: {
        payload: Prisma.$GatewayPayload<ExtArgs>
        fields: Prisma.GatewayFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GatewayFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GatewayPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GatewayFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GatewayPayload>
          }
          findFirst: {
            args: Prisma.GatewayFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GatewayPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GatewayFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GatewayPayload>
          }
          findMany: {
            args: Prisma.GatewayFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GatewayPayload>[]
          }
          create: {
            args: Prisma.GatewayCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GatewayPayload>
          }
          createMany: {
            args: Prisma.GatewayCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GatewayCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GatewayPayload>[]
          }
          delete: {
            args: Prisma.GatewayDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GatewayPayload>
          }
          update: {
            args: Prisma.GatewayUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GatewayPayload>
          }
          deleteMany: {
            args: Prisma.GatewayDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GatewayUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GatewayUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GatewayPayload>[]
          }
          upsert: {
            args: Prisma.GatewayUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GatewayPayload>
          }
          aggregate: {
            args: Prisma.GatewayAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGateway>
          }
          groupBy: {
            args: Prisma.GatewayGroupByArgs<ExtArgs>
            result: $Utils.Optional<GatewayGroupByOutputType>[]
          }
          count: {
            args: Prisma.GatewayCountArgs<ExtArgs>
            result: $Utils.Optional<GatewayCountAggregateOutputType> | number
          }
        }
      }
      RpmReading: {
        payload: Prisma.$RpmReadingPayload<ExtArgs>
        fields: Prisma.RpmReadingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RpmReadingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RpmReadingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RpmReadingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RpmReadingPayload>
          }
          findFirst: {
            args: Prisma.RpmReadingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RpmReadingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RpmReadingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RpmReadingPayload>
          }
          findMany: {
            args: Prisma.RpmReadingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RpmReadingPayload>[]
          }
          create: {
            args: Prisma.RpmReadingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RpmReadingPayload>
          }
          createMany: {
            args: Prisma.RpmReadingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RpmReadingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RpmReadingPayload>[]
          }
          delete: {
            args: Prisma.RpmReadingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RpmReadingPayload>
          }
          update: {
            args: Prisma.RpmReadingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RpmReadingPayload>
          }
          deleteMany: {
            args: Prisma.RpmReadingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RpmReadingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RpmReadingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RpmReadingPayload>[]
          }
          upsert: {
            args: Prisma.RpmReadingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RpmReadingPayload>
          }
          aggregate: {
            args: Prisma.RpmReadingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRpmReading>
          }
          groupBy: {
            args: Prisma.RpmReadingGroupByArgs<ExtArgs>
            result: $Utils.Optional<RpmReadingGroupByOutputType>[]
          }
          count: {
            args: Prisma.RpmReadingCountArgs<ExtArgs>
            result: $Utils.Optional<RpmReadingCountAggregateOutputType> | number
          }
        }
      }
      OilTemperatureReading: {
        payload: Prisma.$OilTemperatureReadingPayload<ExtArgs>
        fields: Prisma.OilTemperatureReadingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OilTemperatureReadingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OilTemperatureReadingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OilTemperatureReadingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OilTemperatureReadingPayload>
          }
          findFirst: {
            args: Prisma.OilTemperatureReadingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OilTemperatureReadingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OilTemperatureReadingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OilTemperatureReadingPayload>
          }
          findMany: {
            args: Prisma.OilTemperatureReadingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OilTemperatureReadingPayload>[]
          }
          create: {
            args: Prisma.OilTemperatureReadingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OilTemperatureReadingPayload>
          }
          createMany: {
            args: Prisma.OilTemperatureReadingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OilTemperatureReadingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OilTemperatureReadingPayload>[]
          }
          delete: {
            args: Prisma.OilTemperatureReadingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OilTemperatureReadingPayload>
          }
          update: {
            args: Prisma.OilTemperatureReadingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OilTemperatureReadingPayload>
          }
          deleteMany: {
            args: Prisma.OilTemperatureReadingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OilTemperatureReadingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OilTemperatureReadingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OilTemperatureReadingPayload>[]
          }
          upsert: {
            args: Prisma.OilTemperatureReadingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OilTemperatureReadingPayload>
          }
          aggregate: {
            args: Prisma.OilTemperatureReadingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOilTemperatureReading>
          }
          groupBy: {
            args: Prisma.OilTemperatureReadingGroupByArgs<ExtArgs>
            result: $Utils.Optional<OilTemperatureReadingGroupByOutputType>[]
          }
          count: {
            args: Prisma.OilTemperatureReadingCountArgs<ExtArgs>
            result: $Utils.Optional<OilTemperatureReadingCountAggregateOutputType> | number
          }
        }
      }
      OilLevelReading: {
        payload: Prisma.$OilLevelReadingPayload<ExtArgs>
        fields: Prisma.OilLevelReadingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OilLevelReadingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OilLevelReadingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OilLevelReadingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OilLevelReadingPayload>
          }
          findFirst: {
            args: Prisma.OilLevelReadingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OilLevelReadingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OilLevelReadingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OilLevelReadingPayload>
          }
          findMany: {
            args: Prisma.OilLevelReadingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OilLevelReadingPayload>[]
          }
          create: {
            args: Prisma.OilLevelReadingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OilLevelReadingPayload>
          }
          createMany: {
            args: Prisma.OilLevelReadingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OilLevelReadingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OilLevelReadingPayload>[]
          }
          delete: {
            args: Prisma.OilLevelReadingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OilLevelReadingPayload>
          }
          update: {
            args: Prisma.OilLevelReadingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OilLevelReadingPayload>
          }
          deleteMany: {
            args: Prisma.OilLevelReadingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OilLevelReadingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OilLevelReadingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OilLevelReadingPayload>[]
          }
          upsert: {
            args: Prisma.OilLevelReadingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OilLevelReadingPayload>
          }
          aggregate: {
            args: Prisma.OilLevelReadingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOilLevelReading>
          }
          groupBy: {
            args: Prisma.OilLevelReadingGroupByArgs<ExtArgs>
            result: $Utils.Optional<OilLevelReadingGroupByOutputType>[]
          }
          count: {
            args: Prisma.OilLevelReadingCountArgs<ExtArgs>
            result: $Utils.Optional<OilLevelReadingCountAggregateOutputType> | number
          }
        }
      }
      CurrentReading: {
        payload: Prisma.$CurrentReadingPayload<ExtArgs>
        fields: Prisma.CurrentReadingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CurrentReadingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrentReadingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CurrentReadingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrentReadingPayload>
          }
          findFirst: {
            args: Prisma.CurrentReadingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrentReadingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CurrentReadingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrentReadingPayload>
          }
          findMany: {
            args: Prisma.CurrentReadingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrentReadingPayload>[]
          }
          create: {
            args: Prisma.CurrentReadingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrentReadingPayload>
          }
          createMany: {
            args: Prisma.CurrentReadingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CurrentReadingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrentReadingPayload>[]
          }
          delete: {
            args: Prisma.CurrentReadingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrentReadingPayload>
          }
          update: {
            args: Prisma.CurrentReadingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrentReadingPayload>
          }
          deleteMany: {
            args: Prisma.CurrentReadingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CurrentReadingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CurrentReadingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrentReadingPayload>[]
          }
          upsert: {
            args: Prisma.CurrentReadingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrentReadingPayload>
          }
          aggregate: {
            args: Prisma.CurrentReadingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCurrentReading>
          }
          groupBy: {
            args: Prisma.CurrentReadingGroupByArgs<ExtArgs>
            result: $Utils.Optional<CurrentReadingGroupByOutputType>[]
          }
          count: {
            args: Prisma.CurrentReadingCountArgs<ExtArgs>
            result: $Utils.Optional<CurrentReadingCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    interacaoIA?: InteracaoIAOmit
    hyperparameterArm?: HyperparameterArmOmit
    client?: ClientOmit
    user?: UserOmit
    machine?: MachineOmit
    unifiedMachineState?: UnifiedMachineStateOmit
    device?: DeviceOmit
    gateway?: GatewayOmit
    rpmReading?: RpmReadingOmit
    oilTemperatureReading?: OilTemperatureReadingOmit
    oilLevelReading?: OilLevelReadingOmit
    currentReading?: CurrentReadingOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type HyperparameterArmCountOutputType
   */

  export type HyperparameterArmCountOutputType = {
    interacoes: number
  }

  export type HyperparameterArmCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interacoes?: boolean | HyperparameterArmCountOutputTypeCountInteracoesArgs
  }

  // Custom InputTypes
  /**
   * HyperparameterArmCountOutputType without action
   */
  export type HyperparameterArmCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HyperparameterArmCountOutputType
     */
    select?: HyperparameterArmCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HyperparameterArmCountOutputType without action
   */
  export type HyperparameterArmCountOutputTypeCountInteracoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InteracaoIAWhereInput
  }


  /**
   * Count Type ClientCountOutputType
   */

  export type ClientCountOutputType = {
    machines: number
    users: number
    devices: number
    gateways: number
  }

  export type ClientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    machines?: boolean | ClientCountOutputTypeCountMachinesArgs
    users?: boolean | ClientCountOutputTypeCountUsersArgs
    devices?: boolean | ClientCountOutputTypeCountDevicesArgs
    gateways?: boolean | ClientCountOutputTypeCountGatewaysArgs
  }

  // Custom InputTypes
  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCountOutputType
     */
    select?: ClientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountMachinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MachineWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountDevicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountGatewaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GatewayWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    currentReadings: number
    responsibleMachines: number
    oilLevelReadings: number
    oilTemperatureReadings: number
    rpmReadings: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    currentReadings?: boolean | UserCountOutputTypeCountCurrentReadingsArgs
    responsibleMachines?: boolean | UserCountOutputTypeCountResponsibleMachinesArgs
    oilLevelReadings?: boolean | UserCountOutputTypeCountOilLevelReadingsArgs
    oilTemperatureReadings?: boolean | UserCountOutputTypeCountOilTemperatureReadingsArgs
    rpmReadings?: boolean | UserCountOutputTypeCountRpmReadingsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCurrentReadingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CurrentReadingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountResponsibleMachinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MachineWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOilLevelReadingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OilLevelReadingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOilTemperatureReadingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OilTemperatureReadingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRpmReadingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RpmReadingWhereInput
  }


  /**
   * Count Type MachineCountOutputType
   */

  export type MachineCountOutputType = {
    UnifiedMachineState: number
    currentReadings: number
    oilLevelReadings: number
    oilTemperatureReadings: number
    rpmReadings: number
  }

  export type MachineCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    UnifiedMachineState?: boolean | MachineCountOutputTypeCountUnifiedMachineStateArgs
    currentReadings?: boolean | MachineCountOutputTypeCountCurrentReadingsArgs
    oilLevelReadings?: boolean | MachineCountOutputTypeCountOilLevelReadingsArgs
    oilTemperatureReadings?: boolean | MachineCountOutputTypeCountOilTemperatureReadingsArgs
    rpmReadings?: boolean | MachineCountOutputTypeCountRpmReadingsArgs
  }

  // Custom InputTypes
  /**
   * MachineCountOutputType without action
   */
  export type MachineCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MachineCountOutputType
     */
    select?: MachineCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MachineCountOutputType without action
   */
  export type MachineCountOutputTypeCountUnifiedMachineStateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnifiedMachineStateWhereInput
  }

  /**
   * MachineCountOutputType without action
   */
  export type MachineCountOutputTypeCountCurrentReadingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CurrentReadingWhereInput
  }

  /**
   * MachineCountOutputType without action
   */
  export type MachineCountOutputTypeCountOilLevelReadingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OilLevelReadingWhereInput
  }

  /**
   * MachineCountOutputType without action
   */
  export type MachineCountOutputTypeCountOilTemperatureReadingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OilTemperatureReadingWhereInput
  }

  /**
   * MachineCountOutputType without action
   */
  export type MachineCountOutputTypeCountRpmReadingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RpmReadingWhereInput
  }


  /**
   * Count Type GatewayCountOutputType
   */

  export type GatewayCountOutputType = {
    responsibleFor: number
  }

  export type GatewayCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    responsibleFor?: boolean | GatewayCountOutputTypeCountResponsibleForArgs
  }

  // Custom InputTypes
  /**
   * GatewayCountOutputType without action
   */
  export type GatewayCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GatewayCountOutputType
     */
    select?: GatewayCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GatewayCountOutputType without action
   */
  export type GatewayCountOutputTypeCountResponsibleForArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceWhereInput
  }


  /**
   * Models
   */

  /**
   * Model InteracaoIA
   */

  export type AggregateInteracaoIA = {
    _count: InteracaoIACountAggregateOutputType | null
    _avg: InteracaoIAAvgAggregateOutputType | null
    _sum: InteracaoIASumAggregateOutputType | null
    _min: InteracaoIAMinAggregateOutputType | null
    _max: InteracaoIAMaxAggregateOutputType | null
  }

  export type InteracaoIAAvgAggregateOutputType = {
    id: number | null
    feedbackUsuario: number | null
  }

  export type InteracaoIASumAggregateOutputType = {
    id: number | null
    feedbackUsuario: number | null
  }

  export type InteracaoIAMinAggregateOutputType = {
    id: number | null
    perguntaUsuario: string | null
    queryMontada: string | null
    respostaHumanizada: string | null
    feedbackUsuario: number | null
    criadoEm: Date | null
    atualizadoEm: Date | null
    hyperparameterArmId: string | null
  }

  export type InteracaoIAMaxAggregateOutputType = {
    id: number | null
    perguntaUsuario: string | null
    queryMontada: string | null
    respostaHumanizada: string | null
    feedbackUsuario: number | null
    criadoEm: Date | null
    atualizadoEm: Date | null
    hyperparameterArmId: string | null
  }

  export type InteracaoIACountAggregateOutputType = {
    id: number
    perguntaUsuario: number
    queryMontada: number
    respostaHumanizada: number
    feedbackUsuario: number
    criadoEm: number
    atualizadoEm: number
    hyperparameterArmId: number
    _all: number
  }


  export type InteracaoIAAvgAggregateInputType = {
    id?: true
    feedbackUsuario?: true
  }

  export type InteracaoIASumAggregateInputType = {
    id?: true
    feedbackUsuario?: true
  }

  export type InteracaoIAMinAggregateInputType = {
    id?: true
    perguntaUsuario?: true
    queryMontada?: true
    respostaHumanizada?: true
    feedbackUsuario?: true
    criadoEm?: true
    atualizadoEm?: true
    hyperparameterArmId?: true
  }

  export type InteracaoIAMaxAggregateInputType = {
    id?: true
    perguntaUsuario?: true
    queryMontada?: true
    respostaHumanizada?: true
    feedbackUsuario?: true
    criadoEm?: true
    atualizadoEm?: true
    hyperparameterArmId?: true
  }

  export type InteracaoIACountAggregateInputType = {
    id?: true
    perguntaUsuario?: true
    queryMontada?: true
    respostaHumanizada?: true
    feedbackUsuario?: true
    criadoEm?: true
    atualizadoEm?: true
    hyperparameterArmId?: true
    _all?: true
  }

  export type InteracaoIAAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InteracaoIA to aggregate.
     */
    where?: InteracaoIAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InteracaoIAS to fetch.
     */
    orderBy?: InteracaoIAOrderByWithRelationInput | InteracaoIAOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InteracaoIAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InteracaoIAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InteracaoIAS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InteracaoIAS
    **/
    _count?: true | InteracaoIACountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InteracaoIAAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InteracaoIASumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InteracaoIAMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InteracaoIAMaxAggregateInputType
  }

  export type GetInteracaoIAAggregateType<T extends InteracaoIAAggregateArgs> = {
        [P in keyof T & keyof AggregateInteracaoIA]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInteracaoIA[P]>
      : GetScalarType<T[P], AggregateInteracaoIA[P]>
  }




  export type InteracaoIAGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InteracaoIAWhereInput
    orderBy?: InteracaoIAOrderByWithAggregationInput | InteracaoIAOrderByWithAggregationInput[]
    by: InteracaoIAScalarFieldEnum[] | InteracaoIAScalarFieldEnum
    having?: InteracaoIAScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InteracaoIACountAggregateInputType | true
    _avg?: InteracaoIAAvgAggregateInputType
    _sum?: InteracaoIASumAggregateInputType
    _min?: InteracaoIAMinAggregateInputType
    _max?: InteracaoIAMaxAggregateInputType
  }

  export type InteracaoIAGroupByOutputType = {
    id: number
    perguntaUsuario: string
    queryMontada: string
    respostaHumanizada: string
    feedbackUsuario: number | null
    criadoEm: Date
    atualizadoEm: Date
    hyperparameterArmId: string
    _count: InteracaoIACountAggregateOutputType | null
    _avg: InteracaoIAAvgAggregateOutputType | null
    _sum: InteracaoIASumAggregateOutputType | null
    _min: InteracaoIAMinAggregateOutputType | null
    _max: InteracaoIAMaxAggregateOutputType | null
  }

  type GetInteracaoIAGroupByPayload<T extends InteracaoIAGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InteracaoIAGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InteracaoIAGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InteracaoIAGroupByOutputType[P]>
            : GetScalarType<T[P], InteracaoIAGroupByOutputType[P]>
        }
      >
    >


  export type InteracaoIASelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    perguntaUsuario?: boolean
    queryMontada?: boolean
    respostaHumanizada?: boolean
    feedbackUsuario?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    hyperparameterArmId?: boolean
    hyperparameterArm?: boolean | HyperparameterArmDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interacaoIA"]>

  export type InteracaoIASelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    perguntaUsuario?: boolean
    queryMontada?: boolean
    respostaHumanizada?: boolean
    feedbackUsuario?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    hyperparameterArmId?: boolean
    hyperparameterArm?: boolean | HyperparameterArmDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interacaoIA"]>

  export type InteracaoIASelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    perguntaUsuario?: boolean
    queryMontada?: boolean
    respostaHumanizada?: boolean
    feedbackUsuario?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    hyperparameterArmId?: boolean
    hyperparameterArm?: boolean | HyperparameterArmDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interacaoIA"]>

  export type InteracaoIASelectScalar = {
    id?: boolean
    perguntaUsuario?: boolean
    queryMontada?: boolean
    respostaHumanizada?: boolean
    feedbackUsuario?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    hyperparameterArmId?: boolean
  }

  export type InteracaoIAOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "perguntaUsuario" | "queryMontada" | "respostaHumanizada" | "feedbackUsuario" | "criadoEm" | "atualizadoEm" | "hyperparameterArmId", ExtArgs["result"]["interacaoIA"]>
  export type InteracaoIAInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hyperparameterArm?: boolean | HyperparameterArmDefaultArgs<ExtArgs>
  }
  export type InteracaoIAIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hyperparameterArm?: boolean | HyperparameterArmDefaultArgs<ExtArgs>
  }
  export type InteracaoIAIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hyperparameterArm?: boolean | HyperparameterArmDefaultArgs<ExtArgs>
  }

  export type $InteracaoIAPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InteracaoIA"
    objects: {
      hyperparameterArm: Prisma.$HyperparameterArmPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      perguntaUsuario: string
      queryMontada: string
      respostaHumanizada: string
      feedbackUsuario: number | null
      criadoEm: Date
      atualizadoEm: Date
      hyperparameterArmId: string
    }, ExtArgs["result"]["interacaoIA"]>
    composites: {}
  }

  type InteracaoIAGetPayload<S extends boolean | null | undefined | InteracaoIADefaultArgs> = $Result.GetResult<Prisma.$InteracaoIAPayload, S>

  type InteracaoIACountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InteracaoIAFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InteracaoIACountAggregateInputType | true
    }

  export interface InteracaoIADelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InteracaoIA'], meta: { name: 'InteracaoIA' } }
    /**
     * Find zero or one InteracaoIA that matches the filter.
     * @param {InteracaoIAFindUniqueArgs} args - Arguments to find a InteracaoIA
     * @example
     * // Get one InteracaoIA
     * const interacaoIA = await prisma.interacaoIA.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InteracaoIAFindUniqueArgs>(args: SelectSubset<T, InteracaoIAFindUniqueArgs<ExtArgs>>): Prisma__InteracaoIAClient<$Result.GetResult<Prisma.$InteracaoIAPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InteracaoIA that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InteracaoIAFindUniqueOrThrowArgs} args - Arguments to find a InteracaoIA
     * @example
     * // Get one InteracaoIA
     * const interacaoIA = await prisma.interacaoIA.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InteracaoIAFindUniqueOrThrowArgs>(args: SelectSubset<T, InteracaoIAFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InteracaoIAClient<$Result.GetResult<Prisma.$InteracaoIAPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InteracaoIA that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteracaoIAFindFirstArgs} args - Arguments to find a InteracaoIA
     * @example
     * // Get one InteracaoIA
     * const interacaoIA = await prisma.interacaoIA.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InteracaoIAFindFirstArgs>(args?: SelectSubset<T, InteracaoIAFindFirstArgs<ExtArgs>>): Prisma__InteracaoIAClient<$Result.GetResult<Prisma.$InteracaoIAPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InteracaoIA that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteracaoIAFindFirstOrThrowArgs} args - Arguments to find a InteracaoIA
     * @example
     * // Get one InteracaoIA
     * const interacaoIA = await prisma.interacaoIA.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InteracaoIAFindFirstOrThrowArgs>(args?: SelectSubset<T, InteracaoIAFindFirstOrThrowArgs<ExtArgs>>): Prisma__InteracaoIAClient<$Result.GetResult<Prisma.$InteracaoIAPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InteracaoIAS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteracaoIAFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InteracaoIAS
     * const interacaoIAS = await prisma.interacaoIA.findMany()
     * 
     * // Get first 10 InteracaoIAS
     * const interacaoIAS = await prisma.interacaoIA.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const interacaoIAWithIdOnly = await prisma.interacaoIA.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InteracaoIAFindManyArgs>(args?: SelectSubset<T, InteracaoIAFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InteracaoIAPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InteracaoIA.
     * @param {InteracaoIACreateArgs} args - Arguments to create a InteracaoIA.
     * @example
     * // Create one InteracaoIA
     * const InteracaoIA = await prisma.interacaoIA.create({
     *   data: {
     *     // ... data to create a InteracaoIA
     *   }
     * })
     * 
     */
    create<T extends InteracaoIACreateArgs>(args: SelectSubset<T, InteracaoIACreateArgs<ExtArgs>>): Prisma__InteracaoIAClient<$Result.GetResult<Prisma.$InteracaoIAPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InteracaoIAS.
     * @param {InteracaoIACreateManyArgs} args - Arguments to create many InteracaoIAS.
     * @example
     * // Create many InteracaoIAS
     * const interacaoIA = await prisma.interacaoIA.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InteracaoIACreateManyArgs>(args?: SelectSubset<T, InteracaoIACreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InteracaoIAS and returns the data saved in the database.
     * @param {InteracaoIACreateManyAndReturnArgs} args - Arguments to create many InteracaoIAS.
     * @example
     * // Create many InteracaoIAS
     * const interacaoIA = await prisma.interacaoIA.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InteracaoIAS and only return the `id`
     * const interacaoIAWithIdOnly = await prisma.interacaoIA.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InteracaoIACreateManyAndReturnArgs>(args?: SelectSubset<T, InteracaoIACreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InteracaoIAPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InteracaoIA.
     * @param {InteracaoIADeleteArgs} args - Arguments to delete one InteracaoIA.
     * @example
     * // Delete one InteracaoIA
     * const InteracaoIA = await prisma.interacaoIA.delete({
     *   where: {
     *     // ... filter to delete one InteracaoIA
     *   }
     * })
     * 
     */
    delete<T extends InteracaoIADeleteArgs>(args: SelectSubset<T, InteracaoIADeleteArgs<ExtArgs>>): Prisma__InteracaoIAClient<$Result.GetResult<Prisma.$InteracaoIAPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InteracaoIA.
     * @param {InteracaoIAUpdateArgs} args - Arguments to update one InteracaoIA.
     * @example
     * // Update one InteracaoIA
     * const interacaoIA = await prisma.interacaoIA.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InteracaoIAUpdateArgs>(args: SelectSubset<T, InteracaoIAUpdateArgs<ExtArgs>>): Prisma__InteracaoIAClient<$Result.GetResult<Prisma.$InteracaoIAPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InteracaoIAS.
     * @param {InteracaoIADeleteManyArgs} args - Arguments to filter InteracaoIAS to delete.
     * @example
     * // Delete a few InteracaoIAS
     * const { count } = await prisma.interacaoIA.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InteracaoIADeleteManyArgs>(args?: SelectSubset<T, InteracaoIADeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InteracaoIAS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteracaoIAUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InteracaoIAS
     * const interacaoIA = await prisma.interacaoIA.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InteracaoIAUpdateManyArgs>(args: SelectSubset<T, InteracaoIAUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InteracaoIAS and returns the data updated in the database.
     * @param {InteracaoIAUpdateManyAndReturnArgs} args - Arguments to update many InteracaoIAS.
     * @example
     * // Update many InteracaoIAS
     * const interacaoIA = await prisma.interacaoIA.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InteracaoIAS and only return the `id`
     * const interacaoIAWithIdOnly = await prisma.interacaoIA.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InteracaoIAUpdateManyAndReturnArgs>(args: SelectSubset<T, InteracaoIAUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InteracaoIAPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InteracaoIA.
     * @param {InteracaoIAUpsertArgs} args - Arguments to update or create a InteracaoIA.
     * @example
     * // Update or create a InteracaoIA
     * const interacaoIA = await prisma.interacaoIA.upsert({
     *   create: {
     *     // ... data to create a InteracaoIA
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InteracaoIA we want to update
     *   }
     * })
     */
    upsert<T extends InteracaoIAUpsertArgs>(args: SelectSubset<T, InteracaoIAUpsertArgs<ExtArgs>>): Prisma__InteracaoIAClient<$Result.GetResult<Prisma.$InteracaoIAPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InteracaoIAS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteracaoIACountArgs} args - Arguments to filter InteracaoIAS to count.
     * @example
     * // Count the number of InteracaoIAS
     * const count = await prisma.interacaoIA.count({
     *   where: {
     *     // ... the filter for the InteracaoIAS we want to count
     *   }
     * })
    **/
    count<T extends InteracaoIACountArgs>(
      args?: Subset<T, InteracaoIACountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InteracaoIACountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InteracaoIA.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteracaoIAAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InteracaoIAAggregateArgs>(args: Subset<T, InteracaoIAAggregateArgs>): Prisma.PrismaPromise<GetInteracaoIAAggregateType<T>>

    /**
     * Group by InteracaoIA.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteracaoIAGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InteracaoIAGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InteracaoIAGroupByArgs['orderBy'] }
        : { orderBy?: InteracaoIAGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InteracaoIAGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInteracaoIAGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InteracaoIA model
   */
  readonly fields: InteracaoIAFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InteracaoIA.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InteracaoIAClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    hyperparameterArm<T extends HyperparameterArmDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HyperparameterArmDefaultArgs<ExtArgs>>): Prisma__HyperparameterArmClient<$Result.GetResult<Prisma.$HyperparameterArmPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InteracaoIA model
   */
  interface InteracaoIAFieldRefs {
    readonly id: FieldRef<"InteracaoIA", 'Int'>
    readonly perguntaUsuario: FieldRef<"InteracaoIA", 'String'>
    readonly queryMontada: FieldRef<"InteracaoIA", 'String'>
    readonly respostaHumanizada: FieldRef<"InteracaoIA", 'String'>
    readonly feedbackUsuario: FieldRef<"InteracaoIA", 'Int'>
    readonly criadoEm: FieldRef<"InteracaoIA", 'DateTime'>
    readonly atualizadoEm: FieldRef<"InteracaoIA", 'DateTime'>
    readonly hyperparameterArmId: FieldRef<"InteracaoIA", 'String'>
  }
    

  // Custom InputTypes
  /**
   * InteracaoIA findUnique
   */
  export type InteracaoIAFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteracaoIA
     */
    select?: InteracaoIASelect<ExtArgs> | null
    /**
     * Omit specific fields from the InteracaoIA
     */
    omit?: InteracaoIAOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteracaoIAInclude<ExtArgs> | null
    /**
     * Filter, which InteracaoIA to fetch.
     */
    where: InteracaoIAWhereUniqueInput
  }

  /**
   * InteracaoIA findUniqueOrThrow
   */
  export type InteracaoIAFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteracaoIA
     */
    select?: InteracaoIASelect<ExtArgs> | null
    /**
     * Omit specific fields from the InteracaoIA
     */
    omit?: InteracaoIAOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteracaoIAInclude<ExtArgs> | null
    /**
     * Filter, which InteracaoIA to fetch.
     */
    where: InteracaoIAWhereUniqueInput
  }

  /**
   * InteracaoIA findFirst
   */
  export type InteracaoIAFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteracaoIA
     */
    select?: InteracaoIASelect<ExtArgs> | null
    /**
     * Omit specific fields from the InteracaoIA
     */
    omit?: InteracaoIAOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteracaoIAInclude<ExtArgs> | null
    /**
     * Filter, which InteracaoIA to fetch.
     */
    where?: InteracaoIAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InteracaoIAS to fetch.
     */
    orderBy?: InteracaoIAOrderByWithRelationInput | InteracaoIAOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InteracaoIAS.
     */
    cursor?: InteracaoIAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InteracaoIAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InteracaoIAS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InteracaoIAS.
     */
    distinct?: InteracaoIAScalarFieldEnum | InteracaoIAScalarFieldEnum[]
  }

  /**
   * InteracaoIA findFirstOrThrow
   */
  export type InteracaoIAFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteracaoIA
     */
    select?: InteracaoIASelect<ExtArgs> | null
    /**
     * Omit specific fields from the InteracaoIA
     */
    omit?: InteracaoIAOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteracaoIAInclude<ExtArgs> | null
    /**
     * Filter, which InteracaoIA to fetch.
     */
    where?: InteracaoIAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InteracaoIAS to fetch.
     */
    orderBy?: InteracaoIAOrderByWithRelationInput | InteracaoIAOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InteracaoIAS.
     */
    cursor?: InteracaoIAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InteracaoIAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InteracaoIAS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InteracaoIAS.
     */
    distinct?: InteracaoIAScalarFieldEnum | InteracaoIAScalarFieldEnum[]
  }

  /**
   * InteracaoIA findMany
   */
  export type InteracaoIAFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteracaoIA
     */
    select?: InteracaoIASelect<ExtArgs> | null
    /**
     * Omit specific fields from the InteracaoIA
     */
    omit?: InteracaoIAOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteracaoIAInclude<ExtArgs> | null
    /**
     * Filter, which InteracaoIAS to fetch.
     */
    where?: InteracaoIAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InteracaoIAS to fetch.
     */
    orderBy?: InteracaoIAOrderByWithRelationInput | InteracaoIAOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InteracaoIAS.
     */
    cursor?: InteracaoIAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InteracaoIAS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InteracaoIAS.
     */
    skip?: number
    distinct?: InteracaoIAScalarFieldEnum | InteracaoIAScalarFieldEnum[]
  }

  /**
   * InteracaoIA create
   */
  export type InteracaoIACreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteracaoIA
     */
    select?: InteracaoIASelect<ExtArgs> | null
    /**
     * Omit specific fields from the InteracaoIA
     */
    omit?: InteracaoIAOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteracaoIAInclude<ExtArgs> | null
    /**
     * The data needed to create a InteracaoIA.
     */
    data: XOR<InteracaoIACreateInput, InteracaoIAUncheckedCreateInput>
  }

  /**
   * InteracaoIA createMany
   */
  export type InteracaoIACreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InteracaoIAS.
     */
    data: InteracaoIACreateManyInput | InteracaoIACreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InteracaoIA createManyAndReturn
   */
  export type InteracaoIACreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteracaoIA
     */
    select?: InteracaoIASelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InteracaoIA
     */
    omit?: InteracaoIAOmit<ExtArgs> | null
    /**
     * The data used to create many InteracaoIAS.
     */
    data: InteracaoIACreateManyInput | InteracaoIACreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteracaoIAIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InteracaoIA update
   */
  export type InteracaoIAUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteracaoIA
     */
    select?: InteracaoIASelect<ExtArgs> | null
    /**
     * Omit specific fields from the InteracaoIA
     */
    omit?: InteracaoIAOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteracaoIAInclude<ExtArgs> | null
    /**
     * The data needed to update a InteracaoIA.
     */
    data: XOR<InteracaoIAUpdateInput, InteracaoIAUncheckedUpdateInput>
    /**
     * Choose, which InteracaoIA to update.
     */
    where: InteracaoIAWhereUniqueInput
  }

  /**
   * InteracaoIA updateMany
   */
  export type InteracaoIAUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InteracaoIAS.
     */
    data: XOR<InteracaoIAUpdateManyMutationInput, InteracaoIAUncheckedUpdateManyInput>
    /**
     * Filter which InteracaoIAS to update
     */
    where?: InteracaoIAWhereInput
    /**
     * Limit how many InteracaoIAS to update.
     */
    limit?: number
  }

  /**
   * InteracaoIA updateManyAndReturn
   */
  export type InteracaoIAUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteracaoIA
     */
    select?: InteracaoIASelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InteracaoIA
     */
    omit?: InteracaoIAOmit<ExtArgs> | null
    /**
     * The data used to update InteracaoIAS.
     */
    data: XOR<InteracaoIAUpdateManyMutationInput, InteracaoIAUncheckedUpdateManyInput>
    /**
     * Filter which InteracaoIAS to update
     */
    where?: InteracaoIAWhereInput
    /**
     * Limit how many InteracaoIAS to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteracaoIAIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InteracaoIA upsert
   */
  export type InteracaoIAUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteracaoIA
     */
    select?: InteracaoIASelect<ExtArgs> | null
    /**
     * Omit specific fields from the InteracaoIA
     */
    omit?: InteracaoIAOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteracaoIAInclude<ExtArgs> | null
    /**
     * The filter to search for the InteracaoIA to update in case it exists.
     */
    where: InteracaoIAWhereUniqueInput
    /**
     * In case the InteracaoIA found by the `where` argument doesn't exist, create a new InteracaoIA with this data.
     */
    create: XOR<InteracaoIACreateInput, InteracaoIAUncheckedCreateInput>
    /**
     * In case the InteracaoIA was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InteracaoIAUpdateInput, InteracaoIAUncheckedUpdateInput>
  }

  /**
   * InteracaoIA delete
   */
  export type InteracaoIADeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteracaoIA
     */
    select?: InteracaoIASelect<ExtArgs> | null
    /**
     * Omit specific fields from the InteracaoIA
     */
    omit?: InteracaoIAOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteracaoIAInclude<ExtArgs> | null
    /**
     * Filter which InteracaoIA to delete.
     */
    where: InteracaoIAWhereUniqueInput
  }

  /**
   * InteracaoIA deleteMany
   */
  export type InteracaoIADeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InteracaoIAS to delete
     */
    where?: InteracaoIAWhereInput
    /**
     * Limit how many InteracaoIAS to delete.
     */
    limit?: number
  }

  /**
   * InteracaoIA without action
   */
  export type InteracaoIADefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteracaoIA
     */
    select?: InteracaoIASelect<ExtArgs> | null
    /**
     * Omit specific fields from the InteracaoIA
     */
    omit?: InteracaoIAOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteracaoIAInclude<ExtArgs> | null
  }


  /**
   * Model HyperparameterArm
   */

  export type AggregateHyperparameterArm = {
    _count: HyperparameterArmCountAggregateOutputType | null
    _avg: HyperparameterArmAvgAggregateOutputType | null
    _sum: HyperparameterArmSumAggregateOutputType | null
    _min: HyperparameterArmMinAggregateOutputType | null
    _max: HyperparameterArmMaxAggregateOutputType | null
  }

  export type HyperparameterArmAvgAggregateOutputType = {
    temperature: number | null
    topP: number | null
    topK: number | null
    maxOutputTokens: number | null
    successes: number | null
    failures: number | null
  }

  export type HyperparameterArmSumAggregateOutputType = {
    temperature: number | null
    topP: number | null
    topK: number | null
    maxOutputTokens: number | null
    successes: number | null
    failures: number | null
  }

  export type HyperparameterArmMinAggregateOutputType = {
    id: string | null
    modelName: string | null
    version: string | null
    temperature: number | null
    topP: number | null
    topK: number | null
    maxOutputTokens: number | null
    responseMimeType: string | null
    successes: number | null
    failures: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HyperparameterArmMaxAggregateOutputType = {
    id: string | null
    modelName: string | null
    version: string | null
    temperature: number | null
    topP: number | null
    topK: number | null
    maxOutputTokens: number | null
    responseMimeType: string | null
    successes: number | null
    failures: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HyperparameterArmCountAggregateOutputType = {
    id: number
    modelName: number
    version: number
    temperature: number
    topP: number
    topK: number
    maxOutputTokens: number
    responseMimeType: number
    successes: number
    failures: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HyperparameterArmAvgAggregateInputType = {
    temperature?: true
    topP?: true
    topK?: true
    maxOutputTokens?: true
    successes?: true
    failures?: true
  }

  export type HyperparameterArmSumAggregateInputType = {
    temperature?: true
    topP?: true
    topK?: true
    maxOutputTokens?: true
    successes?: true
    failures?: true
  }

  export type HyperparameterArmMinAggregateInputType = {
    id?: true
    modelName?: true
    version?: true
    temperature?: true
    topP?: true
    topK?: true
    maxOutputTokens?: true
    responseMimeType?: true
    successes?: true
    failures?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HyperparameterArmMaxAggregateInputType = {
    id?: true
    modelName?: true
    version?: true
    temperature?: true
    topP?: true
    topK?: true
    maxOutputTokens?: true
    responseMimeType?: true
    successes?: true
    failures?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HyperparameterArmCountAggregateInputType = {
    id?: true
    modelName?: true
    version?: true
    temperature?: true
    topP?: true
    topK?: true
    maxOutputTokens?: true
    responseMimeType?: true
    successes?: true
    failures?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HyperparameterArmAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HyperparameterArm to aggregate.
     */
    where?: HyperparameterArmWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HyperparameterArms to fetch.
     */
    orderBy?: HyperparameterArmOrderByWithRelationInput | HyperparameterArmOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HyperparameterArmWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HyperparameterArms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HyperparameterArms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HyperparameterArms
    **/
    _count?: true | HyperparameterArmCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HyperparameterArmAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HyperparameterArmSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HyperparameterArmMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HyperparameterArmMaxAggregateInputType
  }

  export type GetHyperparameterArmAggregateType<T extends HyperparameterArmAggregateArgs> = {
        [P in keyof T & keyof AggregateHyperparameterArm]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHyperparameterArm[P]>
      : GetScalarType<T[P], AggregateHyperparameterArm[P]>
  }




  export type HyperparameterArmGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HyperparameterArmWhereInput
    orderBy?: HyperparameterArmOrderByWithAggregationInput | HyperparameterArmOrderByWithAggregationInput[]
    by: HyperparameterArmScalarFieldEnum[] | HyperparameterArmScalarFieldEnum
    having?: HyperparameterArmScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HyperparameterArmCountAggregateInputType | true
    _avg?: HyperparameterArmAvgAggregateInputType
    _sum?: HyperparameterArmSumAggregateInputType
    _min?: HyperparameterArmMinAggregateInputType
    _max?: HyperparameterArmMaxAggregateInputType
  }

  export type HyperparameterArmGroupByOutputType = {
    id: string
    modelName: string | null
    version: string | null
    temperature: number
    topP: number
    topK: number
    maxOutputTokens: number
    responseMimeType: string
    successes: number | null
    failures: number | null
    createdAt: Date
    updatedAt: Date
    _count: HyperparameterArmCountAggregateOutputType | null
    _avg: HyperparameterArmAvgAggregateOutputType | null
    _sum: HyperparameterArmSumAggregateOutputType | null
    _min: HyperparameterArmMinAggregateOutputType | null
    _max: HyperparameterArmMaxAggregateOutputType | null
  }

  type GetHyperparameterArmGroupByPayload<T extends HyperparameterArmGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HyperparameterArmGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HyperparameterArmGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HyperparameterArmGroupByOutputType[P]>
            : GetScalarType<T[P], HyperparameterArmGroupByOutputType[P]>
        }
      >
    >


  export type HyperparameterArmSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    modelName?: boolean
    version?: boolean
    temperature?: boolean
    topP?: boolean
    topK?: boolean
    maxOutputTokens?: boolean
    responseMimeType?: boolean
    successes?: boolean
    failures?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    interacoes?: boolean | HyperparameterArm$interacoesArgs<ExtArgs>
    _count?: boolean | HyperparameterArmCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hyperparameterArm"]>

  export type HyperparameterArmSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    modelName?: boolean
    version?: boolean
    temperature?: boolean
    topP?: boolean
    topK?: boolean
    maxOutputTokens?: boolean
    responseMimeType?: boolean
    successes?: boolean
    failures?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["hyperparameterArm"]>

  export type HyperparameterArmSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    modelName?: boolean
    version?: boolean
    temperature?: boolean
    topP?: boolean
    topK?: boolean
    maxOutputTokens?: boolean
    responseMimeType?: boolean
    successes?: boolean
    failures?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["hyperparameterArm"]>

  export type HyperparameterArmSelectScalar = {
    id?: boolean
    modelName?: boolean
    version?: boolean
    temperature?: boolean
    topP?: boolean
    topK?: boolean
    maxOutputTokens?: boolean
    responseMimeType?: boolean
    successes?: boolean
    failures?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HyperparameterArmOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "modelName" | "version" | "temperature" | "topP" | "topK" | "maxOutputTokens" | "responseMimeType" | "successes" | "failures" | "createdAt" | "updatedAt", ExtArgs["result"]["hyperparameterArm"]>
  export type HyperparameterArmInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interacoes?: boolean | HyperparameterArm$interacoesArgs<ExtArgs>
    _count?: boolean | HyperparameterArmCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type HyperparameterArmIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type HyperparameterArmIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $HyperparameterArmPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HyperparameterArm"
    objects: {
      interacoes: Prisma.$InteracaoIAPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      modelName: string | null
      version: string | null
      temperature: number
      topP: number
      topK: number
      maxOutputTokens: number
      responseMimeType: string
      successes: number | null
      failures: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["hyperparameterArm"]>
    composites: {}
  }

  type HyperparameterArmGetPayload<S extends boolean | null | undefined | HyperparameterArmDefaultArgs> = $Result.GetResult<Prisma.$HyperparameterArmPayload, S>

  type HyperparameterArmCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HyperparameterArmFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HyperparameterArmCountAggregateInputType | true
    }

  export interface HyperparameterArmDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HyperparameterArm'], meta: { name: 'HyperparameterArm' } }
    /**
     * Find zero or one HyperparameterArm that matches the filter.
     * @param {HyperparameterArmFindUniqueArgs} args - Arguments to find a HyperparameterArm
     * @example
     * // Get one HyperparameterArm
     * const hyperparameterArm = await prisma.hyperparameterArm.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HyperparameterArmFindUniqueArgs>(args: SelectSubset<T, HyperparameterArmFindUniqueArgs<ExtArgs>>): Prisma__HyperparameterArmClient<$Result.GetResult<Prisma.$HyperparameterArmPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one HyperparameterArm that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HyperparameterArmFindUniqueOrThrowArgs} args - Arguments to find a HyperparameterArm
     * @example
     * // Get one HyperparameterArm
     * const hyperparameterArm = await prisma.hyperparameterArm.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HyperparameterArmFindUniqueOrThrowArgs>(args: SelectSubset<T, HyperparameterArmFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HyperparameterArmClient<$Result.GetResult<Prisma.$HyperparameterArmPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HyperparameterArm that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HyperparameterArmFindFirstArgs} args - Arguments to find a HyperparameterArm
     * @example
     * // Get one HyperparameterArm
     * const hyperparameterArm = await prisma.hyperparameterArm.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HyperparameterArmFindFirstArgs>(args?: SelectSubset<T, HyperparameterArmFindFirstArgs<ExtArgs>>): Prisma__HyperparameterArmClient<$Result.GetResult<Prisma.$HyperparameterArmPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HyperparameterArm that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HyperparameterArmFindFirstOrThrowArgs} args - Arguments to find a HyperparameterArm
     * @example
     * // Get one HyperparameterArm
     * const hyperparameterArm = await prisma.hyperparameterArm.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HyperparameterArmFindFirstOrThrowArgs>(args?: SelectSubset<T, HyperparameterArmFindFirstOrThrowArgs<ExtArgs>>): Prisma__HyperparameterArmClient<$Result.GetResult<Prisma.$HyperparameterArmPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more HyperparameterArms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HyperparameterArmFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HyperparameterArms
     * const hyperparameterArms = await prisma.hyperparameterArm.findMany()
     * 
     * // Get first 10 HyperparameterArms
     * const hyperparameterArms = await prisma.hyperparameterArm.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hyperparameterArmWithIdOnly = await prisma.hyperparameterArm.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HyperparameterArmFindManyArgs>(args?: SelectSubset<T, HyperparameterArmFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HyperparameterArmPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a HyperparameterArm.
     * @param {HyperparameterArmCreateArgs} args - Arguments to create a HyperparameterArm.
     * @example
     * // Create one HyperparameterArm
     * const HyperparameterArm = await prisma.hyperparameterArm.create({
     *   data: {
     *     // ... data to create a HyperparameterArm
     *   }
     * })
     * 
     */
    create<T extends HyperparameterArmCreateArgs>(args: SelectSubset<T, HyperparameterArmCreateArgs<ExtArgs>>): Prisma__HyperparameterArmClient<$Result.GetResult<Prisma.$HyperparameterArmPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many HyperparameterArms.
     * @param {HyperparameterArmCreateManyArgs} args - Arguments to create many HyperparameterArms.
     * @example
     * // Create many HyperparameterArms
     * const hyperparameterArm = await prisma.hyperparameterArm.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HyperparameterArmCreateManyArgs>(args?: SelectSubset<T, HyperparameterArmCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HyperparameterArms and returns the data saved in the database.
     * @param {HyperparameterArmCreateManyAndReturnArgs} args - Arguments to create many HyperparameterArms.
     * @example
     * // Create many HyperparameterArms
     * const hyperparameterArm = await prisma.hyperparameterArm.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HyperparameterArms and only return the `id`
     * const hyperparameterArmWithIdOnly = await prisma.hyperparameterArm.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HyperparameterArmCreateManyAndReturnArgs>(args?: SelectSubset<T, HyperparameterArmCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HyperparameterArmPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a HyperparameterArm.
     * @param {HyperparameterArmDeleteArgs} args - Arguments to delete one HyperparameterArm.
     * @example
     * // Delete one HyperparameterArm
     * const HyperparameterArm = await prisma.hyperparameterArm.delete({
     *   where: {
     *     // ... filter to delete one HyperparameterArm
     *   }
     * })
     * 
     */
    delete<T extends HyperparameterArmDeleteArgs>(args: SelectSubset<T, HyperparameterArmDeleteArgs<ExtArgs>>): Prisma__HyperparameterArmClient<$Result.GetResult<Prisma.$HyperparameterArmPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one HyperparameterArm.
     * @param {HyperparameterArmUpdateArgs} args - Arguments to update one HyperparameterArm.
     * @example
     * // Update one HyperparameterArm
     * const hyperparameterArm = await prisma.hyperparameterArm.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HyperparameterArmUpdateArgs>(args: SelectSubset<T, HyperparameterArmUpdateArgs<ExtArgs>>): Prisma__HyperparameterArmClient<$Result.GetResult<Prisma.$HyperparameterArmPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more HyperparameterArms.
     * @param {HyperparameterArmDeleteManyArgs} args - Arguments to filter HyperparameterArms to delete.
     * @example
     * // Delete a few HyperparameterArms
     * const { count } = await prisma.hyperparameterArm.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HyperparameterArmDeleteManyArgs>(args?: SelectSubset<T, HyperparameterArmDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HyperparameterArms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HyperparameterArmUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HyperparameterArms
     * const hyperparameterArm = await prisma.hyperparameterArm.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HyperparameterArmUpdateManyArgs>(args: SelectSubset<T, HyperparameterArmUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HyperparameterArms and returns the data updated in the database.
     * @param {HyperparameterArmUpdateManyAndReturnArgs} args - Arguments to update many HyperparameterArms.
     * @example
     * // Update many HyperparameterArms
     * const hyperparameterArm = await prisma.hyperparameterArm.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more HyperparameterArms and only return the `id`
     * const hyperparameterArmWithIdOnly = await prisma.hyperparameterArm.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HyperparameterArmUpdateManyAndReturnArgs>(args: SelectSubset<T, HyperparameterArmUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HyperparameterArmPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one HyperparameterArm.
     * @param {HyperparameterArmUpsertArgs} args - Arguments to update or create a HyperparameterArm.
     * @example
     * // Update or create a HyperparameterArm
     * const hyperparameterArm = await prisma.hyperparameterArm.upsert({
     *   create: {
     *     // ... data to create a HyperparameterArm
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HyperparameterArm we want to update
     *   }
     * })
     */
    upsert<T extends HyperparameterArmUpsertArgs>(args: SelectSubset<T, HyperparameterArmUpsertArgs<ExtArgs>>): Prisma__HyperparameterArmClient<$Result.GetResult<Prisma.$HyperparameterArmPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of HyperparameterArms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HyperparameterArmCountArgs} args - Arguments to filter HyperparameterArms to count.
     * @example
     * // Count the number of HyperparameterArms
     * const count = await prisma.hyperparameterArm.count({
     *   where: {
     *     // ... the filter for the HyperparameterArms we want to count
     *   }
     * })
    **/
    count<T extends HyperparameterArmCountArgs>(
      args?: Subset<T, HyperparameterArmCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HyperparameterArmCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HyperparameterArm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HyperparameterArmAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HyperparameterArmAggregateArgs>(args: Subset<T, HyperparameterArmAggregateArgs>): Prisma.PrismaPromise<GetHyperparameterArmAggregateType<T>>

    /**
     * Group by HyperparameterArm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HyperparameterArmGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HyperparameterArmGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HyperparameterArmGroupByArgs['orderBy'] }
        : { orderBy?: HyperparameterArmGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HyperparameterArmGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHyperparameterArmGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HyperparameterArm model
   */
  readonly fields: HyperparameterArmFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HyperparameterArm.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HyperparameterArmClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    interacoes<T extends HyperparameterArm$interacoesArgs<ExtArgs> = {}>(args?: Subset<T, HyperparameterArm$interacoesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InteracaoIAPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HyperparameterArm model
   */
  interface HyperparameterArmFieldRefs {
    readonly id: FieldRef<"HyperparameterArm", 'String'>
    readonly modelName: FieldRef<"HyperparameterArm", 'String'>
    readonly version: FieldRef<"HyperparameterArm", 'String'>
    readonly temperature: FieldRef<"HyperparameterArm", 'Float'>
    readonly topP: FieldRef<"HyperparameterArm", 'Float'>
    readonly topK: FieldRef<"HyperparameterArm", 'Int'>
    readonly maxOutputTokens: FieldRef<"HyperparameterArm", 'Int'>
    readonly responseMimeType: FieldRef<"HyperparameterArm", 'String'>
    readonly successes: FieldRef<"HyperparameterArm", 'Int'>
    readonly failures: FieldRef<"HyperparameterArm", 'Int'>
    readonly createdAt: FieldRef<"HyperparameterArm", 'DateTime'>
    readonly updatedAt: FieldRef<"HyperparameterArm", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HyperparameterArm findUnique
   */
  export type HyperparameterArmFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HyperparameterArm
     */
    select?: HyperparameterArmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HyperparameterArm
     */
    omit?: HyperparameterArmOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HyperparameterArmInclude<ExtArgs> | null
    /**
     * Filter, which HyperparameterArm to fetch.
     */
    where: HyperparameterArmWhereUniqueInput
  }

  /**
   * HyperparameterArm findUniqueOrThrow
   */
  export type HyperparameterArmFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HyperparameterArm
     */
    select?: HyperparameterArmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HyperparameterArm
     */
    omit?: HyperparameterArmOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HyperparameterArmInclude<ExtArgs> | null
    /**
     * Filter, which HyperparameterArm to fetch.
     */
    where: HyperparameterArmWhereUniqueInput
  }

  /**
   * HyperparameterArm findFirst
   */
  export type HyperparameterArmFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HyperparameterArm
     */
    select?: HyperparameterArmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HyperparameterArm
     */
    omit?: HyperparameterArmOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HyperparameterArmInclude<ExtArgs> | null
    /**
     * Filter, which HyperparameterArm to fetch.
     */
    where?: HyperparameterArmWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HyperparameterArms to fetch.
     */
    orderBy?: HyperparameterArmOrderByWithRelationInput | HyperparameterArmOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HyperparameterArms.
     */
    cursor?: HyperparameterArmWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HyperparameterArms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HyperparameterArms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HyperparameterArms.
     */
    distinct?: HyperparameterArmScalarFieldEnum | HyperparameterArmScalarFieldEnum[]
  }

  /**
   * HyperparameterArm findFirstOrThrow
   */
  export type HyperparameterArmFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HyperparameterArm
     */
    select?: HyperparameterArmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HyperparameterArm
     */
    omit?: HyperparameterArmOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HyperparameterArmInclude<ExtArgs> | null
    /**
     * Filter, which HyperparameterArm to fetch.
     */
    where?: HyperparameterArmWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HyperparameterArms to fetch.
     */
    orderBy?: HyperparameterArmOrderByWithRelationInput | HyperparameterArmOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HyperparameterArms.
     */
    cursor?: HyperparameterArmWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HyperparameterArms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HyperparameterArms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HyperparameterArms.
     */
    distinct?: HyperparameterArmScalarFieldEnum | HyperparameterArmScalarFieldEnum[]
  }

  /**
   * HyperparameterArm findMany
   */
  export type HyperparameterArmFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HyperparameterArm
     */
    select?: HyperparameterArmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HyperparameterArm
     */
    omit?: HyperparameterArmOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HyperparameterArmInclude<ExtArgs> | null
    /**
     * Filter, which HyperparameterArms to fetch.
     */
    where?: HyperparameterArmWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HyperparameterArms to fetch.
     */
    orderBy?: HyperparameterArmOrderByWithRelationInput | HyperparameterArmOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HyperparameterArms.
     */
    cursor?: HyperparameterArmWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HyperparameterArms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HyperparameterArms.
     */
    skip?: number
    distinct?: HyperparameterArmScalarFieldEnum | HyperparameterArmScalarFieldEnum[]
  }

  /**
   * HyperparameterArm create
   */
  export type HyperparameterArmCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HyperparameterArm
     */
    select?: HyperparameterArmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HyperparameterArm
     */
    omit?: HyperparameterArmOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HyperparameterArmInclude<ExtArgs> | null
    /**
     * The data needed to create a HyperparameterArm.
     */
    data: XOR<HyperparameterArmCreateInput, HyperparameterArmUncheckedCreateInput>
  }

  /**
   * HyperparameterArm createMany
   */
  export type HyperparameterArmCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HyperparameterArms.
     */
    data: HyperparameterArmCreateManyInput | HyperparameterArmCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HyperparameterArm createManyAndReturn
   */
  export type HyperparameterArmCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HyperparameterArm
     */
    select?: HyperparameterArmSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HyperparameterArm
     */
    omit?: HyperparameterArmOmit<ExtArgs> | null
    /**
     * The data used to create many HyperparameterArms.
     */
    data: HyperparameterArmCreateManyInput | HyperparameterArmCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HyperparameterArm update
   */
  export type HyperparameterArmUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HyperparameterArm
     */
    select?: HyperparameterArmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HyperparameterArm
     */
    omit?: HyperparameterArmOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HyperparameterArmInclude<ExtArgs> | null
    /**
     * The data needed to update a HyperparameterArm.
     */
    data: XOR<HyperparameterArmUpdateInput, HyperparameterArmUncheckedUpdateInput>
    /**
     * Choose, which HyperparameterArm to update.
     */
    where: HyperparameterArmWhereUniqueInput
  }

  /**
   * HyperparameterArm updateMany
   */
  export type HyperparameterArmUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HyperparameterArms.
     */
    data: XOR<HyperparameterArmUpdateManyMutationInput, HyperparameterArmUncheckedUpdateManyInput>
    /**
     * Filter which HyperparameterArms to update
     */
    where?: HyperparameterArmWhereInput
    /**
     * Limit how many HyperparameterArms to update.
     */
    limit?: number
  }

  /**
   * HyperparameterArm updateManyAndReturn
   */
  export type HyperparameterArmUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HyperparameterArm
     */
    select?: HyperparameterArmSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HyperparameterArm
     */
    omit?: HyperparameterArmOmit<ExtArgs> | null
    /**
     * The data used to update HyperparameterArms.
     */
    data: XOR<HyperparameterArmUpdateManyMutationInput, HyperparameterArmUncheckedUpdateManyInput>
    /**
     * Filter which HyperparameterArms to update
     */
    where?: HyperparameterArmWhereInput
    /**
     * Limit how many HyperparameterArms to update.
     */
    limit?: number
  }

  /**
   * HyperparameterArm upsert
   */
  export type HyperparameterArmUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HyperparameterArm
     */
    select?: HyperparameterArmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HyperparameterArm
     */
    omit?: HyperparameterArmOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HyperparameterArmInclude<ExtArgs> | null
    /**
     * The filter to search for the HyperparameterArm to update in case it exists.
     */
    where: HyperparameterArmWhereUniqueInput
    /**
     * In case the HyperparameterArm found by the `where` argument doesn't exist, create a new HyperparameterArm with this data.
     */
    create: XOR<HyperparameterArmCreateInput, HyperparameterArmUncheckedCreateInput>
    /**
     * In case the HyperparameterArm was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HyperparameterArmUpdateInput, HyperparameterArmUncheckedUpdateInput>
  }

  /**
   * HyperparameterArm delete
   */
  export type HyperparameterArmDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HyperparameterArm
     */
    select?: HyperparameterArmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HyperparameterArm
     */
    omit?: HyperparameterArmOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HyperparameterArmInclude<ExtArgs> | null
    /**
     * Filter which HyperparameterArm to delete.
     */
    where: HyperparameterArmWhereUniqueInput
  }

  /**
   * HyperparameterArm deleteMany
   */
  export type HyperparameterArmDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HyperparameterArms to delete
     */
    where?: HyperparameterArmWhereInput
    /**
     * Limit how many HyperparameterArms to delete.
     */
    limit?: number
  }

  /**
   * HyperparameterArm.interacoes
   */
  export type HyperparameterArm$interacoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteracaoIA
     */
    select?: InteracaoIASelect<ExtArgs> | null
    /**
     * Omit specific fields from the InteracaoIA
     */
    omit?: InteracaoIAOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteracaoIAInclude<ExtArgs> | null
    where?: InteracaoIAWhereInput
    orderBy?: InteracaoIAOrderByWithRelationInput | InteracaoIAOrderByWithRelationInput[]
    cursor?: InteracaoIAWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InteracaoIAScalarFieldEnum | InteracaoIAScalarFieldEnum[]
  }

  /**
   * HyperparameterArm without action
   */
  export type HyperparameterArmDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HyperparameterArm
     */
    select?: HyperparameterArmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HyperparameterArm
     */
    omit?: HyperparameterArmOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HyperparameterArmInclude<ExtArgs> | null
  }


  /**
   * Model Client
   */

  export type AggregateClient = {
    _count: ClientCountAggregateOutputType | null
    _avg: ClientAvgAggregateOutputType | null
    _sum: ClientSumAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  export type ClientAvgAggregateOutputType = {
    id: number | null
  }

  export type ClientSumAggregateOutputType = {
    id: number | null
  }

  export type ClientMinAggregateOutputType = {
    id: number | null
    companyName: string | null
    cnpj: string | null
    phone: string | null
    address: string | null
    email: string | null
    password: string | null
    contractDate: Date | null
    status: $Enums.Status | null
  }

  export type ClientMaxAggregateOutputType = {
    id: number | null
    companyName: string | null
    cnpj: string | null
    phone: string | null
    address: string | null
    email: string | null
    password: string | null
    contractDate: Date | null
    status: $Enums.Status | null
  }

  export type ClientCountAggregateOutputType = {
    id: number
    companyName: number
    cnpj: number
    phone: number
    address: number
    email: number
    password: number
    contractDate: number
    status: number
    _all: number
  }


  export type ClientAvgAggregateInputType = {
    id?: true
  }

  export type ClientSumAggregateInputType = {
    id?: true
  }

  export type ClientMinAggregateInputType = {
    id?: true
    companyName?: true
    cnpj?: true
    phone?: true
    address?: true
    email?: true
    password?: true
    contractDate?: true
    status?: true
  }

  export type ClientMaxAggregateInputType = {
    id?: true
    companyName?: true
    cnpj?: true
    phone?: true
    address?: true
    email?: true
    password?: true
    contractDate?: true
    status?: true
  }

  export type ClientCountAggregateInputType = {
    id?: true
    companyName?: true
    cnpj?: true
    phone?: true
    address?: true
    email?: true
    password?: true
    contractDate?: true
    status?: true
    _all?: true
  }

  export type ClientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Client to aggregate.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clients
    **/
    _count?: true | ClientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientMaxAggregateInputType
  }

  export type GetClientAggregateType<T extends ClientAggregateArgs> = {
        [P in keyof T & keyof AggregateClient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClient[P]>
      : GetScalarType<T[P], AggregateClient[P]>
  }




  export type ClientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
    orderBy?: ClientOrderByWithAggregationInput | ClientOrderByWithAggregationInput[]
    by: ClientScalarFieldEnum[] | ClientScalarFieldEnum
    having?: ClientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientCountAggregateInputType | true
    _avg?: ClientAvgAggregateInputType
    _sum?: ClientSumAggregateInputType
    _min?: ClientMinAggregateInputType
    _max?: ClientMaxAggregateInputType
  }

  export type ClientGroupByOutputType = {
    id: number
    companyName: string
    cnpj: string
    phone: string | null
    address: string | null
    email: string
    password: string
    contractDate: Date
    status: $Enums.Status
    _count: ClientCountAggregateOutputType | null
    _avg: ClientAvgAggregateOutputType | null
    _sum: ClientSumAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  type GetClientGroupByPayload<T extends ClientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientGroupByOutputType[P]>
            : GetScalarType<T[P], ClientGroupByOutputType[P]>
        }
      >
    >


  export type ClientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyName?: boolean
    cnpj?: boolean
    phone?: boolean
    address?: boolean
    email?: boolean
    password?: boolean
    contractDate?: boolean
    status?: boolean
    machines?: boolean | Client$machinesArgs<ExtArgs>
    users?: boolean | Client$usersArgs<ExtArgs>
    devices?: boolean | Client$devicesArgs<ExtArgs>
    gateways?: boolean | Client$gatewaysArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type ClientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyName?: boolean
    cnpj?: boolean
    phone?: boolean
    address?: boolean
    email?: boolean
    password?: boolean
    contractDate?: boolean
    status?: boolean
  }, ExtArgs["result"]["client"]>

  export type ClientSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyName?: boolean
    cnpj?: boolean
    phone?: boolean
    address?: boolean
    email?: boolean
    password?: boolean
    contractDate?: boolean
    status?: boolean
  }, ExtArgs["result"]["client"]>

  export type ClientSelectScalar = {
    id?: boolean
    companyName?: boolean
    cnpj?: boolean
    phone?: boolean
    address?: boolean
    email?: boolean
    password?: boolean
    contractDate?: boolean
    status?: boolean
  }

  export type ClientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyName" | "cnpj" | "phone" | "address" | "email" | "password" | "contractDate" | "status", ExtArgs["result"]["client"]>
  export type ClientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    machines?: boolean | Client$machinesArgs<ExtArgs>
    users?: boolean | Client$usersArgs<ExtArgs>
    devices?: boolean | Client$devicesArgs<ExtArgs>
    gateways?: boolean | Client$gatewaysArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ClientIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ClientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Client"
    objects: {
      machines: Prisma.$MachinePayload<ExtArgs>[]
      users: Prisma.$UserPayload<ExtArgs>[]
      devices: Prisma.$DevicePayload<ExtArgs>[]
      gateways: Prisma.$GatewayPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      companyName: string
      cnpj: string
      phone: string | null
      address: string | null
      email: string
      password: string
      contractDate: Date
      status: $Enums.Status
    }, ExtArgs["result"]["client"]>
    composites: {}
  }

  type ClientGetPayload<S extends boolean | null | undefined | ClientDefaultArgs> = $Result.GetResult<Prisma.$ClientPayload, S>

  type ClientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientCountAggregateInputType | true
    }

  export interface ClientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Client'], meta: { name: 'Client' } }
    /**
     * Find zero or one Client that matches the filter.
     * @param {ClientFindUniqueArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientFindUniqueArgs>(args: SelectSubset<T, ClientFindUniqueArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Client that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClientFindUniqueOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Client that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientFindFirstArgs>(args?: SelectSubset<T, ClientFindFirstArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Client that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clients
     * const clients = await prisma.client.findMany()
     * 
     * // Get first 10 Clients
     * const clients = await prisma.client.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientWithIdOnly = await prisma.client.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientFindManyArgs>(args?: SelectSubset<T, ClientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Client.
     * @param {ClientCreateArgs} args - Arguments to create a Client.
     * @example
     * // Create one Client
     * const Client = await prisma.client.create({
     *   data: {
     *     // ... data to create a Client
     *   }
     * })
     * 
     */
    create<T extends ClientCreateArgs>(args: SelectSubset<T, ClientCreateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Clients.
     * @param {ClientCreateManyArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientCreateManyArgs>(args?: SelectSubset<T, ClientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Clients and returns the data saved in the database.
     * @param {ClientCreateManyAndReturnArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Clients and only return the `id`
     * const clientWithIdOnly = await prisma.client.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClientCreateManyAndReturnArgs>(args?: SelectSubset<T, ClientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Client.
     * @param {ClientDeleteArgs} args - Arguments to delete one Client.
     * @example
     * // Delete one Client
     * const Client = await prisma.client.delete({
     *   where: {
     *     // ... filter to delete one Client
     *   }
     * })
     * 
     */
    delete<T extends ClientDeleteArgs>(args: SelectSubset<T, ClientDeleteArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Client.
     * @param {ClientUpdateArgs} args - Arguments to update one Client.
     * @example
     * // Update one Client
     * const client = await prisma.client.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientUpdateArgs>(args: SelectSubset<T, ClientUpdateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Clients.
     * @param {ClientDeleteManyArgs} args - Arguments to filter Clients to delete.
     * @example
     * // Delete a few Clients
     * const { count } = await prisma.client.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientDeleteManyArgs>(args?: SelectSubset<T, ClientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientUpdateManyArgs>(args: SelectSubset<T, ClientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients and returns the data updated in the database.
     * @param {ClientUpdateManyAndReturnArgs} args - Arguments to update many Clients.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Clients and only return the `id`
     * const clientWithIdOnly = await prisma.client.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClientUpdateManyAndReturnArgs>(args: SelectSubset<T, ClientUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Client.
     * @param {ClientUpsertArgs} args - Arguments to update or create a Client.
     * @example
     * // Update or create a Client
     * const client = await prisma.client.upsert({
     *   create: {
     *     // ... data to create a Client
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Client we want to update
     *   }
     * })
     */
    upsert<T extends ClientUpsertArgs>(args: SelectSubset<T, ClientUpsertArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCountArgs} args - Arguments to filter Clients to count.
     * @example
     * // Count the number of Clients
     * const count = await prisma.client.count({
     *   where: {
     *     // ... the filter for the Clients we want to count
     *   }
     * })
    **/
    count<T extends ClientCountArgs>(
      args?: Subset<T, ClientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientAggregateArgs>(args: Subset<T, ClientAggregateArgs>): Prisma.PrismaPromise<GetClientAggregateType<T>>

    /**
     * Group by Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientGroupByArgs['orderBy'] }
        : { orderBy?: ClientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Client model
   */
  readonly fields: ClientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Client.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    machines<T extends Client$machinesArgs<ExtArgs> = {}>(args?: Subset<T, Client$machinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MachinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends Client$usersArgs<ExtArgs> = {}>(args?: Subset<T, Client$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    devices<T extends Client$devicesArgs<ExtArgs> = {}>(args?: Subset<T, Client$devicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    gateways<T extends Client$gatewaysArgs<ExtArgs> = {}>(args?: Subset<T, Client$gatewaysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GatewayPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Client model
   */
  interface ClientFieldRefs {
    readonly id: FieldRef<"Client", 'Int'>
    readonly companyName: FieldRef<"Client", 'String'>
    readonly cnpj: FieldRef<"Client", 'String'>
    readonly phone: FieldRef<"Client", 'String'>
    readonly address: FieldRef<"Client", 'String'>
    readonly email: FieldRef<"Client", 'String'>
    readonly password: FieldRef<"Client", 'String'>
    readonly contractDate: FieldRef<"Client", 'DateTime'>
    readonly status: FieldRef<"Client", 'Status'>
  }
    

  // Custom InputTypes
  /**
   * Client findUnique
   */
  export type ClientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findUniqueOrThrow
   */
  export type ClientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findFirst
   */
  export type ClientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findFirstOrThrow
   */
  export type ClientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findMany
   */
  export type ClientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Clients to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client create
   */
  export type ClientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to create a Client.
     */
    data: XOR<ClientCreateInput, ClientUncheckedCreateInput>
  }

  /**
   * Client createMany
   */
  export type ClientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Client createManyAndReturn
   */
  export type ClientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Client update
   */
  export type ClientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to update a Client.
     */
    data: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
    /**
     * Choose, which Client to update.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client updateMany
   */
  export type ClientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to update.
     */
    limit?: number
  }

  /**
   * Client updateManyAndReturn
   */
  export type ClientUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to update.
     */
    limit?: number
  }

  /**
   * Client upsert
   */
  export type ClientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The filter to search for the Client to update in case it exists.
     */
    where: ClientWhereUniqueInput
    /**
     * In case the Client found by the `where` argument doesn't exist, create a new Client with this data.
     */
    create: XOR<ClientCreateInput, ClientUncheckedCreateInput>
    /**
     * In case the Client was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
  }

  /**
   * Client delete
   */
  export type ClientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter which Client to delete.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client deleteMany
   */
  export type ClientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clients to delete
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to delete.
     */
    limit?: number
  }

  /**
   * Client.machines
   */
  export type Client$machinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Machine
     */
    omit?: MachineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineInclude<ExtArgs> | null
    where?: MachineWhereInput
    orderBy?: MachineOrderByWithRelationInput | MachineOrderByWithRelationInput[]
    cursor?: MachineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MachineScalarFieldEnum | MachineScalarFieldEnum[]
  }

  /**
   * Client.users
   */
  export type Client$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Client.devices
   */
  export type Client$devicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    where?: DeviceWhereInput
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[]
    cursor?: DeviceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeviceScalarFieldEnum | DeviceScalarFieldEnum[]
  }

  /**
   * Client.gateways
   */
  export type Client$gatewaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gateway
     */
    select?: GatewaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gateway
     */
    omit?: GatewayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GatewayInclude<ExtArgs> | null
    where?: GatewayWhereInput
    orderBy?: GatewayOrderByWithRelationInput | GatewayOrderByWithRelationInput[]
    cursor?: GatewayWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GatewayScalarFieldEnum | GatewayScalarFieldEnum[]
  }

  /**
   * Client without action
   */
  export type ClientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    clientId: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    clientId: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    password: string | null
    userType: $Enums.UserType | null
    status: $Enums.Status | null
    clientId: number | null
    createdAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    password: string | null
    userType: $Enums.UserType | null
    status: $Enums.Status | null
    clientId: number | null
    createdAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    password: number
    userType: number
    status: number
    clientId: number
    createdAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    clientId?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    clientId?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    userType?: true
    status?: true
    clientId?: true
    createdAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    userType?: true
    status?: true
    clientId?: true
    createdAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    userType?: true
    status?: true
    clientId?: true
    createdAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    name: string
    email: string
    password: string
    userType: $Enums.UserType
    status: $Enums.Status
    clientId: number
    createdAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    userType?: boolean
    status?: boolean
    clientId?: boolean
    createdAt?: boolean
    currentReadings?: boolean | User$currentReadingsArgs<ExtArgs>
    responsibleMachines?: boolean | User$responsibleMachinesArgs<ExtArgs>
    oilLevelReadings?: boolean | User$oilLevelReadingsArgs<ExtArgs>
    oilTemperatureReadings?: boolean | User$oilTemperatureReadingsArgs<ExtArgs>
    rpmReadings?: boolean | User$rpmReadingsArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    userType?: boolean
    status?: boolean
    clientId?: boolean
    createdAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    userType?: boolean
    status?: boolean
    clientId?: boolean
    createdAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    userType?: boolean
    status?: boolean
    clientId?: boolean
    createdAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "password" | "userType" | "status" | "clientId" | "createdAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    currentReadings?: boolean | User$currentReadingsArgs<ExtArgs>
    responsibleMachines?: boolean | User$responsibleMachinesArgs<ExtArgs>
    oilLevelReadings?: boolean | User$oilLevelReadingsArgs<ExtArgs>
    oilTemperatureReadings?: boolean | User$oilTemperatureReadingsArgs<ExtArgs>
    rpmReadings?: boolean | User$rpmReadingsArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      currentReadings: Prisma.$CurrentReadingPayload<ExtArgs>[]
      responsibleMachines: Prisma.$MachinePayload<ExtArgs>[]
      oilLevelReadings: Prisma.$OilLevelReadingPayload<ExtArgs>[]
      oilTemperatureReadings: Prisma.$OilTemperatureReadingPayload<ExtArgs>[]
      rpmReadings: Prisma.$RpmReadingPayload<ExtArgs>[]
      client: Prisma.$ClientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      email: string
      password: string
      userType: $Enums.UserType
      status: $Enums.Status
      clientId: number
      createdAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    currentReadings<T extends User$currentReadingsArgs<ExtArgs> = {}>(args?: Subset<T, User$currentReadingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CurrentReadingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    responsibleMachines<T extends User$responsibleMachinesArgs<ExtArgs> = {}>(args?: Subset<T, User$responsibleMachinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MachinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    oilLevelReadings<T extends User$oilLevelReadingsArgs<ExtArgs> = {}>(args?: Subset<T, User$oilLevelReadingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OilLevelReadingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    oilTemperatureReadings<T extends User$oilTemperatureReadingsArgs<ExtArgs> = {}>(args?: Subset<T, User$oilTemperatureReadingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OilTemperatureReadingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rpmReadings<T extends User$rpmReadingsArgs<ExtArgs> = {}>(args?: Subset<T, User$rpmReadingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RpmReadingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly userType: FieldRef<"User", 'UserType'>
    readonly status: FieldRef<"User", 'Status'>
    readonly clientId: FieldRef<"User", 'Int'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.currentReadings
   */
  export type User$currentReadingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrentReading
     */
    select?: CurrentReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurrentReading
     */
    omit?: CurrentReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrentReadingInclude<ExtArgs> | null
    where?: CurrentReadingWhereInput
    orderBy?: CurrentReadingOrderByWithRelationInput | CurrentReadingOrderByWithRelationInput[]
    cursor?: CurrentReadingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CurrentReadingScalarFieldEnum | CurrentReadingScalarFieldEnum[]
  }

  /**
   * User.responsibleMachines
   */
  export type User$responsibleMachinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Machine
     */
    omit?: MachineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineInclude<ExtArgs> | null
    where?: MachineWhereInput
    orderBy?: MachineOrderByWithRelationInput | MachineOrderByWithRelationInput[]
    cursor?: MachineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MachineScalarFieldEnum | MachineScalarFieldEnum[]
  }

  /**
   * User.oilLevelReadings
   */
  export type User$oilLevelReadingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OilLevelReading
     */
    select?: OilLevelReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OilLevelReading
     */
    omit?: OilLevelReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OilLevelReadingInclude<ExtArgs> | null
    where?: OilLevelReadingWhereInput
    orderBy?: OilLevelReadingOrderByWithRelationInput | OilLevelReadingOrderByWithRelationInput[]
    cursor?: OilLevelReadingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OilLevelReadingScalarFieldEnum | OilLevelReadingScalarFieldEnum[]
  }

  /**
   * User.oilTemperatureReadings
   */
  export type User$oilTemperatureReadingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OilTemperatureReading
     */
    select?: OilTemperatureReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OilTemperatureReading
     */
    omit?: OilTemperatureReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OilTemperatureReadingInclude<ExtArgs> | null
    where?: OilTemperatureReadingWhereInput
    orderBy?: OilTemperatureReadingOrderByWithRelationInput | OilTemperatureReadingOrderByWithRelationInput[]
    cursor?: OilTemperatureReadingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OilTemperatureReadingScalarFieldEnum | OilTemperatureReadingScalarFieldEnum[]
  }

  /**
   * User.rpmReadings
   */
  export type User$rpmReadingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RpmReading
     */
    select?: RpmReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RpmReading
     */
    omit?: RpmReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RpmReadingInclude<ExtArgs> | null
    where?: RpmReadingWhereInput
    orderBy?: RpmReadingOrderByWithRelationInput | RpmReadingOrderByWithRelationInput[]
    cursor?: RpmReadingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RpmReadingScalarFieldEnum | RpmReadingScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Machine
   */

  export type AggregateMachine = {
    _count: MachineCountAggregateOutputType | null
    _avg: MachineAvgAggregateOutputType | null
    _sum: MachineSumAggregateOutputType | null
    _min: MachineMinAggregateOutputType | null
    _max: MachineMaxAggregateOutputType | null
  }

  export type MachineAvgAggregateOutputType = {
    id: number | null
    clientId: number | null
    responsibleUserId: number | null
    deviceId: number | null
  }

  export type MachineSumAggregateOutputType = {
    id: number | null
    clientId: number | null
    responsibleUserId: number | null
    deviceId: number | null
  }

  export type MachineMinAggregateOutputType = {
    id: number | null
    name: string | null
    model: string | null
    manufacturer: string | null
    serialNumber: string | null
    status: $Enums.Status | null
    clientId: number | null
    responsibleUserId: number | null
    deviceId: number | null
  }

  export type MachineMaxAggregateOutputType = {
    id: number | null
    name: string | null
    model: string | null
    manufacturer: string | null
    serialNumber: string | null
    status: $Enums.Status | null
    clientId: number | null
    responsibleUserId: number | null
    deviceId: number | null
  }

  export type MachineCountAggregateOutputType = {
    id: number
    name: number
    model: number
    manufacturer: number
    serialNumber: number
    status: number
    clientId: number
    responsibleUserId: number
    deviceId: number
    _all: number
  }


  export type MachineAvgAggregateInputType = {
    id?: true
    clientId?: true
    responsibleUserId?: true
    deviceId?: true
  }

  export type MachineSumAggregateInputType = {
    id?: true
    clientId?: true
    responsibleUserId?: true
    deviceId?: true
  }

  export type MachineMinAggregateInputType = {
    id?: true
    name?: true
    model?: true
    manufacturer?: true
    serialNumber?: true
    status?: true
    clientId?: true
    responsibleUserId?: true
    deviceId?: true
  }

  export type MachineMaxAggregateInputType = {
    id?: true
    name?: true
    model?: true
    manufacturer?: true
    serialNumber?: true
    status?: true
    clientId?: true
    responsibleUserId?: true
    deviceId?: true
  }

  export type MachineCountAggregateInputType = {
    id?: true
    name?: true
    model?: true
    manufacturer?: true
    serialNumber?: true
    status?: true
    clientId?: true
    responsibleUserId?: true
    deviceId?: true
    _all?: true
  }

  export type MachineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Machine to aggregate.
     */
    where?: MachineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Machines to fetch.
     */
    orderBy?: MachineOrderByWithRelationInput | MachineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MachineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Machines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Machines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Machines
    **/
    _count?: true | MachineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MachineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MachineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MachineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MachineMaxAggregateInputType
  }

  export type GetMachineAggregateType<T extends MachineAggregateArgs> = {
        [P in keyof T & keyof AggregateMachine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMachine[P]>
      : GetScalarType<T[P], AggregateMachine[P]>
  }




  export type MachineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MachineWhereInput
    orderBy?: MachineOrderByWithAggregationInput | MachineOrderByWithAggregationInput[]
    by: MachineScalarFieldEnum[] | MachineScalarFieldEnum
    having?: MachineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MachineCountAggregateInputType | true
    _avg?: MachineAvgAggregateInputType
    _sum?: MachineSumAggregateInputType
    _min?: MachineMinAggregateInputType
    _max?: MachineMaxAggregateInputType
  }

  export type MachineGroupByOutputType = {
    id: number
    name: string
    model: string | null
    manufacturer: string | null
    serialNumber: string
    status: $Enums.Status
    clientId: number
    responsibleUserId: number | null
    deviceId: number | null
    _count: MachineCountAggregateOutputType | null
    _avg: MachineAvgAggregateOutputType | null
    _sum: MachineSumAggregateOutputType | null
    _min: MachineMinAggregateOutputType | null
    _max: MachineMaxAggregateOutputType | null
  }

  type GetMachineGroupByPayload<T extends MachineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MachineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MachineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MachineGroupByOutputType[P]>
            : GetScalarType<T[P], MachineGroupByOutputType[P]>
        }
      >
    >


  export type MachineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    model?: boolean
    manufacturer?: boolean
    serialNumber?: boolean
    status?: boolean
    clientId?: boolean
    responsibleUserId?: boolean
    deviceId?: boolean
    UnifiedMachineState?: boolean | Machine$UnifiedMachineStateArgs<ExtArgs>
    currentReadings?: boolean | Machine$currentReadingsArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
    device?: boolean | Machine$deviceArgs<ExtArgs>
    responsibleUser?: boolean | Machine$responsibleUserArgs<ExtArgs>
    oilLevelReadings?: boolean | Machine$oilLevelReadingsArgs<ExtArgs>
    oilTemperatureReadings?: boolean | Machine$oilTemperatureReadingsArgs<ExtArgs>
    rpmReadings?: boolean | Machine$rpmReadingsArgs<ExtArgs>
    _count?: boolean | MachineCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["machine"]>

  export type MachineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    model?: boolean
    manufacturer?: boolean
    serialNumber?: boolean
    status?: boolean
    clientId?: boolean
    responsibleUserId?: boolean
    deviceId?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    device?: boolean | Machine$deviceArgs<ExtArgs>
    responsibleUser?: boolean | Machine$responsibleUserArgs<ExtArgs>
  }, ExtArgs["result"]["machine"]>

  export type MachineSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    model?: boolean
    manufacturer?: boolean
    serialNumber?: boolean
    status?: boolean
    clientId?: boolean
    responsibleUserId?: boolean
    deviceId?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    device?: boolean | Machine$deviceArgs<ExtArgs>
    responsibleUser?: boolean | Machine$responsibleUserArgs<ExtArgs>
  }, ExtArgs["result"]["machine"]>

  export type MachineSelectScalar = {
    id?: boolean
    name?: boolean
    model?: boolean
    manufacturer?: boolean
    serialNumber?: boolean
    status?: boolean
    clientId?: boolean
    responsibleUserId?: boolean
    deviceId?: boolean
  }

  export type MachineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "model" | "manufacturer" | "serialNumber" | "status" | "clientId" | "responsibleUserId" | "deviceId", ExtArgs["result"]["machine"]>
  export type MachineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    UnifiedMachineState?: boolean | Machine$UnifiedMachineStateArgs<ExtArgs>
    currentReadings?: boolean | Machine$currentReadingsArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
    device?: boolean | Machine$deviceArgs<ExtArgs>
    responsibleUser?: boolean | Machine$responsibleUserArgs<ExtArgs>
    oilLevelReadings?: boolean | Machine$oilLevelReadingsArgs<ExtArgs>
    oilTemperatureReadings?: boolean | Machine$oilTemperatureReadingsArgs<ExtArgs>
    rpmReadings?: boolean | Machine$rpmReadingsArgs<ExtArgs>
    _count?: boolean | MachineCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MachineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    device?: boolean | Machine$deviceArgs<ExtArgs>
    responsibleUser?: boolean | Machine$responsibleUserArgs<ExtArgs>
  }
  export type MachineIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    device?: boolean | Machine$deviceArgs<ExtArgs>
    responsibleUser?: boolean | Machine$responsibleUserArgs<ExtArgs>
  }

  export type $MachinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Machine"
    objects: {
      UnifiedMachineState: Prisma.$UnifiedMachineStatePayload<ExtArgs>[]
      currentReadings: Prisma.$CurrentReadingPayload<ExtArgs>[]
      client: Prisma.$ClientPayload<ExtArgs>
      device: Prisma.$DevicePayload<ExtArgs> | null
      responsibleUser: Prisma.$UserPayload<ExtArgs> | null
      oilLevelReadings: Prisma.$OilLevelReadingPayload<ExtArgs>[]
      oilTemperatureReadings: Prisma.$OilTemperatureReadingPayload<ExtArgs>[]
      rpmReadings: Prisma.$RpmReadingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      model: string | null
      manufacturer: string | null
      serialNumber: string
      status: $Enums.Status
      clientId: number
      responsibleUserId: number | null
      deviceId: number | null
    }, ExtArgs["result"]["machine"]>
    composites: {}
  }

  type MachineGetPayload<S extends boolean | null | undefined | MachineDefaultArgs> = $Result.GetResult<Prisma.$MachinePayload, S>

  type MachineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MachineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MachineCountAggregateInputType | true
    }

  export interface MachineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Machine'], meta: { name: 'Machine' } }
    /**
     * Find zero or one Machine that matches the filter.
     * @param {MachineFindUniqueArgs} args - Arguments to find a Machine
     * @example
     * // Get one Machine
     * const machine = await prisma.machine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MachineFindUniqueArgs>(args: SelectSubset<T, MachineFindUniqueArgs<ExtArgs>>): Prisma__MachineClient<$Result.GetResult<Prisma.$MachinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Machine that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MachineFindUniqueOrThrowArgs} args - Arguments to find a Machine
     * @example
     * // Get one Machine
     * const machine = await prisma.machine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MachineFindUniqueOrThrowArgs>(args: SelectSubset<T, MachineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MachineClient<$Result.GetResult<Prisma.$MachinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Machine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineFindFirstArgs} args - Arguments to find a Machine
     * @example
     * // Get one Machine
     * const machine = await prisma.machine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MachineFindFirstArgs>(args?: SelectSubset<T, MachineFindFirstArgs<ExtArgs>>): Prisma__MachineClient<$Result.GetResult<Prisma.$MachinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Machine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineFindFirstOrThrowArgs} args - Arguments to find a Machine
     * @example
     * // Get one Machine
     * const machine = await prisma.machine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MachineFindFirstOrThrowArgs>(args?: SelectSubset<T, MachineFindFirstOrThrowArgs<ExtArgs>>): Prisma__MachineClient<$Result.GetResult<Prisma.$MachinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Machines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Machines
     * const machines = await prisma.machine.findMany()
     * 
     * // Get first 10 Machines
     * const machines = await prisma.machine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const machineWithIdOnly = await prisma.machine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MachineFindManyArgs>(args?: SelectSubset<T, MachineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MachinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Machine.
     * @param {MachineCreateArgs} args - Arguments to create a Machine.
     * @example
     * // Create one Machine
     * const Machine = await prisma.machine.create({
     *   data: {
     *     // ... data to create a Machine
     *   }
     * })
     * 
     */
    create<T extends MachineCreateArgs>(args: SelectSubset<T, MachineCreateArgs<ExtArgs>>): Prisma__MachineClient<$Result.GetResult<Prisma.$MachinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Machines.
     * @param {MachineCreateManyArgs} args - Arguments to create many Machines.
     * @example
     * // Create many Machines
     * const machine = await prisma.machine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MachineCreateManyArgs>(args?: SelectSubset<T, MachineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Machines and returns the data saved in the database.
     * @param {MachineCreateManyAndReturnArgs} args - Arguments to create many Machines.
     * @example
     * // Create many Machines
     * const machine = await prisma.machine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Machines and only return the `id`
     * const machineWithIdOnly = await prisma.machine.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MachineCreateManyAndReturnArgs>(args?: SelectSubset<T, MachineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MachinePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Machine.
     * @param {MachineDeleteArgs} args - Arguments to delete one Machine.
     * @example
     * // Delete one Machine
     * const Machine = await prisma.machine.delete({
     *   where: {
     *     // ... filter to delete one Machine
     *   }
     * })
     * 
     */
    delete<T extends MachineDeleteArgs>(args: SelectSubset<T, MachineDeleteArgs<ExtArgs>>): Prisma__MachineClient<$Result.GetResult<Prisma.$MachinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Machine.
     * @param {MachineUpdateArgs} args - Arguments to update one Machine.
     * @example
     * // Update one Machine
     * const machine = await prisma.machine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MachineUpdateArgs>(args: SelectSubset<T, MachineUpdateArgs<ExtArgs>>): Prisma__MachineClient<$Result.GetResult<Prisma.$MachinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Machines.
     * @param {MachineDeleteManyArgs} args - Arguments to filter Machines to delete.
     * @example
     * // Delete a few Machines
     * const { count } = await prisma.machine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MachineDeleteManyArgs>(args?: SelectSubset<T, MachineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Machines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Machines
     * const machine = await prisma.machine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MachineUpdateManyArgs>(args: SelectSubset<T, MachineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Machines and returns the data updated in the database.
     * @param {MachineUpdateManyAndReturnArgs} args - Arguments to update many Machines.
     * @example
     * // Update many Machines
     * const machine = await prisma.machine.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Machines and only return the `id`
     * const machineWithIdOnly = await prisma.machine.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MachineUpdateManyAndReturnArgs>(args: SelectSubset<T, MachineUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MachinePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Machine.
     * @param {MachineUpsertArgs} args - Arguments to update or create a Machine.
     * @example
     * // Update or create a Machine
     * const machine = await prisma.machine.upsert({
     *   create: {
     *     // ... data to create a Machine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Machine we want to update
     *   }
     * })
     */
    upsert<T extends MachineUpsertArgs>(args: SelectSubset<T, MachineUpsertArgs<ExtArgs>>): Prisma__MachineClient<$Result.GetResult<Prisma.$MachinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Machines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineCountArgs} args - Arguments to filter Machines to count.
     * @example
     * // Count the number of Machines
     * const count = await prisma.machine.count({
     *   where: {
     *     // ... the filter for the Machines we want to count
     *   }
     * })
    **/
    count<T extends MachineCountArgs>(
      args?: Subset<T, MachineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MachineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Machine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MachineAggregateArgs>(args: Subset<T, MachineAggregateArgs>): Prisma.PrismaPromise<GetMachineAggregateType<T>>

    /**
     * Group by Machine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MachineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MachineGroupByArgs['orderBy'] }
        : { orderBy?: MachineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MachineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMachineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Machine model
   */
  readonly fields: MachineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Machine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MachineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    UnifiedMachineState<T extends Machine$UnifiedMachineStateArgs<ExtArgs> = {}>(args?: Subset<T, Machine$UnifiedMachineStateArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnifiedMachineStatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    currentReadings<T extends Machine$currentReadingsArgs<ExtArgs> = {}>(args?: Subset<T, Machine$currentReadingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CurrentReadingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    device<T extends Machine$deviceArgs<ExtArgs> = {}>(args?: Subset<T, Machine$deviceArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    responsibleUser<T extends Machine$responsibleUserArgs<ExtArgs> = {}>(args?: Subset<T, Machine$responsibleUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    oilLevelReadings<T extends Machine$oilLevelReadingsArgs<ExtArgs> = {}>(args?: Subset<T, Machine$oilLevelReadingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OilLevelReadingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    oilTemperatureReadings<T extends Machine$oilTemperatureReadingsArgs<ExtArgs> = {}>(args?: Subset<T, Machine$oilTemperatureReadingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OilTemperatureReadingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rpmReadings<T extends Machine$rpmReadingsArgs<ExtArgs> = {}>(args?: Subset<T, Machine$rpmReadingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RpmReadingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Machine model
   */
  interface MachineFieldRefs {
    readonly id: FieldRef<"Machine", 'Int'>
    readonly name: FieldRef<"Machine", 'String'>
    readonly model: FieldRef<"Machine", 'String'>
    readonly manufacturer: FieldRef<"Machine", 'String'>
    readonly serialNumber: FieldRef<"Machine", 'String'>
    readonly status: FieldRef<"Machine", 'Status'>
    readonly clientId: FieldRef<"Machine", 'Int'>
    readonly responsibleUserId: FieldRef<"Machine", 'Int'>
    readonly deviceId: FieldRef<"Machine", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Machine findUnique
   */
  export type MachineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Machine
     */
    omit?: MachineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineInclude<ExtArgs> | null
    /**
     * Filter, which Machine to fetch.
     */
    where: MachineWhereUniqueInput
  }

  /**
   * Machine findUniqueOrThrow
   */
  export type MachineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Machine
     */
    omit?: MachineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineInclude<ExtArgs> | null
    /**
     * Filter, which Machine to fetch.
     */
    where: MachineWhereUniqueInput
  }

  /**
   * Machine findFirst
   */
  export type MachineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Machine
     */
    omit?: MachineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineInclude<ExtArgs> | null
    /**
     * Filter, which Machine to fetch.
     */
    where?: MachineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Machines to fetch.
     */
    orderBy?: MachineOrderByWithRelationInput | MachineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Machines.
     */
    cursor?: MachineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Machines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Machines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Machines.
     */
    distinct?: MachineScalarFieldEnum | MachineScalarFieldEnum[]
  }

  /**
   * Machine findFirstOrThrow
   */
  export type MachineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Machine
     */
    omit?: MachineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineInclude<ExtArgs> | null
    /**
     * Filter, which Machine to fetch.
     */
    where?: MachineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Machines to fetch.
     */
    orderBy?: MachineOrderByWithRelationInput | MachineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Machines.
     */
    cursor?: MachineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Machines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Machines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Machines.
     */
    distinct?: MachineScalarFieldEnum | MachineScalarFieldEnum[]
  }

  /**
   * Machine findMany
   */
  export type MachineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Machine
     */
    omit?: MachineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineInclude<ExtArgs> | null
    /**
     * Filter, which Machines to fetch.
     */
    where?: MachineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Machines to fetch.
     */
    orderBy?: MachineOrderByWithRelationInput | MachineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Machines.
     */
    cursor?: MachineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Machines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Machines.
     */
    skip?: number
    distinct?: MachineScalarFieldEnum | MachineScalarFieldEnum[]
  }

  /**
   * Machine create
   */
  export type MachineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Machine
     */
    omit?: MachineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineInclude<ExtArgs> | null
    /**
     * The data needed to create a Machine.
     */
    data: XOR<MachineCreateInput, MachineUncheckedCreateInput>
  }

  /**
   * Machine createMany
   */
  export type MachineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Machines.
     */
    data: MachineCreateManyInput | MachineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Machine createManyAndReturn
   */
  export type MachineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Machine
     */
    omit?: MachineOmit<ExtArgs> | null
    /**
     * The data used to create many Machines.
     */
    data: MachineCreateManyInput | MachineCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Machine update
   */
  export type MachineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Machine
     */
    omit?: MachineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineInclude<ExtArgs> | null
    /**
     * The data needed to update a Machine.
     */
    data: XOR<MachineUpdateInput, MachineUncheckedUpdateInput>
    /**
     * Choose, which Machine to update.
     */
    where: MachineWhereUniqueInput
  }

  /**
   * Machine updateMany
   */
  export type MachineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Machines.
     */
    data: XOR<MachineUpdateManyMutationInput, MachineUncheckedUpdateManyInput>
    /**
     * Filter which Machines to update
     */
    where?: MachineWhereInput
    /**
     * Limit how many Machines to update.
     */
    limit?: number
  }

  /**
   * Machine updateManyAndReturn
   */
  export type MachineUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Machine
     */
    omit?: MachineOmit<ExtArgs> | null
    /**
     * The data used to update Machines.
     */
    data: XOR<MachineUpdateManyMutationInput, MachineUncheckedUpdateManyInput>
    /**
     * Filter which Machines to update
     */
    where?: MachineWhereInput
    /**
     * Limit how many Machines to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Machine upsert
   */
  export type MachineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Machine
     */
    omit?: MachineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineInclude<ExtArgs> | null
    /**
     * The filter to search for the Machine to update in case it exists.
     */
    where: MachineWhereUniqueInput
    /**
     * In case the Machine found by the `where` argument doesn't exist, create a new Machine with this data.
     */
    create: XOR<MachineCreateInput, MachineUncheckedCreateInput>
    /**
     * In case the Machine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MachineUpdateInput, MachineUncheckedUpdateInput>
  }

  /**
   * Machine delete
   */
  export type MachineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Machine
     */
    omit?: MachineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineInclude<ExtArgs> | null
    /**
     * Filter which Machine to delete.
     */
    where: MachineWhereUniqueInput
  }

  /**
   * Machine deleteMany
   */
  export type MachineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Machines to delete
     */
    where?: MachineWhereInput
    /**
     * Limit how many Machines to delete.
     */
    limit?: number
  }

  /**
   * Machine.UnifiedMachineState
   */
  export type Machine$UnifiedMachineStateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnifiedMachineState
     */
    select?: UnifiedMachineStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnifiedMachineState
     */
    omit?: UnifiedMachineStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnifiedMachineStateInclude<ExtArgs> | null
    where?: UnifiedMachineStateWhereInput
    orderBy?: UnifiedMachineStateOrderByWithRelationInput | UnifiedMachineStateOrderByWithRelationInput[]
    cursor?: UnifiedMachineStateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnifiedMachineStateScalarFieldEnum | UnifiedMachineStateScalarFieldEnum[]
  }

  /**
   * Machine.currentReadings
   */
  export type Machine$currentReadingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrentReading
     */
    select?: CurrentReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurrentReading
     */
    omit?: CurrentReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrentReadingInclude<ExtArgs> | null
    where?: CurrentReadingWhereInput
    orderBy?: CurrentReadingOrderByWithRelationInput | CurrentReadingOrderByWithRelationInput[]
    cursor?: CurrentReadingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CurrentReadingScalarFieldEnum | CurrentReadingScalarFieldEnum[]
  }

  /**
   * Machine.device
   */
  export type Machine$deviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    where?: DeviceWhereInput
  }

  /**
   * Machine.responsibleUser
   */
  export type Machine$responsibleUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Machine.oilLevelReadings
   */
  export type Machine$oilLevelReadingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OilLevelReading
     */
    select?: OilLevelReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OilLevelReading
     */
    omit?: OilLevelReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OilLevelReadingInclude<ExtArgs> | null
    where?: OilLevelReadingWhereInput
    orderBy?: OilLevelReadingOrderByWithRelationInput | OilLevelReadingOrderByWithRelationInput[]
    cursor?: OilLevelReadingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OilLevelReadingScalarFieldEnum | OilLevelReadingScalarFieldEnum[]
  }

  /**
   * Machine.oilTemperatureReadings
   */
  export type Machine$oilTemperatureReadingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OilTemperatureReading
     */
    select?: OilTemperatureReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OilTemperatureReading
     */
    omit?: OilTemperatureReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OilTemperatureReadingInclude<ExtArgs> | null
    where?: OilTemperatureReadingWhereInput
    orderBy?: OilTemperatureReadingOrderByWithRelationInput | OilTemperatureReadingOrderByWithRelationInput[]
    cursor?: OilTemperatureReadingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OilTemperatureReadingScalarFieldEnum | OilTemperatureReadingScalarFieldEnum[]
  }

  /**
   * Machine.rpmReadings
   */
  export type Machine$rpmReadingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RpmReading
     */
    select?: RpmReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RpmReading
     */
    omit?: RpmReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RpmReadingInclude<ExtArgs> | null
    where?: RpmReadingWhereInput
    orderBy?: RpmReadingOrderByWithRelationInput | RpmReadingOrderByWithRelationInput[]
    cursor?: RpmReadingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RpmReadingScalarFieldEnum | RpmReadingScalarFieldEnum[]
  }

  /**
   * Machine without action
   */
  export type MachineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Machine
     */
    omit?: MachineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineInclude<ExtArgs> | null
  }


  /**
   * Model UnifiedMachineState
   */

  export type AggregateUnifiedMachineState = {
    _count: UnifiedMachineStateCountAggregateOutputType | null
    _avg: UnifiedMachineStateAvgAggregateOutputType | null
    _sum: UnifiedMachineStateSumAggregateOutputType | null
    _min: UnifiedMachineStateMinAggregateOutputType | null
    _max: UnifiedMachineStateMaxAggregateOutputType | null
  }

  export type UnifiedMachineStateAvgAggregateOutputType = {
    machineId: number | null
    current: number | null
    rpm: number | null
    oilTemperature: number | null
    oilLevel: number | null
    clusterPredict: number | null
    clusterStrength: number | null
  }

  export type UnifiedMachineStateSumAggregateOutputType = {
    machineId: number | null
    current: number | null
    rpm: number | null
    oilTemperature: number | null
    oilLevel: number | null
    clusterPredict: number | null
    clusterStrength: number | null
  }

  export type UnifiedMachineStateMinAggregateOutputType = {
    id: string | null
    timestamp: Date | null
    machineId: number | null
    current: number | null
    rpm: number | null
    oilTemperature: number | null
    oilLevel: number | null
    clusterPredict: number | null
    clusterStrength: number | null
    currentIsMissing: boolean | null
    rpmIsMissing: boolean | null
    oilTemperatureIsMissing: boolean | null
    oilLevelIsMissing: boolean | null
  }

  export type UnifiedMachineStateMaxAggregateOutputType = {
    id: string | null
    timestamp: Date | null
    machineId: number | null
    current: number | null
    rpm: number | null
    oilTemperature: number | null
    oilLevel: number | null
    clusterPredict: number | null
    clusterStrength: number | null
    currentIsMissing: boolean | null
    rpmIsMissing: boolean | null
    oilTemperatureIsMissing: boolean | null
    oilLevelIsMissing: boolean | null
  }

  export type UnifiedMachineStateCountAggregateOutputType = {
    id: number
    timestamp: number
    machineId: number
    current: number
    rpm: number
    oilTemperature: number
    oilLevel: number
    clusterPredict: number
    clusterStrength: number
    currentIsMissing: number
    rpmIsMissing: number
    oilTemperatureIsMissing: number
    oilLevelIsMissing: number
    _all: number
  }


  export type UnifiedMachineStateAvgAggregateInputType = {
    machineId?: true
    current?: true
    rpm?: true
    oilTemperature?: true
    oilLevel?: true
    clusterPredict?: true
    clusterStrength?: true
  }

  export type UnifiedMachineStateSumAggregateInputType = {
    machineId?: true
    current?: true
    rpm?: true
    oilTemperature?: true
    oilLevel?: true
    clusterPredict?: true
    clusterStrength?: true
  }

  export type UnifiedMachineStateMinAggregateInputType = {
    id?: true
    timestamp?: true
    machineId?: true
    current?: true
    rpm?: true
    oilTemperature?: true
    oilLevel?: true
    clusterPredict?: true
    clusterStrength?: true
    currentIsMissing?: true
    rpmIsMissing?: true
    oilTemperatureIsMissing?: true
    oilLevelIsMissing?: true
  }

  export type UnifiedMachineStateMaxAggregateInputType = {
    id?: true
    timestamp?: true
    machineId?: true
    current?: true
    rpm?: true
    oilTemperature?: true
    oilLevel?: true
    clusterPredict?: true
    clusterStrength?: true
    currentIsMissing?: true
    rpmIsMissing?: true
    oilTemperatureIsMissing?: true
    oilLevelIsMissing?: true
  }

  export type UnifiedMachineStateCountAggregateInputType = {
    id?: true
    timestamp?: true
    machineId?: true
    current?: true
    rpm?: true
    oilTemperature?: true
    oilLevel?: true
    clusterPredict?: true
    clusterStrength?: true
    currentIsMissing?: true
    rpmIsMissing?: true
    oilTemperatureIsMissing?: true
    oilLevelIsMissing?: true
    _all?: true
  }

  export type UnifiedMachineStateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnifiedMachineState to aggregate.
     */
    where?: UnifiedMachineStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnifiedMachineStates to fetch.
     */
    orderBy?: UnifiedMachineStateOrderByWithRelationInput | UnifiedMachineStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnifiedMachineStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnifiedMachineStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnifiedMachineStates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UnifiedMachineStates
    **/
    _count?: true | UnifiedMachineStateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UnifiedMachineStateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UnifiedMachineStateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnifiedMachineStateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnifiedMachineStateMaxAggregateInputType
  }

  export type GetUnifiedMachineStateAggregateType<T extends UnifiedMachineStateAggregateArgs> = {
        [P in keyof T & keyof AggregateUnifiedMachineState]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnifiedMachineState[P]>
      : GetScalarType<T[P], AggregateUnifiedMachineState[P]>
  }




  export type UnifiedMachineStateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnifiedMachineStateWhereInput
    orderBy?: UnifiedMachineStateOrderByWithAggregationInput | UnifiedMachineStateOrderByWithAggregationInput[]
    by: UnifiedMachineStateScalarFieldEnum[] | UnifiedMachineStateScalarFieldEnum
    having?: UnifiedMachineStateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnifiedMachineStateCountAggregateInputType | true
    _avg?: UnifiedMachineStateAvgAggregateInputType
    _sum?: UnifiedMachineStateSumAggregateInputType
    _min?: UnifiedMachineStateMinAggregateInputType
    _max?: UnifiedMachineStateMaxAggregateInputType
  }

  export type UnifiedMachineStateGroupByOutputType = {
    id: string
    timestamp: Date
    machineId: number
    current: number | null
    rpm: number | null
    oilTemperature: number | null
    oilLevel: number | null
    clusterPredict: number | null
    clusterStrength: number | null
    currentIsMissing: boolean
    rpmIsMissing: boolean
    oilTemperatureIsMissing: boolean
    oilLevelIsMissing: boolean
    _count: UnifiedMachineStateCountAggregateOutputType | null
    _avg: UnifiedMachineStateAvgAggregateOutputType | null
    _sum: UnifiedMachineStateSumAggregateOutputType | null
    _min: UnifiedMachineStateMinAggregateOutputType | null
    _max: UnifiedMachineStateMaxAggregateOutputType | null
  }

  type GetUnifiedMachineStateGroupByPayload<T extends UnifiedMachineStateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnifiedMachineStateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnifiedMachineStateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnifiedMachineStateGroupByOutputType[P]>
            : GetScalarType<T[P], UnifiedMachineStateGroupByOutputType[P]>
        }
      >
    >


  export type UnifiedMachineStateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    machineId?: boolean
    current?: boolean
    rpm?: boolean
    oilTemperature?: boolean
    oilLevel?: boolean
    clusterPredict?: boolean
    clusterStrength?: boolean
    currentIsMissing?: boolean
    rpmIsMissing?: boolean
    oilTemperatureIsMissing?: boolean
    oilLevelIsMissing?: boolean
    machine?: boolean | MachineDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unifiedMachineState"]>

  export type UnifiedMachineStateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    machineId?: boolean
    current?: boolean
    rpm?: boolean
    oilTemperature?: boolean
    oilLevel?: boolean
    clusterPredict?: boolean
    clusterStrength?: boolean
    currentIsMissing?: boolean
    rpmIsMissing?: boolean
    oilTemperatureIsMissing?: boolean
    oilLevelIsMissing?: boolean
    machine?: boolean | MachineDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unifiedMachineState"]>

  export type UnifiedMachineStateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    machineId?: boolean
    current?: boolean
    rpm?: boolean
    oilTemperature?: boolean
    oilLevel?: boolean
    clusterPredict?: boolean
    clusterStrength?: boolean
    currentIsMissing?: boolean
    rpmIsMissing?: boolean
    oilTemperatureIsMissing?: boolean
    oilLevelIsMissing?: boolean
    machine?: boolean | MachineDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unifiedMachineState"]>

  export type UnifiedMachineStateSelectScalar = {
    id?: boolean
    timestamp?: boolean
    machineId?: boolean
    current?: boolean
    rpm?: boolean
    oilTemperature?: boolean
    oilLevel?: boolean
    clusterPredict?: boolean
    clusterStrength?: boolean
    currentIsMissing?: boolean
    rpmIsMissing?: boolean
    oilTemperatureIsMissing?: boolean
    oilLevelIsMissing?: boolean
  }

  export type UnifiedMachineStateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "timestamp" | "machineId" | "current" | "rpm" | "oilTemperature" | "oilLevel" | "clusterPredict" | "clusterStrength" | "currentIsMissing" | "rpmIsMissing" | "oilTemperatureIsMissing" | "oilLevelIsMissing", ExtArgs["result"]["unifiedMachineState"]>
  export type UnifiedMachineStateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    machine?: boolean | MachineDefaultArgs<ExtArgs>
  }
  export type UnifiedMachineStateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    machine?: boolean | MachineDefaultArgs<ExtArgs>
  }
  export type UnifiedMachineStateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    machine?: boolean | MachineDefaultArgs<ExtArgs>
  }

  export type $UnifiedMachineStatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UnifiedMachineState"
    objects: {
      machine: Prisma.$MachinePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      timestamp: Date
      machineId: number
      current: number | null
      rpm: number | null
      oilTemperature: number | null
      oilLevel: number | null
      clusterPredict: number | null
      clusterStrength: number | null
      currentIsMissing: boolean
      rpmIsMissing: boolean
      oilTemperatureIsMissing: boolean
      oilLevelIsMissing: boolean
    }, ExtArgs["result"]["unifiedMachineState"]>
    composites: {}
  }

  type UnifiedMachineStateGetPayload<S extends boolean | null | undefined | UnifiedMachineStateDefaultArgs> = $Result.GetResult<Prisma.$UnifiedMachineStatePayload, S>

  type UnifiedMachineStateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UnifiedMachineStateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UnifiedMachineStateCountAggregateInputType | true
    }

  export interface UnifiedMachineStateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UnifiedMachineState'], meta: { name: 'UnifiedMachineState' } }
    /**
     * Find zero or one UnifiedMachineState that matches the filter.
     * @param {UnifiedMachineStateFindUniqueArgs} args - Arguments to find a UnifiedMachineState
     * @example
     * // Get one UnifiedMachineState
     * const unifiedMachineState = await prisma.unifiedMachineState.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnifiedMachineStateFindUniqueArgs>(args: SelectSubset<T, UnifiedMachineStateFindUniqueArgs<ExtArgs>>): Prisma__UnifiedMachineStateClient<$Result.GetResult<Prisma.$UnifiedMachineStatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UnifiedMachineState that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UnifiedMachineStateFindUniqueOrThrowArgs} args - Arguments to find a UnifiedMachineState
     * @example
     * // Get one UnifiedMachineState
     * const unifiedMachineState = await prisma.unifiedMachineState.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnifiedMachineStateFindUniqueOrThrowArgs>(args: SelectSubset<T, UnifiedMachineStateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnifiedMachineStateClient<$Result.GetResult<Prisma.$UnifiedMachineStatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnifiedMachineState that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnifiedMachineStateFindFirstArgs} args - Arguments to find a UnifiedMachineState
     * @example
     * // Get one UnifiedMachineState
     * const unifiedMachineState = await prisma.unifiedMachineState.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnifiedMachineStateFindFirstArgs>(args?: SelectSubset<T, UnifiedMachineStateFindFirstArgs<ExtArgs>>): Prisma__UnifiedMachineStateClient<$Result.GetResult<Prisma.$UnifiedMachineStatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnifiedMachineState that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnifiedMachineStateFindFirstOrThrowArgs} args - Arguments to find a UnifiedMachineState
     * @example
     * // Get one UnifiedMachineState
     * const unifiedMachineState = await prisma.unifiedMachineState.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnifiedMachineStateFindFirstOrThrowArgs>(args?: SelectSubset<T, UnifiedMachineStateFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnifiedMachineStateClient<$Result.GetResult<Prisma.$UnifiedMachineStatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UnifiedMachineStates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnifiedMachineStateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UnifiedMachineStates
     * const unifiedMachineStates = await prisma.unifiedMachineState.findMany()
     * 
     * // Get first 10 UnifiedMachineStates
     * const unifiedMachineStates = await prisma.unifiedMachineState.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unifiedMachineStateWithIdOnly = await prisma.unifiedMachineState.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UnifiedMachineStateFindManyArgs>(args?: SelectSubset<T, UnifiedMachineStateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnifiedMachineStatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UnifiedMachineState.
     * @param {UnifiedMachineStateCreateArgs} args - Arguments to create a UnifiedMachineState.
     * @example
     * // Create one UnifiedMachineState
     * const UnifiedMachineState = await prisma.unifiedMachineState.create({
     *   data: {
     *     // ... data to create a UnifiedMachineState
     *   }
     * })
     * 
     */
    create<T extends UnifiedMachineStateCreateArgs>(args: SelectSubset<T, UnifiedMachineStateCreateArgs<ExtArgs>>): Prisma__UnifiedMachineStateClient<$Result.GetResult<Prisma.$UnifiedMachineStatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UnifiedMachineStates.
     * @param {UnifiedMachineStateCreateManyArgs} args - Arguments to create many UnifiedMachineStates.
     * @example
     * // Create many UnifiedMachineStates
     * const unifiedMachineState = await prisma.unifiedMachineState.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnifiedMachineStateCreateManyArgs>(args?: SelectSubset<T, UnifiedMachineStateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UnifiedMachineStates and returns the data saved in the database.
     * @param {UnifiedMachineStateCreateManyAndReturnArgs} args - Arguments to create many UnifiedMachineStates.
     * @example
     * // Create many UnifiedMachineStates
     * const unifiedMachineState = await prisma.unifiedMachineState.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UnifiedMachineStates and only return the `id`
     * const unifiedMachineStateWithIdOnly = await prisma.unifiedMachineState.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UnifiedMachineStateCreateManyAndReturnArgs>(args?: SelectSubset<T, UnifiedMachineStateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnifiedMachineStatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UnifiedMachineState.
     * @param {UnifiedMachineStateDeleteArgs} args - Arguments to delete one UnifiedMachineState.
     * @example
     * // Delete one UnifiedMachineState
     * const UnifiedMachineState = await prisma.unifiedMachineState.delete({
     *   where: {
     *     // ... filter to delete one UnifiedMachineState
     *   }
     * })
     * 
     */
    delete<T extends UnifiedMachineStateDeleteArgs>(args: SelectSubset<T, UnifiedMachineStateDeleteArgs<ExtArgs>>): Prisma__UnifiedMachineStateClient<$Result.GetResult<Prisma.$UnifiedMachineStatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UnifiedMachineState.
     * @param {UnifiedMachineStateUpdateArgs} args - Arguments to update one UnifiedMachineState.
     * @example
     * // Update one UnifiedMachineState
     * const unifiedMachineState = await prisma.unifiedMachineState.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnifiedMachineStateUpdateArgs>(args: SelectSubset<T, UnifiedMachineStateUpdateArgs<ExtArgs>>): Prisma__UnifiedMachineStateClient<$Result.GetResult<Prisma.$UnifiedMachineStatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UnifiedMachineStates.
     * @param {UnifiedMachineStateDeleteManyArgs} args - Arguments to filter UnifiedMachineStates to delete.
     * @example
     * // Delete a few UnifiedMachineStates
     * const { count } = await prisma.unifiedMachineState.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnifiedMachineStateDeleteManyArgs>(args?: SelectSubset<T, UnifiedMachineStateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnifiedMachineStates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnifiedMachineStateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UnifiedMachineStates
     * const unifiedMachineState = await prisma.unifiedMachineState.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnifiedMachineStateUpdateManyArgs>(args: SelectSubset<T, UnifiedMachineStateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnifiedMachineStates and returns the data updated in the database.
     * @param {UnifiedMachineStateUpdateManyAndReturnArgs} args - Arguments to update many UnifiedMachineStates.
     * @example
     * // Update many UnifiedMachineStates
     * const unifiedMachineState = await prisma.unifiedMachineState.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UnifiedMachineStates and only return the `id`
     * const unifiedMachineStateWithIdOnly = await prisma.unifiedMachineState.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UnifiedMachineStateUpdateManyAndReturnArgs>(args: SelectSubset<T, UnifiedMachineStateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnifiedMachineStatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UnifiedMachineState.
     * @param {UnifiedMachineStateUpsertArgs} args - Arguments to update or create a UnifiedMachineState.
     * @example
     * // Update or create a UnifiedMachineState
     * const unifiedMachineState = await prisma.unifiedMachineState.upsert({
     *   create: {
     *     // ... data to create a UnifiedMachineState
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UnifiedMachineState we want to update
     *   }
     * })
     */
    upsert<T extends UnifiedMachineStateUpsertArgs>(args: SelectSubset<T, UnifiedMachineStateUpsertArgs<ExtArgs>>): Prisma__UnifiedMachineStateClient<$Result.GetResult<Prisma.$UnifiedMachineStatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UnifiedMachineStates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnifiedMachineStateCountArgs} args - Arguments to filter UnifiedMachineStates to count.
     * @example
     * // Count the number of UnifiedMachineStates
     * const count = await prisma.unifiedMachineState.count({
     *   where: {
     *     // ... the filter for the UnifiedMachineStates we want to count
     *   }
     * })
    **/
    count<T extends UnifiedMachineStateCountArgs>(
      args?: Subset<T, UnifiedMachineStateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnifiedMachineStateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UnifiedMachineState.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnifiedMachineStateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnifiedMachineStateAggregateArgs>(args: Subset<T, UnifiedMachineStateAggregateArgs>): Prisma.PrismaPromise<GetUnifiedMachineStateAggregateType<T>>

    /**
     * Group by UnifiedMachineState.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnifiedMachineStateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnifiedMachineStateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnifiedMachineStateGroupByArgs['orderBy'] }
        : { orderBy?: UnifiedMachineStateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnifiedMachineStateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnifiedMachineStateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UnifiedMachineState model
   */
  readonly fields: UnifiedMachineStateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UnifiedMachineState.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnifiedMachineStateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    machine<T extends MachineDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MachineDefaultArgs<ExtArgs>>): Prisma__MachineClient<$Result.GetResult<Prisma.$MachinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UnifiedMachineState model
   */
  interface UnifiedMachineStateFieldRefs {
    readonly id: FieldRef<"UnifiedMachineState", 'String'>
    readonly timestamp: FieldRef<"UnifiedMachineState", 'DateTime'>
    readonly machineId: FieldRef<"UnifiedMachineState", 'Int'>
    readonly current: FieldRef<"UnifiedMachineState", 'Float'>
    readonly rpm: FieldRef<"UnifiedMachineState", 'Int'>
    readonly oilTemperature: FieldRef<"UnifiedMachineState", 'Float'>
    readonly oilLevel: FieldRef<"UnifiedMachineState", 'Float'>
    readonly clusterPredict: FieldRef<"UnifiedMachineState", 'Int'>
    readonly clusterStrength: FieldRef<"UnifiedMachineState", 'Float'>
    readonly currentIsMissing: FieldRef<"UnifiedMachineState", 'Boolean'>
    readonly rpmIsMissing: FieldRef<"UnifiedMachineState", 'Boolean'>
    readonly oilTemperatureIsMissing: FieldRef<"UnifiedMachineState", 'Boolean'>
    readonly oilLevelIsMissing: FieldRef<"UnifiedMachineState", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * UnifiedMachineState findUnique
   */
  export type UnifiedMachineStateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnifiedMachineState
     */
    select?: UnifiedMachineStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnifiedMachineState
     */
    omit?: UnifiedMachineStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnifiedMachineStateInclude<ExtArgs> | null
    /**
     * Filter, which UnifiedMachineState to fetch.
     */
    where: UnifiedMachineStateWhereUniqueInput
  }

  /**
   * UnifiedMachineState findUniqueOrThrow
   */
  export type UnifiedMachineStateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnifiedMachineState
     */
    select?: UnifiedMachineStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnifiedMachineState
     */
    omit?: UnifiedMachineStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnifiedMachineStateInclude<ExtArgs> | null
    /**
     * Filter, which UnifiedMachineState to fetch.
     */
    where: UnifiedMachineStateWhereUniqueInput
  }

  /**
   * UnifiedMachineState findFirst
   */
  export type UnifiedMachineStateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnifiedMachineState
     */
    select?: UnifiedMachineStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnifiedMachineState
     */
    omit?: UnifiedMachineStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnifiedMachineStateInclude<ExtArgs> | null
    /**
     * Filter, which UnifiedMachineState to fetch.
     */
    where?: UnifiedMachineStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnifiedMachineStates to fetch.
     */
    orderBy?: UnifiedMachineStateOrderByWithRelationInput | UnifiedMachineStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnifiedMachineStates.
     */
    cursor?: UnifiedMachineStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnifiedMachineStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnifiedMachineStates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnifiedMachineStates.
     */
    distinct?: UnifiedMachineStateScalarFieldEnum | UnifiedMachineStateScalarFieldEnum[]
  }

  /**
   * UnifiedMachineState findFirstOrThrow
   */
  export type UnifiedMachineStateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnifiedMachineState
     */
    select?: UnifiedMachineStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnifiedMachineState
     */
    omit?: UnifiedMachineStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnifiedMachineStateInclude<ExtArgs> | null
    /**
     * Filter, which UnifiedMachineState to fetch.
     */
    where?: UnifiedMachineStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnifiedMachineStates to fetch.
     */
    orderBy?: UnifiedMachineStateOrderByWithRelationInput | UnifiedMachineStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnifiedMachineStates.
     */
    cursor?: UnifiedMachineStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnifiedMachineStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnifiedMachineStates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnifiedMachineStates.
     */
    distinct?: UnifiedMachineStateScalarFieldEnum | UnifiedMachineStateScalarFieldEnum[]
  }

  /**
   * UnifiedMachineState findMany
   */
  export type UnifiedMachineStateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnifiedMachineState
     */
    select?: UnifiedMachineStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnifiedMachineState
     */
    omit?: UnifiedMachineStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnifiedMachineStateInclude<ExtArgs> | null
    /**
     * Filter, which UnifiedMachineStates to fetch.
     */
    where?: UnifiedMachineStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnifiedMachineStates to fetch.
     */
    orderBy?: UnifiedMachineStateOrderByWithRelationInput | UnifiedMachineStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UnifiedMachineStates.
     */
    cursor?: UnifiedMachineStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnifiedMachineStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnifiedMachineStates.
     */
    skip?: number
    distinct?: UnifiedMachineStateScalarFieldEnum | UnifiedMachineStateScalarFieldEnum[]
  }

  /**
   * UnifiedMachineState create
   */
  export type UnifiedMachineStateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnifiedMachineState
     */
    select?: UnifiedMachineStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnifiedMachineState
     */
    omit?: UnifiedMachineStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnifiedMachineStateInclude<ExtArgs> | null
    /**
     * The data needed to create a UnifiedMachineState.
     */
    data: XOR<UnifiedMachineStateCreateInput, UnifiedMachineStateUncheckedCreateInput>
  }

  /**
   * UnifiedMachineState createMany
   */
  export type UnifiedMachineStateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UnifiedMachineStates.
     */
    data: UnifiedMachineStateCreateManyInput | UnifiedMachineStateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UnifiedMachineState createManyAndReturn
   */
  export type UnifiedMachineStateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnifiedMachineState
     */
    select?: UnifiedMachineStateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UnifiedMachineState
     */
    omit?: UnifiedMachineStateOmit<ExtArgs> | null
    /**
     * The data used to create many UnifiedMachineStates.
     */
    data: UnifiedMachineStateCreateManyInput | UnifiedMachineStateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnifiedMachineStateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UnifiedMachineState update
   */
  export type UnifiedMachineStateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnifiedMachineState
     */
    select?: UnifiedMachineStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnifiedMachineState
     */
    omit?: UnifiedMachineStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnifiedMachineStateInclude<ExtArgs> | null
    /**
     * The data needed to update a UnifiedMachineState.
     */
    data: XOR<UnifiedMachineStateUpdateInput, UnifiedMachineStateUncheckedUpdateInput>
    /**
     * Choose, which UnifiedMachineState to update.
     */
    where: UnifiedMachineStateWhereUniqueInput
  }

  /**
   * UnifiedMachineState updateMany
   */
  export type UnifiedMachineStateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UnifiedMachineStates.
     */
    data: XOR<UnifiedMachineStateUpdateManyMutationInput, UnifiedMachineStateUncheckedUpdateManyInput>
    /**
     * Filter which UnifiedMachineStates to update
     */
    where?: UnifiedMachineStateWhereInput
    /**
     * Limit how many UnifiedMachineStates to update.
     */
    limit?: number
  }

  /**
   * UnifiedMachineState updateManyAndReturn
   */
  export type UnifiedMachineStateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnifiedMachineState
     */
    select?: UnifiedMachineStateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UnifiedMachineState
     */
    omit?: UnifiedMachineStateOmit<ExtArgs> | null
    /**
     * The data used to update UnifiedMachineStates.
     */
    data: XOR<UnifiedMachineStateUpdateManyMutationInput, UnifiedMachineStateUncheckedUpdateManyInput>
    /**
     * Filter which UnifiedMachineStates to update
     */
    where?: UnifiedMachineStateWhereInput
    /**
     * Limit how many UnifiedMachineStates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnifiedMachineStateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UnifiedMachineState upsert
   */
  export type UnifiedMachineStateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnifiedMachineState
     */
    select?: UnifiedMachineStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnifiedMachineState
     */
    omit?: UnifiedMachineStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnifiedMachineStateInclude<ExtArgs> | null
    /**
     * The filter to search for the UnifiedMachineState to update in case it exists.
     */
    where: UnifiedMachineStateWhereUniqueInput
    /**
     * In case the UnifiedMachineState found by the `where` argument doesn't exist, create a new UnifiedMachineState with this data.
     */
    create: XOR<UnifiedMachineStateCreateInput, UnifiedMachineStateUncheckedCreateInput>
    /**
     * In case the UnifiedMachineState was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnifiedMachineStateUpdateInput, UnifiedMachineStateUncheckedUpdateInput>
  }

  /**
   * UnifiedMachineState delete
   */
  export type UnifiedMachineStateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnifiedMachineState
     */
    select?: UnifiedMachineStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnifiedMachineState
     */
    omit?: UnifiedMachineStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnifiedMachineStateInclude<ExtArgs> | null
    /**
     * Filter which UnifiedMachineState to delete.
     */
    where: UnifiedMachineStateWhereUniqueInput
  }

  /**
   * UnifiedMachineState deleteMany
   */
  export type UnifiedMachineStateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnifiedMachineStates to delete
     */
    where?: UnifiedMachineStateWhereInput
    /**
     * Limit how many UnifiedMachineStates to delete.
     */
    limit?: number
  }

  /**
   * UnifiedMachineState without action
   */
  export type UnifiedMachineStateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnifiedMachineState
     */
    select?: UnifiedMachineStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnifiedMachineState
     */
    omit?: UnifiedMachineStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnifiedMachineStateInclude<ExtArgs> | null
  }


  /**
   * Model Device
   */

  export type AggregateDevice = {
    _count: DeviceCountAggregateOutputType | null
    _avg: DeviceAvgAggregateOutputType | null
    _sum: DeviceSumAggregateOutputType | null
    _min: DeviceMinAggregateOutputType | null
    _max: DeviceMaxAggregateOutputType | null
  }

  export type DeviceAvgAggregateOutputType = {
    id: number | null
    gatewayId: number | null
    clientId: number | null
  }

  export type DeviceSumAggregateOutputType = {
    id: number | null
    gatewayId: number | null
    clientId: number | null
  }

  export type DeviceMinAggregateOutputType = {
    id: number | null
    nodeId: string | null
    description: string | null
    status: $Enums.DeviceStatus | null
    lastHeartbeat: Date | null
    gatewayId: number | null
    clientId: number | null
  }

  export type DeviceMaxAggregateOutputType = {
    id: number | null
    nodeId: string | null
    description: string | null
    status: $Enums.DeviceStatus | null
    lastHeartbeat: Date | null
    gatewayId: number | null
    clientId: number | null
  }

  export type DeviceCountAggregateOutputType = {
    id: number
    nodeId: number
    description: number
    status: number
    lastHeartbeat: number
    gatewayId: number
    clientId: number
    _all: number
  }


  export type DeviceAvgAggregateInputType = {
    id?: true
    gatewayId?: true
    clientId?: true
  }

  export type DeviceSumAggregateInputType = {
    id?: true
    gatewayId?: true
    clientId?: true
  }

  export type DeviceMinAggregateInputType = {
    id?: true
    nodeId?: true
    description?: true
    status?: true
    lastHeartbeat?: true
    gatewayId?: true
    clientId?: true
  }

  export type DeviceMaxAggregateInputType = {
    id?: true
    nodeId?: true
    description?: true
    status?: true
    lastHeartbeat?: true
    gatewayId?: true
    clientId?: true
  }

  export type DeviceCountAggregateInputType = {
    id?: true
    nodeId?: true
    description?: true
    status?: true
    lastHeartbeat?: true
    gatewayId?: true
    clientId?: true
    _all?: true
  }

  export type DeviceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Device to aggregate.
     */
    where?: DeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devices to fetch.
     */
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Devices
    **/
    _count?: true | DeviceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeviceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeviceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeviceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeviceMaxAggregateInputType
  }

  export type GetDeviceAggregateType<T extends DeviceAggregateArgs> = {
        [P in keyof T & keyof AggregateDevice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDevice[P]>
      : GetScalarType<T[P], AggregateDevice[P]>
  }




  export type DeviceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceWhereInput
    orderBy?: DeviceOrderByWithAggregationInput | DeviceOrderByWithAggregationInput[]
    by: DeviceScalarFieldEnum[] | DeviceScalarFieldEnum
    having?: DeviceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeviceCountAggregateInputType | true
    _avg?: DeviceAvgAggregateInputType
    _sum?: DeviceSumAggregateInputType
    _min?: DeviceMinAggregateInputType
    _max?: DeviceMaxAggregateInputType
  }

  export type DeviceGroupByOutputType = {
    id: number
    nodeId: string
    description: string | null
    status: $Enums.DeviceStatus
    lastHeartbeat: Date
    gatewayId: number | null
    clientId: number
    _count: DeviceCountAggregateOutputType | null
    _avg: DeviceAvgAggregateOutputType | null
    _sum: DeviceSumAggregateOutputType | null
    _min: DeviceMinAggregateOutputType | null
    _max: DeviceMaxAggregateOutputType | null
  }

  type GetDeviceGroupByPayload<T extends DeviceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeviceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeviceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeviceGroupByOutputType[P]>
            : GetScalarType<T[P], DeviceGroupByOutputType[P]>
        }
      >
    >


  export type DeviceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nodeId?: boolean
    description?: boolean
    status?: boolean
    lastHeartbeat?: boolean
    gatewayId?: boolean
    clientId?: boolean
    gateway?: boolean | Device$gatewayArgs<ExtArgs>
    machine?: boolean | Device$machineArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["device"]>

  export type DeviceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nodeId?: boolean
    description?: boolean
    status?: boolean
    lastHeartbeat?: boolean
    gatewayId?: boolean
    clientId?: boolean
    gateway?: boolean | Device$gatewayArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["device"]>

  export type DeviceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nodeId?: boolean
    description?: boolean
    status?: boolean
    lastHeartbeat?: boolean
    gatewayId?: boolean
    clientId?: boolean
    gateway?: boolean | Device$gatewayArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["device"]>

  export type DeviceSelectScalar = {
    id?: boolean
    nodeId?: boolean
    description?: boolean
    status?: boolean
    lastHeartbeat?: boolean
    gatewayId?: boolean
    clientId?: boolean
  }

  export type DeviceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nodeId" | "description" | "status" | "lastHeartbeat" | "gatewayId" | "clientId", ExtArgs["result"]["device"]>
  export type DeviceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gateway?: boolean | Device$gatewayArgs<ExtArgs>
    machine?: boolean | Device$machineArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }
  export type DeviceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gateway?: boolean | Device$gatewayArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }
  export type DeviceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gateway?: boolean | Device$gatewayArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }

  export type $DevicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Device"
    objects: {
      gateway: Prisma.$GatewayPayload<ExtArgs> | null
      machine: Prisma.$MachinePayload<ExtArgs> | null
      client: Prisma.$ClientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nodeId: string
      description: string | null
      status: $Enums.DeviceStatus
      lastHeartbeat: Date
      gatewayId: number | null
      clientId: number
    }, ExtArgs["result"]["device"]>
    composites: {}
  }

  type DeviceGetPayload<S extends boolean | null | undefined | DeviceDefaultArgs> = $Result.GetResult<Prisma.$DevicePayload, S>

  type DeviceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeviceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeviceCountAggregateInputType | true
    }

  export interface DeviceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Device'], meta: { name: 'Device' } }
    /**
     * Find zero or one Device that matches the filter.
     * @param {DeviceFindUniqueArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeviceFindUniqueArgs>(args: SelectSubset<T, DeviceFindUniqueArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Device that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeviceFindUniqueOrThrowArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeviceFindUniqueOrThrowArgs>(args: SelectSubset<T, DeviceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Device that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceFindFirstArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeviceFindFirstArgs>(args?: SelectSubset<T, DeviceFindFirstArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Device that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceFindFirstOrThrowArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeviceFindFirstOrThrowArgs>(args?: SelectSubset<T, DeviceFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Devices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Devices
     * const devices = await prisma.device.findMany()
     * 
     * // Get first 10 Devices
     * const devices = await prisma.device.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deviceWithIdOnly = await prisma.device.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeviceFindManyArgs>(args?: SelectSubset<T, DeviceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Device.
     * @param {DeviceCreateArgs} args - Arguments to create a Device.
     * @example
     * // Create one Device
     * const Device = await prisma.device.create({
     *   data: {
     *     // ... data to create a Device
     *   }
     * })
     * 
     */
    create<T extends DeviceCreateArgs>(args: SelectSubset<T, DeviceCreateArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Devices.
     * @param {DeviceCreateManyArgs} args - Arguments to create many Devices.
     * @example
     * // Create many Devices
     * const device = await prisma.device.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeviceCreateManyArgs>(args?: SelectSubset<T, DeviceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Devices and returns the data saved in the database.
     * @param {DeviceCreateManyAndReturnArgs} args - Arguments to create many Devices.
     * @example
     * // Create many Devices
     * const device = await prisma.device.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Devices and only return the `id`
     * const deviceWithIdOnly = await prisma.device.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeviceCreateManyAndReturnArgs>(args?: SelectSubset<T, DeviceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Device.
     * @param {DeviceDeleteArgs} args - Arguments to delete one Device.
     * @example
     * // Delete one Device
     * const Device = await prisma.device.delete({
     *   where: {
     *     // ... filter to delete one Device
     *   }
     * })
     * 
     */
    delete<T extends DeviceDeleteArgs>(args: SelectSubset<T, DeviceDeleteArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Device.
     * @param {DeviceUpdateArgs} args - Arguments to update one Device.
     * @example
     * // Update one Device
     * const device = await prisma.device.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeviceUpdateArgs>(args: SelectSubset<T, DeviceUpdateArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Devices.
     * @param {DeviceDeleteManyArgs} args - Arguments to filter Devices to delete.
     * @example
     * // Delete a few Devices
     * const { count } = await prisma.device.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeviceDeleteManyArgs>(args?: SelectSubset<T, DeviceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Devices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Devices
     * const device = await prisma.device.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeviceUpdateManyArgs>(args: SelectSubset<T, DeviceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Devices and returns the data updated in the database.
     * @param {DeviceUpdateManyAndReturnArgs} args - Arguments to update many Devices.
     * @example
     * // Update many Devices
     * const device = await prisma.device.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Devices and only return the `id`
     * const deviceWithIdOnly = await prisma.device.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeviceUpdateManyAndReturnArgs>(args: SelectSubset<T, DeviceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Device.
     * @param {DeviceUpsertArgs} args - Arguments to update or create a Device.
     * @example
     * // Update or create a Device
     * const device = await prisma.device.upsert({
     *   create: {
     *     // ... data to create a Device
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Device we want to update
     *   }
     * })
     */
    upsert<T extends DeviceUpsertArgs>(args: SelectSubset<T, DeviceUpsertArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Devices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceCountArgs} args - Arguments to filter Devices to count.
     * @example
     * // Count the number of Devices
     * const count = await prisma.device.count({
     *   where: {
     *     // ... the filter for the Devices we want to count
     *   }
     * })
    **/
    count<T extends DeviceCountArgs>(
      args?: Subset<T, DeviceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeviceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Device.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeviceAggregateArgs>(args: Subset<T, DeviceAggregateArgs>): Prisma.PrismaPromise<GetDeviceAggregateType<T>>

    /**
     * Group by Device.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeviceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeviceGroupByArgs['orderBy'] }
        : { orderBy?: DeviceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeviceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeviceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Device model
   */
  readonly fields: DeviceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Device.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeviceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    gateway<T extends Device$gatewayArgs<ExtArgs> = {}>(args?: Subset<T, Device$gatewayArgs<ExtArgs>>): Prisma__GatewayClient<$Result.GetResult<Prisma.$GatewayPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    machine<T extends Device$machineArgs<ExtArgs> = {}>(args?: Subset<T, Device$machineArgs<ExtArgs>>): Prisma__MachineClient<$Result.GetResult<Prisma.$MachinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Device model
   */
  interface DeviceFieldRefs {
    readonly id: FieldRef<"Device", 'Int'>
    readonly nodeId: FieldRef<"Device", 'String'>
    readonly description: FieldRef<"Device", 'String'>
    readonly status: FieldRef<"Device", 'DeviceStatus'>
    readonly lastHeartbeat: FieldRef<"Device", 'DateTime'>
    readonly gatewayId: FieldRef<"Device", 'Int'>
    readonly clientId: FieldRef<"Device", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Device findUnique
   */
  export type DeviceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Device to fetch.
     */
    where: DeviceWhereUniqueInput
  }

  /**
   * Device findUniqueOrThrow
   */
  export type DeviceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Device to fetch.
     */
    where: DeviceWhereUniqueInput
  }

  /**
   * Device findFirst
   */
  export type DeviceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Device to fetch.
     */
    where?: DeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devices to fetch.
     */
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Devices.
     */
    cursor?: DeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Devices.
     */
    distinct?: DeviceScalarFieldEnum | DeviceScalarFieldEnum[]
  }

  /**
   * Device findFirstOrThrow
   */
  export type DeviceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Device to fetch.
     */
    where?: DeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devices to fetch.
     */
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Devices.
     */
    cursor?: DeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Devices.
     */
    distinct?: DeviceScalarFieldEnum | DeviceScalarFieldEnum[]
  }

  /**
   * Device findMany
   */
  export type DeviceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Devices to fetch.
     */
    where?: DeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devices to fetch.
     */
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Devices.
     */
    cursor?: DeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devices.
     */
    skip?: number
    distinct?: DeviceScalarFieldEnum | DeviceScalarFieldEnum[]
  }

  /**
   * Device create
   */
  export type DeviceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * The data needed to create a Device.
     */
    data: XOR<DeviceCreateInput, DeviceUncheckedCreateInput>
  }

  /**
   * Device createMany
   */
  export type DeviceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Devices.
     */
    data: DeviceCreateManyInput | DeviceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Device createManyAndReturn
   */
  export type DeviceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * The data used to create many Devices.
     */
    data: DeviceCreateManyInput | DeviceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Device update
   */
  export type DeviceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * The data needed to update a Device.
     */
    data: XOR<DeviceUpdateInput, DeviceUncheckedUpdateInput>
    /**
     * Choose, which Device to update.
     */
    where: DeviceWhereUniqueInput
  }

  /**
   * Device updateMany
   */
  export type DeviceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Devices.
     */
    data: XOR<DeviceUpdateManyMutationInput, DeviceUncheckedUpdateManyInput>
    /**
     * Filter which Devices to update
     */
    where?: DeviceWhereInput
    /**
     * Limit how many Devices to update.
     */
    limit?: number
  }

  /**
   * Device updateManyAndReturn
   */
  export type DeviceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * The data used to update Devices.
     */
    data: XOR<DeviceUpdateManyMutationInput, DeviceUncheckedUpdateManyInput>
    /**
     * Filter which Devices to update
     */
    where?: DeviceWhereInput
    /**
     * Limit how many Devices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Device upsert
   */
  export type DeviceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * The filter to search for the Device to update in case it exists.
     */
    where: DeviceWhereUniqueInput
    /**
     * In case the Device found by the `where` argument doesn't exist, create a new Device with this data.
     */
    create: XOR<DeviceCreateInput, DeviceUncheckedCreateInput>
    /**
     * In case the Device was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeviceUpdateInput, DeviceUncheckedUpdateInput>
  }

  /**
   * Device delete
   */
  export type DeviceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter which Device to delete.
     */
    where: DeviceWhereUniqueInput
  }

  /**
   * Device deleteMany
   */
  export type DeviceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Devices to delete
     */
    where?: DeviceWhereInput
    /**
     * Limit how many Devices to delete.
     */
    limit?: number
  }

  /**
   * Device.gateway
   */
  export type Device$gatewayArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gateway
     */
    select?: GatewaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gateway
     */
    omit?: GatewayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GatewayInclude<ExtArgs> | null
    where?: GatewayWhereInput
  }

  /**
   * Device.machine
   */
  export type Device$machineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Machine
     */
    omit?: MachineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineInclude<ExtArgs> | null
    where?: MachineWhereInput
  }

  /**
   * Device without action
   */
  export type DeviceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
  }


  /**
   * Model Gateway
   */

  export type AggregateGateway = {
    _count: GatewayCountAggregateOutputType | null
    _avg: GatewayAvgAggregateOutputType | null
    _sum: GatewaySumAggregateOutputType | null
    _min: GatewayMinAggregateOutputType | null
    _max: GatewayMaxAggregateOutputType | null
  }

  export type GatewayAvgAggregateOutputType = {
    id: number | null
    clientId: number | null
  }

  export type GatewaySumAggregateOutputType = {
    id: number | null
    clientId: number | null
  }

  export type GatewayMinAggregateOutputType = {
    id: number | null
    gatewayId: string | null
    description: string | null
    status: $Enums.DeviceStatus | null
    lastHeartbeat: Date | null
    clientId: number | null
  }

  export type GatewayMaxAggregateOutputType = {
    id: number | null
    gatewayId: string | null
    description: string | null
    status: $Enums.DeviceStatus | null
    lastHeartbeat: Date | null
    clientId: number | null
  }

  export type GatewayCountAggregateOutputType = {
    id: number
    gatewayId: number
    description: number
    status: number
    lastHeartbeat: number
    clientId: number
    _all: number
  }


  export type GatewayAvgAggregateInputType = {
    id?: true
    clientId?: true
  }

  export type GatewaySumAggregateInputType = {
    id?: true
    clientId?: true
  }

  export type GatewayMinAggregateInputType = {
    id?: true
    gatewayId?: true
    description?: true
    status?: true
    lastHeartbeat?: true
    clientId?: true
  }

  export type GatewayMaxAggregateInputType = {
    id?: true
    gatewayId?: true
    description?: true
    status?: true
    lastHeartbeat?: true
    clientId?: true
  }

  export type GatewayCountAggregateInputType = {
    id?: true
    gatewayId?: true
    description?: true
    status?: true
    lastHeartbeat?: true
    clientId?: true
    _all?: true
  }

  export type GatewayAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Gateway to aggregate.
     */
    where?: GatewayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gateways to fetch.
     */
    orderBy?: GatewayOrderByWithRelationInput | GatewayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GatewayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gateways from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gateways.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Gateways
    **/
    _count?: true | GatewayCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GatewayAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GatewaySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GatewayMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GatewayMaxAggregateInputType
  }

  export type GetGatewayAggregateType<T extends GatewayAggregateArgs> = {
        [P in keyof T & keyof AggregateGateway]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGateway[P]>
      : GetScalarType<T[P], AggregateGateway[P]>
  }




  export type GatewayGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GatewayWhereInput
    orderBy?: GatewayOrderByWithAggregationInput | GatewayOrderByWithAggregationInput[]
    by: GatewayScalarFieldEnum[] | GatewayScalarFieldEnum
    having?: GatewayScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GatewayCountAggregateInputType | true
    _avg?: GatewayAvgAggregateInputType
    _sum?: GatewaySumAggregateInputType
    _min?: GatewayMinAggregateInputType
    _max?: GatewayMaxAggregateInputType
  }

  export type GatewayGroupByOutputType = {
    id: number
    gatewayId: string
    description: string | null
    status: $Enums.DeviceStatus
    lastHeartbeat: Date
    clientId: number
    _count: GatewayCountAggregateOutputType | null
    _avg: GatewayAvgAggregateOutputType | null
    _sum: GatewaySumAggregateOutputType | null
    _min: GatewayMinAggregateOutputType | null
    _max: GatewayMaxAggregateOutputType | null
  }

  type GetGatewayGroupByPayload<T extends GatewayGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GatewayGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GatewayGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GatewayGroupByOutputType[P]>
            : GetScalarType<T[P], GatewayGroupByOutputType[P]>
        }
      >
    >


  export type GatewaySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gatewayId?: boolean
    description?: boolean
    status?: boolean
    lastHeartbeat?: boolean
    clientId?: boolean
    responsibleFor?: boolean | Gateway$responsibleForArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
    _count?: boolean | GatewayCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gateway"]>

  export type GatewaySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gatewayId?: boolean
    description?: boolean
    status?: boolean
    lastHeartbeat?: boolean
    clientId?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gateway"]>

  export type GatewaySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gatewayId?: boolean
    description?: boolean
    status?: boolean
    lastHeartbeat?: boolean
    clientId?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gateway"]>

  export type GatewaySelectScalar = {
    id?: boolean
    gatewayId?: boolean
    description?: boolean
    status?: boolean
    lastHeartbeat?: boolean
    clientId?: boolean
  }

  export type GatewayOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "gatewayId" | "description" | "status" | "lastHeartbeat" | "clientId", ExtArgs["result"]["gateway"]>
  export type GatewayInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    responsibleFor?: boolean | Gateway$responsibleForArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
    _count?: boolean | GatewayCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GatewayIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }
  export type GatewayIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }

  export type $GatewayPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Gateway"
    objects: {
      responsibleFor: Prisma.$DevicePayload<ExtArgs>[]
      client: Prisma.$ClientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      gatewayId: string
      description: string | null
      status: $Enums.DeviceStatus
      lastHeartbeat: Date
      clientId: number
    }, ExtArgs["result"]["gateway"]>
    composites: {}
  }

  type GatewayGetPayload<S extends boolean | null | undefined | GatewayDefaultArgs> = $Result.GetResult<Prisma.$GatewayPayload, S>

  type GatewayCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GatewayFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GatewayCountAggregateInputType | true
    }

  export interface GatewayDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Gateway'], meta: { name: 'Gateway' } }
    /**
     * Find zero or one Gateway that matches the filter.
     * @param {GatewayFindUniqueArgs} args - Arguments to find a Gateway
     * @example
     * // Get one Gateway
     * const gateway = await prisma.gateway.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GatewayFindUniqueArgs>(args: SelectSubset<T, GatewayFindUniqueArgs<ExtArgs>>): Prisma__GatewayClient<$Result.GetResult<Prisma.$GatewayPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Gateway that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GatewayFindUniqueOrThrowArgs} args - Arguments to find a Gateway
     * @example
     * // Get one Gateway
     * const gateway = await prisma.gateway.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GatewayFindUniqueOrThrowArgs>(args: SelectSubset<T, GatewayFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GatewayClient<$Result.GetResult<Prisma.$GatewayPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Gateway that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GatewayFindFirstArgs} args - Arguments to find a Gateway
     * @example
     * // Get one Gateway
     * const gateway = await prisma.gateway.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GatewayFindFirstArgs>(args?: SelectSubset<T, GatewayFindFirstArgs<ExtArgs>>): Prisma__GatewayClient<$Result.GetResult<Prisma.$GatewayPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Gateway that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GatewayFindFirstOrThrowArgs} args - Arguments to find a Gateway
     * @example
     * // Get one Gateway
     * const gateway = await prisma.gateway.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GatewayFindFirstOrThrowArgs>(args?: SelectSubset<T, GatewayFindFirstOrThrowArgs<ExtArgs>>): Prisma__GatewayClient<$Result.GetResult<Prisma.$GatewayPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Gateways that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GatewayFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Gateways
     * const gateways = await prisma.gateway.findMany()
     * 
     * // Get first 10 Gateways
     * const gateways = await prisma.gateway.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gatewayWithIdOnly = await prisma.gateway.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GatewayFindManyArgs>(args?: SelectSubset<T, GatewayFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GatewayPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Gateway.
     * @param {GatewayCreateArgs} args - Arguments to create a Gateway.
     * @example
     * // Create one Gateway
     * const Gateway = await prisma.gateway.create({
     *   data: {
     *     // ... data to create a Gateway
     *   }
     * })
     * 
     */
    create<T extends GatewayCreateArgs>(args: SelectSubset<T, GatewayCreateArgs<ExtArgs>>): Prisma__GatewayClient<$Result.GetResult<Prisma.$GatewayPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Gateways.
     * @param {GatewayCreateManyArgs} args - Arguments to create many Gateways.
     * @example
     * // Create many Gateways
     * const gateway = await prisma.gateway.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GatewayCreateManyArgs>(args?: SelectSubset<T, GatewayCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Gateways and returns the data saved in the database.
     * @param {GatewayCreateManyAndReturnArgs} args - Arguments to create many Gateways.
     * @example
     * // Create many Gateways
     * const gateway = await prisma.gateway.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Gateways and only return the `id`
     * const gatewayWithIdOnly = await prisma.gateway.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GatewayCreateManyAndReturnArgs>(args?: SelectSubset<T, GatewayCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GatewayPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Gateway.
     * @param {GatewayDeleteArgs} args - Arguments to delete one Gateway.
     * @example
     * // Delete one Gateway
     * const Gateway = await prisma.gateway.delete({
     *   where: {
     *     // ... filter to delete one Gateway
     *   }
     * })
     * 
     */
    delete<T extends GatewayDeleteArgs>(args: SelectSubset<T, GatewayDeleteArgs<ExtArgs>>): Prisma__GatewayClient<$Result.GetResult<Prisma.$GatewayPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Gateway.
     * @param {GatewayUpdateArgs} args - Arguments to update one Gateway.
     * @example
     * // Update one Gateway
     * const gateway = await prisma.gateway.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GatewayUpdateArgs>(args: SelectSubset<T, GatewayUpdateArgs<ExtArgs>>): Prisma__GatewayClient<$Result.GetResult<Prisma.$GatewayPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Gateways.
     * @param {GatewayDeleteManyArgs} args - Arguments to filter Gateways to delete.
     * @example
     * // Delete a few Gateways
     * const { count } = await prisma.gateway.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GatewayDeleteManyArgs>(args?: SelectSubset<T, GatewayDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gateways.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GatewayUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Gateways
     * const gateway = await prisma.gateway.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GatewayUpdateManyArgs>(args: SelectSubset<T, GatewayUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gateways and returns the data updated in the database.
     * @param {GatewayUpdateManyAndReturnArgs} args - Arguments to update many Gateways.
     * @example
     * // Update many Gateways
     * const gateway = await prisma.gateway.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Gateways and only return the `id`
     * const gatewayWithIdOnly = await prisma.gateway.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GatewayUpdateManyAndReturnArgs>(args: SelectSubset<T, GatewayUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GatewayPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Gateway.
     * @param {GatewayUpsertArgs} args - Arguments to update or create a Gateway.
     * @example
     * // Update or create a Gateway
     * const gateway = await prisma.gateway.upsert({
     *   create: {
     *     // ... data to create a Gateway
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Gateway we want to update
     *   }
     * })
     */
    upsert<T extends GatewayUpsertArgs>(args: SelectSubset<T, GatewayUpsertArgs<ExtArgs>>): Prisma__GatewayClient<$Result.GetResult<Prisma.$GatewayPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Gateways.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GatewayCountArgs} args - Arguments to filter Gateways to count.
     * @example
     * // Count the number of Gateways
     * const count = await prisma.gateway.count({
     *   where: {
     *     // ... the filter for the Gateways we want to count
     *   }
     * })
    **/
    count<T extends GatewayCountArgs>(
      args?: Subset<T, GatewayCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GatewayCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Gateway.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GatewayAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GatewayAggregateArgs>(args: Subset<T, GatewayAggregateArgs>): Prisma.PrismaPromise<GetGatewayAggregateType<T>>

    /**
     * Group by Gateway.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GatewayGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GatewayGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GatewayGroupByArgs['orderBy'] }
        : { orderBy?: GatewayGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GatewayGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGatewayGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Gateway model
   */
  readonly fields: GatewayFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Gateway.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GatewayClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    responsibleFor<T extends Gateway$responsibleForArgs<ExtArgs> = {}>(args?: Subset<T, Gateway$responsibleForArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Gateway model
   */
  interface GatewayFieldRefs {
    readonly id: FieldRef<"Gateway", 'Int'>
    readonly gatewayId: FieldRef<"Gateway", 'String'>
    readonly description: FieldRef<"Gateway", 'String'>
    readonly status: FieldRef<"Gateway", 'DeviceStatus'>
    readonly lastHeartbeat: FieldRef<"Gateway", 'DateTime'>
    readonly clientId: FieldRef<"Gateway", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Gateway findUnique
   */
  export type GatewayFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gateway
     */
    select?: GatewaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gateway
     */
    omit?: GatewayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GatewayInclude<ExtArgs> | null
    /**
     * Filter, which Gateway to fetch.
     */
    where: GatewayWhereUniqueInput
  }

  /**
   * Gateway findUniqueOrThrow
   */
  export type GatewayFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gateway
     */
    select?: GatewaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gateway
     */
    omit?: GatewayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GatewayInclude<ExtArgs> | null
    /**
     * Filter, which Gateway to fetch.
     */
    where: GatewayWhereUniqueInput
  }

  /**
   * Gateway findFirst
   */
  export type GatewayFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gateway
     */
    select?: GatewaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gateway
     */
    omit?: GatewayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GatewayInclude<ExtArgs> | null
    /**
     * Filter, which Gateway to fetch.
     */
    where?: GatewayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gateways to fetch.
     */
    orderBy?: GatewayOrderByWithRelationInput | GatewayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Gateways.
     */
    cursor?: GatewayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gateways from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gateways.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Gateways.
     */
    distinct?: GatewayScalarFieldEnum | GatewayScalarFieldEnum[]
  }

  /**
   * Gateway findFirstOrThrow
   */
  export type GatewayFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gateway
     */
    select?: GatewaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gateway
     */
    omit?: GatewayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GatewayInclude<ExtArgs> | null
    /**
     * Filter, which Gateway to fetch.
     */
    where?: GatewayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gateways to fetch.
     */
    orderBy?: GatewayOrderByWithRelationInput | GatewayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Gateways.
     */
    cursor?: GatewayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gateways from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gateways.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Gateways.
     */
    distinct?: GatewayScalarFieldEnum | GatewayScalarFieldEnum[]
  }

  /**
   * Gateway findMany
   */
  export type GatewayFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gateway
     */
    select?: GatewaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gateway
     */
    omit?: GatewayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GatewayInclude<ExtArgs> | null
    /**
     * Filter, which Gateways to fetch.
     */
    where?: GatewayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gateways to fetch.
     */
    orderBy?: GatewayOrderByWithRelationInput | GatewayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Gateways.
     */
    cursor?: GatewayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gateways from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gateways.
     */
    skip?: number
    distinct?: GatewayScalarFieldEnum | GatewayScalarFieldEnum[]
  }

  /**
   * Gateway create
   */
  export type GatewayCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gateway
     */
    select?: GatewaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gateway
     */
    omit?: GatewayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GatewayInclude<ExtArgs> | null
    /**
     * The data needed to create a Gateway.
     */
    data: XOR<GatewayCreateInput, GatewayUncheckedCreateInput>
  }

  /**
   * Gateway createMany
   */
  export type GatewayCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Gateways.
     */
    data: GatewayCreateManyInput | GatewayCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Gateway createManyAndReturn
   */
  export type GatewayCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gateway
     */
    select?: GatewaySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Gateway
     */
    omit?: GatewayOmit<ExtArgs> | null
    /**
     * The data used to create many Gateways.
     */
    data: GatewayCreateManyInput | GatewayCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GatewayIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Gateway update
   */
  export type GatewayUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gateway
     */
    select?: GatewaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gateway
     */
    omit?: GatewayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GatewayInclude<ExtArgs> | null
    /**
     * The data needed to update a Gateway.
     */
    data: XOR<GatewayUpdateInput, GatewayUncheckedUpdateInput>
    /**
     * Choose, which Gateway to update.
     */
    where: GatewayWhereUniqueInput
  }

  /**
   * Gateway updateMany
   */
  export type GatewayUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Gateways.
     */
    data: XOR<GatewayUpdateManyMutationInput, GatewayUncheckedUpdateManyInput>
    /**
     * Filter which Gateways to update
     */
    where?: GatewayWhereInput
    /**
     * Limit how many Gateways to update.
     */
    limit?: number
  }

  /**
   * Gateway updateManyAndReturn
   */
  export type GatewayUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gateway
     */
    select?: GatewaySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Gateway
     */
    omit?: GatewayOmit<ExtArgs> | null
    /**
     * The data used to update Gateways.
     */
    data: XOR<GatewayUpdateManyMutationInput, GatewayUncheckedUpdateManyInput>
    /**
     * Filter which Gateways to update
     */
    where?: GatewayWhereInput
    /**
     * Limit how many Gateways to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GatewayIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Gateway upsert
   */
  export type GatewayUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gateway
     */
    select?: GatewaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gateway
     */
    omit?: GatewayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GatewayInclude<ExtArgs> | null
    /**
     * The filter to search for the Gateway to update in case it exists.
     */
    where: GatewayWhereUniqueInput
    /**
     * In case the Gateway found by the `where` argument doesn't exist, create a new Gateway with this data.
     */
    create: XOR<GatewayCreateInput, GatewayUncheckedCreateInput>
    /**
     * In case the Gateway was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GatewayUpdateInput, GatewayUncheckedUpdateInput>
  }

  /**
   * Gateway delete
   */
  export type GatewayDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gateway
     */
    select?: GatewaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gateway
     */
    omit?: GatewayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GatewayInclude<ExtArgs> | null
    /**
     * Filter which Gateway to delete.
     */
    where: GatewayWhereUniqueInput
  }

  /**
   * Gateway deleteMany
   */
  export type GatewayDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Gateways to delete
     */
    where?: GatewayWhereInput
    /**
     * Limit how many Gateways to delete.
     */
    limit?: number
  }

  /**
   * Gateway.responsibleFor
   */
  export type Gateway$responsibleForArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    where?: DeviceWhereInput
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[]
    cursor?: DeviceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeviceScalarFieldEnum | DeviceScalarFieldEnum[]
  }

  /**
   * Gateway without action
   */
  export type GatewayDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gateway
     */
    select?: GatewaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Gateway
     */
    omit?: GatewayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GatewayInclude<ExtArgs> | null
  }


  /**
   * Model RpmReading
   */

  export type AggregateRpmReading = {
    _count: RpmReadingCountAggregateOutputType | null
    _avg: RpmReadingAvgAggregateOutputType | null
    _sum: RpmReadingSumAggregateOutputType | null
    _min: RpmReadingMinAggregateOutputType | null
    _max: RpmReadingMaxAggregateOutputType | null
  }

  export type RpmReadingAvgAggregateOutputType = {
    id: number | null
    rpm: number | null
    machineId: number | null
    userId: number | null
  }

  export type RpmReadingSumAggregateOutputType = {
    id: number | null
    rpm: number | null
    machineId: number | null
    userId: number | null
  }

  export type RpmReadingMinAggregateOutputType = {
    id: number | null
    timestamp: Date | null
    rpm: number | null
    machineId: number | null
    userId: number | null
  }

  export type RpmReadingMaxAggregateOutputType = {
    id: number | null
    timestamp: Date | null
    rpm: number | null
    machineId: number | null
    userId: number | null
  }

  export type RpmReadingCountAggregateOutputType = {
    id: number
    timestamp: number
    rpm: number
    machineId: number
    userId: number
    _all: number
  }


  export type RpmReadingAvgAggregateInputType = {
    id?: true
    rpm?: true
    machineId?: true
    userId?: true
  }

  export type RpmReadingSumAggregateInputType = {
    id?: true
    rpm?: true
    machineId?: true
    userId?: true
  }

  export type RpmReadingMinAggregateInputType = {
    id?: true
    timestamp?: true
    rpm?: true
    machineId?: true
    userId?: true
  }

  export type RpmReadingMaxAggregateInputType = {
    id?: true
    timestamp?: true
    rpm?: true
    machineId?: true
    userId?: true
  }

  export type RpmReadingCountAggregateInputType = {
    id?: true
    timestamp?: true
    rpm?: true
    machineId?: true
    userId?: true
    _all?: true
  }

  export type RpmReadingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RpmReading to aggregate.
     */
    where?: RpmReadingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RpmReadings to fetch.
     */
    orderBy?: RpmReadingOrderByWithRelationInput | RpmReadingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RpmReadingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RpmReadings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RpmReadings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RpmReadings
    **/
    _count?: true | RpmReadingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RpmReadingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RpmReadingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RpmReadingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RpmReadingMaxAggregateInputType
  }

  export type GetRpmReadingAggregateType<T extends RpmReadingAggregateArgs> = {
        [P in keyof T & keyof AggregateRpmReading]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRpmReading[P]>
      : GetScalarType<T[P], AggregateRpmReading[P]>
  }




  export type RpmReadingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RpmReadingWhereInput
    orderBy?: RpmReadingOrderByWithAggregationInput | RpmReadingOrderByWithAggregationInput[]
    by: RpmReadingScalarFieldEnum[] | RpmReadingScalarFieldEnum
    having?: RpmReadingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RpmReadingCountAggregateInputType | true
    _avg?: RpmReadingAvgAggregateInputType
    _sum?: RpmReadingSumAggregateInputType
    _min?: RpmReadingMinAggregateInputType
    _max?: RpmReadingMaxAggregateInputType
  }

  export type RpmReadingGroupByOutputType = {
    id: number
    timestamp: Date
    rpm: number
    machineId: number
    userId: number | null
    _count: RpmReadingCountAggregateOutputType | null
    _avg: RpmReadingAvgAggregateOutputType | null
    _sum: RpmReadingSumAggregateOutputType | null
    _min: RpmReadingMinAggregateOutputType | null
    _max: RpmReadingMaxAggregateOutputType | null
  }

  type GetRpmReadingGroupByPayload<T extends RpmReadingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RpmReadingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RpmReadingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RpmReadingGroupByOutputType[P]>
            : GetScalarType<T[P], RpmReadingGroupByOutputType[P]>
        }
      >
    >


  export type RpmReadingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    rpm?: boolean
    machineId?: boolean
    userId?: boolean
    machine?: boolean | MachineDefaultArgs<ExtArgs>
    user?: boolean | RpmReading$userArgs<ExtArgs>
  }, ExtArgs["result"]["rpmReading"]>

  export type RpmReadingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    rpm?: boolean
    machineId?: boolean
    userId?: boolean
    machine?: boolean | MachineDefaultArgs<ExtArgs>
    user?: boolean | RpmReading$userArgs<ExtArgs>
  }, ExtArgs["result"]["rpmReading"]>

  export type RpmReadingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    rpm?: boolean
    machineId?: boolean
    userId?: boolean
    machine?: boolean | MachineDefaultArgs<ExtArgs>
    user?: boolean | RpmReading$userArgs<ExtArgs>
  }, ExtArgs["result"]["rpmReading"]>

  export type RpmReadingSelectScalar = {
    id?: boolean
    timestamp?: boolean
    rpm?: boolean
    machineId?: boolean
    userId?: boolean
  }

  export type RpmReadingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "timestamp" | "rpm" | "machineId" | "userId", ExtArgs["result"]["rpmReading"]>
  export type RpmReadingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    machine?: boolean | MachineDefaultArgs<ExtArgs>
    user?: boolean | RpmReading$userArgs<ExtArgs>
  }
  export type RpmReadingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    machine?: boolean | MachineDefaultArgs<ExtArgs>
    user?: boolean | RpmReading$userArgs<ExtArgs>
  }
  export type RpmReadingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    machine?: boolean | MachineDefaultArgs<ExtArgs>
    user?: boolean | RpmReading$userArgs<ExtArgs>
  }

  export type $RpmReadingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RpmReading"
    objects: {
      machine: Prisma.$MachinePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      timestamp: Date
      rpm: number
      machineId: number
      userId: number | null
    }, ExtArgs["result"]["rpmReading"]>
    composites: {}
  }

  type RpmReadingGetPayload<S extends boolean | null | undefined | RpmReadingDefaultArgs> = $Result.GetResult<Prisma.$RpmReadingPayload, S>

  type RpmReadingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RpmReadingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RpmReadingCountAggregateInputType | true
    }

  export interface RpmReadingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RpmReading'], meta: { name: 'RpmReading' } }
    /**
     * Find zero or one RpmReading that matches the filter.
     * @param {RpmReadingFindUniqueArgs} args - Arguments to find a RpmReading
     * @example
     * // Get one RpmReading
     * const rpmReading = await prisma.rpmReading.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RpmReadingFindUniqueArgs>(args: SelectSubset<T, RpmReadingFindUniqueArgs<ExtArgs>>): Prisma__RpmReadingClient<$Result.GetResult<Prisma.$RpmReadingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RpmReading that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RpmReadingFindUniqueOrThrowArgs} args - Arguments to find a RpmReading
     * @example
     * // Get one RpmReading
     * const rpmReading = await prisma.rpmReading.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RpmReadingFindUniqueOrThrowArgs>(args: SelectSubset<T, RpmReadingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RpmReadingClient<$Result.GetResult<Prisma.$RpmReadingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RpmReading that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RpmReadingFindFirstArgs} args - Arguments to find a RpmReading
     * @example
     * // Get one RpmReading
     * const rpmReading = await prisma.rpmReading.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RpmReadingFindFirstArgs>(args?: SelectSubset<T, RpmReadingFindFirstArgs<ExtArgs>>): Prisma__RpmReadingClient<$Result.GetResult<Prisma.$RpmReadingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RpmReading that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RpmReadingFindFirstOrThrowArgs} args - Arguments to find a RpmReading
     * @example
     * // Get one RpmReading
     * const rpmReading = await prisma.rpmReading.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RpmReadingFindFirstOrThrowArgs>(args?: SelectSubset<T, RpmReadingFindFirstOrThrowArgs<ExtArgs>>): Prisma__RpmReadingClient<$Result.GetResult<Prisma.$RpmReadingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RpmReadings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RpmReadingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RpmReadings
     * const rpmReadings = await prisma.rpmReading.findMany()
     * 
     * // Get first 10 RpmReadings
     * const rpmReadings = await prisma.rpmReading.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rpmReadingWithIdOnly = await prisma.rpmReading.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RpmReadingFindManyArgs>(args?: SelectSubset<T, RpmReadingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RpmReadingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RpmReading.
     * @param {RpmReadingCreateArgs} args - Arguments to create a RpmReading.
     * @example
     * // Create one RpmReading
     * const RpmReading = await prisma.rpmReading.create({
     *   data: {
     *     // ... data to create a RpmReading
     *   }
     * })
     * 
     */
    create<T extends RpmReadingCreateArgs>(args: SelectSubset<T, RpmReadingCreateArgs<ExtArgs>>): Prisma__RpmReadingClient<$Result.GetResult<Prisma.$RpmReadingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RpmReadings.
     * @param {RpmReadingCreateManyArgs} args - Arguments to create many RpmReadings.
     * @example
     * // Create many RpmReadings
     * const rpmReading = await prisma.rpmReading.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RpmReadingCreateManyArgs>(args?: SelectSubset<T, RpmReadingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RpmReadings and returns the data saved in the database.
     * @param {RpmReadingCreateManyAndReturnArgs} args - Arguments to create many RpmReadings.
     * @example
     * // Create many RpmReadings
     * const rpmReading = await prisma.rpmReading.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RpmReadings and only return the `id`
     * const rpmReadingWithIdOnly = await prisma.rpmReading.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RpmReadingCreateManyAndReturnArgs>(args?: SelectSubset<T, RpmReadingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RpmReadingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RpmReading.
     * @param {RpmReadingDeleteArgs} args - Arguments to delete one RpmReading.
     * @example
     * // Delete one RpmReading
     * const RpmReading = await prisma.rpmReading.delete({
     *   where: {
     *     // ... filter to delete one RpmReading
     *   }
     * })
     * 
     */
    delete<T extends RpmReadingDeleteArgs>(args: SelectSubset<T, RpmReadingDeleteArgs<ExtArgs>>): Prisma__RpmReadingClient<$Result.GetResult<Prisma.$RpmReadingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RpmReading.
     * @param {RpmReadingUpdateArgs} args - Arguments to update one RpmReading.
     * @example
     * // Update one RpmReading
     * const rpmReading = await prisma.rpmReading.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RpmReadingUpdateArgs>(args: SelectSubset<T, RpmReadingUpdateArgs<ExtArgs>>): Prisma__RpmReadingClient<$Result.GetResult<Prisma.$RpmReadingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RpmReadings.
     * @param {RpmReadingDeleteManyArgs} args - Arguments to filter RpmReadings to delete.
     * @example
     * // Delete a few RpmReadings
     * const { count } = await prisma.rpmReading.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RpmReadingDeleteManyArgs>(args?: SelectSubset<T, RpmReadingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RpmReadings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RpmReadingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RpmReadings
     * const rpmReading = await prisma.rpmReading.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RpmReadingUpdateManyArgs>(args: SelectSubset<T, RpmReadingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RpmReadings and returns the data updated in the database.
     * @param {RpmReadingUpdateManyAndReturnArgs} args - Arguments to update many RpmReadings.
     * @example
     * // Update many RpmReadings
     * const rpmReading = await prisma.rpmReading.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RpmReadings and only return the `id`
     * const rpmReadingWithIdOnly = await prisma.rpmReading.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RpmReadingUpdateManyAndReturnArgs>(args: SelectSubset<T, RpmReadingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RpmReadingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RpmReading.
     * @param {RpmReadingUpsertArgs} args - Arguments to update or create a RpmReading.
     * @example
     * // Update or create a RpmReading
     * const rpmReading = await prisma.rpmReading.upsert({
     *   create: {
     *     // ... data to create a RpmReading
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RpmReading we want to update
     *   }
     * })
     */
    upsert<T extends RpmReadingUpsertArgs>(args: SelectSubset<T, RpmReadingUpsertArgs<ExtArgs>>): Prisma__RpmReadingClient<$Result.GetResult<Prisma.$RpmReadingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RpmReadings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RpmReadingCountArgs} args - Arguments to filter RpmReadings to count.
     * @example
     * // Count the number of RpmReadings
     * const count = await prisma.rpmReading.count({
     *   where: {
     *     // ... the filter for the RpmReadings we want to count
     *   }
     * })
    **/
    count<T extends RpmReadingCountArgs>(
      args?: Subset<T, RpmReadingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RpmReadingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RpmReading.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RpmReadingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RpmReadingAggregateArgs>(args: Subset<T, RpmReadingAggregateArgs>): Prisma.PrismaPromise<GetRpmReadingAggregateType<T>>

    /**
     * Group by RpmReading.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RpmReadingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RpmReadingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RpmReadingGroupByArgs['orderBy'] }
        : { orderBy?: RpmReadingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RpmReadingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRpmReadingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RpmReading model
   */
  readonly fields: RpmReadingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RpmReading.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RpmReadingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    machine<T extends MachineDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MachineDefaultArgs<ExtArgs>>): Prisma__MachineClient<$Result.GetResult<Prisma.$MachinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends RpmReading$userArgs<ExtArgs> = {}>(args?: Subset<T, RpmReading$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RpmReading model
   */
  interface RpmReadingFieldRefs {
    readonly id: FieldRef<"RpmReading", 'Int'>
    readonly timestamp: FieldRef<"RpmReading", 'DateTime'>
    readonly rpm: FieldRef<"RpmReading", 'Int'>
    readonly machineId: FieldRef<"RpmReading", 'Int'>
    readonly userId: FieldRef<"RpmReading", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * RpmReading findUnique
   */
  export type RpmReadingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RpmReading
     */
    select?: RpmReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RpmReading
     */
    omit?: RpmReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RpmReadingInclude<ExtArgs> | null
    /**
     * Filter, which RpmReading to fetch.
     */
    where: RpmReadingWhereUniqueInput
  }

  /**
   * RpmReading findUniqueOrThrow
   */
  export type RpmReadingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RpmReading
     */
    select?: RpmReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RpmReading
     */
    omit?: RpmReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RpmReadingInclude<ExtArgs> | null
    /**
     * Filter, which RpmReading to fetch.
     */
    where: RpmReadingWhereUniqueInput
  }

  /**
   * RpmReading findFirst
   */
  export type RpmReadingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RpmReading
     */
    select?: RpmReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RpmReading
     */
    omit?: RpmReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RpmReadingInclude<ExtArgs> | null
    /**
     * Filter, which RpmReading to fetch.
     */
    where?: RpmReadingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RpmReadings to fetch.
     */
    orderBy?: RpmReadingOrderByWithRelationInput | RpmReadingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RpmReadings.
     */
    cursor?: RpmReadingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RpmReadings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RpmReadings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RpmReadings.
     */
    distinct?: RpmReadingScalarFieldEnum | RpmReadingScalarFieldEnum[]
  }

  /**
   * RpmReading findFirstOrThrow
   */
  export type RpmReadingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RpmReading
     */
    select?: RpmReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RpmReading
     */
    omit?: RpmReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RpmReadingInclude<ExtArgs> | null
    /**
     * Filter, which RpmReading to fetch.
     */
    where?: RpmReadingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RpmReadings to fetch.
     */
    orderBy?: RpmReadingOrderByWithRelationInput | RpmReadingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RpmReadings.
     */
    cursor?: RpmReadingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RpmReadings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RpmReadings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RpmReadings.
     */
    distinct?: RpmReadingScalarFieldEnum | RpmReadingScalarFieldEnum[]
  }

  /**
   * RpmReading findMany
   */
  export type RpmReadingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RpmReading
     */
    select?: RpmReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RpmReading
     */
    omit?: RpmReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RpmReadingInclude<ExtArgs> | null
    /**
     * Filter, which RpmReadings to fetch.
     */
    where?: RpmReadingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RpmReadings to fetch.
     */
    orderBy?: RpmReadingOrderByWithRelationInput | RpmReadingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RpmReadings.
     */
    cursor?: RpmReadingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RpmReadings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RpmReadings.
     */
    skip?: number
    distinct?: RpmReadingScalarFieldEnum | RpmReadingScalarFieldEnum[]
  }

  /**
   * RpmReading create
   */
  export type RpmReadingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RpmReading
     */
    select?: RpmReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RpmReading
     */
    omit?: RpmReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RpmReadingInclude<ExtArgs> | null
    /**
     * The data needed to create a RpmReading.
     */
    data: XOR<RpmReadingCreateInput, RpmReadingUncheckedCreateInput>
  }

  /**
   * RpmReading createMany
   */
  export type RpmReadingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RpmReadings.
     */
    data: RpmReadingCreateManyInput | RpmReadingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RpmReading createManyAndReturn
   */
  export type RpmReadingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RpmReading
     */
    select?: RpmReadingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RpmReading
     */
    omit?: RpmReadingOmit<ExtArgs> | null
    /**
     * The data used to create many RpmReadings.
     */
    data: RpmReadingCreateManyInput | RpmReadingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RpmReadingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RpmReading update
   */
  export type RpmReadingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RpmReading
     */
    select?: RpmReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RpmReading
     */
    omit?: RpmReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RpmReadingInclude<ExtArgs> | null
    /**
     * The data needed to update a RpmReading.
     */
    data: XOR<RpmReadingUpdateInput, RpmReadingUncheckedUpdateInput>
    /**
     * Choose, which RpmReading to update.
     */
    where: RpmReadingWhereUniqueInput
  }

  /**
   * RpmReading updateMany
   */
  export type RpmReadingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RpmReadings.
     */
    data: XOR<RpmReadingUpdateManyMutationInput, RpmReadingUncheckedUpdateManyInput>
    /**
     * Filter which RpmReadings to update
     */
    where?: RpmReadingWhereInput
    /**
     * Limit how many RpmReadings to update.
     */
    limit?: number
  }

  /**
   * RpmReading updateManyAndReturn
   */
  export type RpmReadingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RpmReading
     */
    select?: RpmReadingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RpmReading
     */
    omit?: RpmReadingOmit<ExtArgs> | null
    /**
     * The data used to update RpmReadings.
     */
    data: XOR<RpmReadingUpdateManyMutationInput, RpmReadingUncheckedUpdateManyInput>
    /**
     * Filter which RpmReadings to update
     */
    where?: RpmReadingWhereInput
    /**
     * Limit how many RpmReadings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RpmReadingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RpmReading upsert
   */
  export type RpmReadingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RpmReading
     */
    select?: RpmReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RpmReading
     */
    omit?: RpmReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RpmReadingInclude<ExtArgs> | null
    /**
     * The filter to search for the RpmReading to update in case it exists.
     */
    where: RpmReadingWhereUniqueInput
    /**
     * In case the RpmReading found by the `where` argument doesn't exist, create a new RpmReading with this data.
     */
    create: XOR<RpmReadingCreateInput, RpmReadingUncheckedCreateInput>
    /**
     * In case the RpmReading was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RpmReadingUpdateInput, RpmReadingUncheckedUpdateInput>
  }

  /**
   * RpmReading delete
   */
  export type RpmReadingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RpmReading
     */
    select?: RpmReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RpmReading
     */
    omit?: RpmReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RpmReadingInclude<ExtArgs> | null
    /**
     * Filter which RpmReading to delete.
     */
    where: RpmReadingWhereUniqueInput
  }

  /**
   * RpmReading deleteMany
   */
  export type RpmReadingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RpmReadings to delete
     */
    where?: RpmReadingWhereInput
    /**
     * Limit how many RpmReadings to delete.
     */
    limit?: number
  }

  /**
   * RpmReading.user
   */
  export type RpmReading$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * RpmReading without action
   */
  export type RpmReadingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RpmReading
     */
    select?: RpmReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RpmReading
     */
    omit?: RpmReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RpmReadingInclude<ExtArgs> | null
  }


  /**
   * Model OilTemperatureReading
   */

  export type AggregateOilTemperatureReading = {
    _count: OilTemperatureReadingCountAggregateOutputType | null
    _avg: OilTemperatureReadingAvgAggregateOutputType | null
    _sum: OilTemperatureReadingSumAggregateOutputType | null
    _min: OilTemperatureReadingMinAggregateOutputType | null
    _max: OilTemperatureReadingMaxAggregateOutputType | null
  }

  export type OilTemperatureReadingAvgAggregateOutputType = {
    id: number | null
    temperature: number | null
    machineId: number | null
    userId: number | null
  }

  export type OilTemperatureReadingSumAggregateOutputType = {
    id: number | null
    temperature: number | null
    machineId: number | null
    userId: number | null
  }

  export type OilTemperatureReadingMinAggregateOutputType = {
    id: number | null
    timestamp: Date | null
    temperature: number | null
    machineId: number | null
    userId: number | null
  }

  export type OilTemperatureReadingMaxAggregateOutputType = {
    id: number | null
    timestamp: Date | null
    temperature: number | null
    machineId: number | null
    userId: number | null
  }

  export type OilTemperatureReadingCountAggregateOutputType = {
    id: number
    timestamp: number
    temperature: number
    machineId: number
    userId: number
    _all: number
  }


  export type OilTemperatureReadingAvgAggregateInputType = {
    id?: true
    temperature?: true
    machineId?: true
    userId?: true
  }

  export type OilTemperatureReadingSumAggregateInputType = {
    id?: true
    temperature?: true
    machineId?: true
    userId?: true
  }

  export type OilTemperatureReadingMinAggregateInputType = {
    id?: true
    timestamp?: true
    temperature?: true
    machineId?: true
    userId?: true
  }

  export type OilTemperatureReadingMaxAggregateInputType = {
    id?: true
    timestamp?: true
    temperature?: true
    machineId?: true
    userId?: true
  }

  export type OilTemperatureReadingCountAggregateInputType = {
    id?: true
    timestamp?: true
    temperature?: true
    machineId?: true
    userId?: true
    _all?: true
  }

  export type OilTemperatureReadingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OilTemperatureReading to aggregate.
     */
    where?: OilTemperatureReadingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OilTemperatureReadings to fetch.
     */
    orderBy?: OilTemperatureReadingOrderByWithRelationInput | OilTemperatureReadingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OilTemperatureReadingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OilTemperatureReadings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OilTemperatureReadings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OilTemperatureReadings
    **/
    _count?: true | OilTemperatureReadingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OilTemperatureReadingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OilTemperatureReadingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OilTemperatureReadingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OilTemperatureReadingMaxAggregateInputType
  }

  export type GetOilTemperatureReadingAggregateType<T extends OilTemperatureReadingAggregateArgs> = {
        [P in keyof T & keyof AggregateOilTemperatureReading]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOilTemperatureReading[P]>
      : GetScalarType<T[P], AggregateOilTemperatureReading[P]>
  }




  export type OilTemperatureReadingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OilTemperatureReadingWhereInput
    orderBy?: OilTemperatureReadingOrderByWithAggregationInput | OilTemperatureReadingOrderByWithAggregationInput[]
    by: OilTemperatureReadingScalarFieldEnum[] | OilTemperatureReadingScalarFieldEnum
    having?: OilTemperatureReadingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OilTemperatureReadingCountAggregateInputType | true
    _avg?: OilTemperatureReadingAvgAggregateInputType
    _sum?: OilTemperatureReadingSumAggregateInputType
    _min?: OilTemperatureReadingMinAggregateInputType
    _max?: OilTemperatureReadingMaxAggregateInputType
  }

  export type OilTemperatureReadingGroupByOutputType = {
    id: number
    timestamp: Date
    temperature: number
    machineId: number
    userId: number | null
    _count: OilTemperatureReadingCountAggregateOutputType | null
    _avg: OilTemperatureReadingAvgAggregateOutputType | null
    _sum: OilTemperatureReadingSumAggregateOutputType | null
    _min: OilTemperatureReadingMinAggregateOutputType | null
    _max: OilTemperatureReadingMaxAggregateOutputType | null
  }

  type GetOilTemperatureReadingGroupByPayload<T extends OilTemperatureReadingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OilTemperatureReadingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OilTemperatureReadingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OilTemperatureReadingGroupByOutputType[P]>
            : GetScalarType<T[P], OilTemperatureReadingGroupByOutputType[P]>
        }
      >
    >


  export type OilTemperatureReadingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    temperature?: boolean
    machineId?: boolean
    userId?: boolean
    machine?: boolean | MachineDefaultArgs<ExtArgs>
    user?: boolean | OilTemperatureReading$userArgs<ExtArgs>
  }, ExtArgs["result"]["oilTemperatureReading"]>

  export type OilTemperatureReadingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    temperature?: boolean
    machineId?: boolean
    userId?: boolean
    machine?: boolean | MachineDefaultArgs<ExtArgs>
    user?: boolean | OilTemperatureReading$userArgs<ExtArgs>
  }, ExtArgs["result"]["oilTemperatureReading"]>

  export type OilTemperatureReadingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    temperature?: boolean
    machineId?: boolean
    userId?: boolean
    machine?: boolean | MachineDefaultArgs<ExtArgs>
    user?: boolean | OilTemperatureReading$userArgs<ExtArgs>
  }, ExtArgs["result"]["oilTemperatureReading"]>

  export type OilTemperatureReadingSelectScalar = {
    id?: boolean
    timestamp?: boolean
    temperature?: boolean
    machineId?: boolean
    userId?: boolean
  }

  export type OilTemperatureReadingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "timestamp" | "temperature" | "machineId" | "userId", ExtArgs["result"]["oilTemperatureReading"]>
  export type OilTemperatureReadingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    machine?: boolean | MachineDefaultArgs<ExtArgs>
    user?: boolean | OilTemperatureReading$userArgs<ExtArgs>
  }
  export type OilTemperatureReadingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    machine?: boolean | MachineDefaultArgs<ExtArgs>
    user?: boolean | OilTemperatureReading$userArgs<ExtArgs>
  }
  export type OilTemperatureReadingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    machine?: boolean | MachineDefaultArgs<ExtArgs>
    user?: boolean | OilTemperatureReading$userArgs<ExtArgs>
  }

  export type $OilTemperatureReadingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OilTemperatureReading"
    objects: {
      machine: Prisma.$MachinePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      timestamp: Date
      temperature: number
      machineId: number
      userId: number | null
    }, ExtArgs["result"]["oilTemperatureReading"]>
    composites: {}
  }

  type OilTemperatureReadingGetPayload<S extends boolean | null | undefined | OilTemperatureReadingDefaultArgs> = $Result.GetResult<Prisma.$OilTemperatureReadingPayload, S>

  type OilTemperatureReadingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OilTemperatureReadingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OilTemperatureReadingCountAggregateInputType | true
    }

  export interface OilTemperatureReadingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OilTemperatureReading'], meta: { name: 'OilTemperatureReading' } }
    /**
     * Find zero or one OilTemperatureReading that matches the filter.
     * @param {OilTemperatureReadingFindUniqueArgs} args - Arguments to find a OilTemperatureReading
     * @example
     * // Get one OilTemperatureReading
     * const oilTemperatureReading = await prisma.oilTemperatureReading.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OilTemperatureReadingFindUniqueArgs>(args: SelectSubset<T, OilTemperatureReadingFindUniqueArgs<ExtArgs>>): Prisma__OilTemperatureReadingClient<$Result.GetResult<Prisma.$OilTemperatureReadingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OilTemperatureReading that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OilTemperatureReadingFindUniqueOrThrowArgs} args - Arguments to find a OilTemperatureReading
     * @example
     * // Get one OilTemperatureReading
     * const oilTemperatureReading = await prisma.oilTemperatureReading.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OilTemperatureReadingFindUniqueOrThrowArgs>(args: SelectSubset<T, OilTemperatureReadingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OilTemperatureReadingClient<$Result.GetResult<Prisma.$OilTemperatureReadingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OilTemperatureReading that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OilTemperatureReadingFindFirstArgs} args - Arguments to find a OilTemperatureReading
     * @example
     * // Get one OilTemperatureReading
     * const oilTemperatureReading = await prisma.oilTemperatureReading.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OilTemperatureReadingFindFirstArgs>(args?: SelectSubset<T, OilTemperatureReadingFindFirstArgs<ExtArgs>>): Prisma__OilTemperatureReadingClient<$Result.GetResult<Prisma.$OilTemperatureReadingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OilTemperatureReading that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OilTemperatureReadingFindFirstOrThrowArgs} args - Arguments to find a OilTemperatureReading
     * @example
     * // Get one OilTemperatureReading
     * const oilTemperatureReading = await prisma.oilTemperatureReading.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OilTemperatureReadingFindFirstOrThrowArgs>(args?: SelectSubset<T, OilTemperatureReadingFindFirstOrThrowArgs<ExtArgs>>): Prisma__OilTemperatureReadingClient<$Result.GetResult<Prisma.$OilTemperatureReadingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OilTemperatureReadings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OilTemperatureReadingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OilTemperatureReadings
     * const oilTemperatureReadings = await prisma.oilTemperatureReading.findMany()
     * 
     * // Get first 10 OilTemperatureReadings
     * const oilTemperatureReadings = await prisma.oilTemperatureReading.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const oilTemperatureReadingWithIdOnly = await prisma.oilTemperatureReading.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OilTemperatureReadingFindManyArgs>(args?: SelectSubset<T, OilTemperatureReadingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OilTemperatureReadingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OilTemperatureReading.
     * @param {OilTemperatureReadingCreateArgs} args - Arguments to create a OilTemperatureReading.
     * @example
     * // Create one OilTemperatureReading
     * const OilTemperatureReading = await prisma.oilTemperatureReading.create({
     *   data: {
     *     // ... data to create a OilTemperatureReading
     *   }
     * })
     * 
     */
    create<T extends OilTemperatureReadingCreateArgs>(args: SelectSubset<T, OilTemperatureReadingCreateArgs<ExtArgs>>): Prisma__OilTemperatureReadingClient<$Result.GetResult<Prisma.$OilTemperatureReadingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OilTemperatureReadings.
     * @param {OilTemperatureReadingCreateManyArgs} args - Arguments to create many OilTemperatureReadings.
     * @example
     * // Create many OilTemperatureReadings
     * const oilTemperatureReading = await prisma.oilTemperatureReading.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OilTemperatureReadingCreateManyArgs>(args?: SelectSubset<T, OilTemperatureReadingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OilTemperatureReadings and returns the data saved in the database.
     * @param {OilTemperatureReadingCreateManyAndReturnArgs} args - Arguments to create many OilTemperatureReadings.
     * @example
     * // Create many OilTemperatureReadings
     * const oilTemperatureReading = await prisma.oilTemperatureReading.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OilTemperatureReadings and only return the `id`
     * const oilTemperatureReadingWithIdOnly = await prisma.oilTemperatureReading.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OilTemperatureReadingCreateManyAndReturnArgs>(args?: SelectSubset<T, OilTemperatureReadingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OilTemperatureReadingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OilTemperatureReading.
     * @param {OilTemperatureReadingDeleteArgs} args - Arguments to delete one OilTemperatureReading.
     * @example
     * // Delete one OilTemperatureReading
     * const OilTemperatureReading = await prisma.oilTemperatureReading.delete({
     *   where: {
     *     // ... filter to delete one OilTemperatureReading
     *   }
     * })
     * 
     */
    delete<T extends OilTemperatureReadingDeleteArgs>(args: SelectSubset<T, OilTemperatureReadingDeleteArgs<ExtArgs>>): Prisma__OilTemperatureReadingClient<$Result.GetResult<Prisma.$OilTemperatureReadingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OilTemperatureReading.
     * @param {OilTemperatureReadingUpdateArgs} args - Arguments to update one OilTemperatureReading.
     * @example
     * // Update one OilTemperatureReading
     * const oilTemperatureReading = await prisma.oilTemperatureReading.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OilTemperatureReadingUpdateArgs>(args: SelectSubset<T, OilTemperatureReadingUpdateArgs<ExtArgs>>): Prisma__OilTemperatureReadingClient<$Result.GetResult<Prisma.$OilTemperatureReadingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OilTemperatureReadings.
     * @param {OilTemperatureReadingDeleteManyArgs} args - Arguments to filter OilTemperatureReadings to delete.
     * @example
     * // Delete a few OilTemperatureReadings
     * const { count } = await prisma.oilTemperatureReading.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OilTemperatureReadingDeleteManyArgs>(args?: SelectSubset<T, OilTemperatureReadingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OilTemperatureReadings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OilTemperatureReadingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OilTemperatureReadings
     * const oilTemperatureReading = await prisma.oilTemperatureReading.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OilTemperatureReadingUpdateManyArgs>(args: SelectSubset<T, OilTemperatureReadingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OilTemperatureReadings and returns the data updated in the database.
     * @param {OilTemperatureReadingUpdateManyAndReturnArgs} args - Arguments to update many OilTemperatureReadings.
     * @example
     * // Update many OilTemperatureReadings
     * const oilTemperatureReading = await prisma.oilTemperatureReading.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OilTemperatureReadings and only return the `id`
     * const oilTemperatureReadingWithIdOnly = await prisma.oilTemperatureReading.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OilTemperatureReadingUpdateManyAndReturnArgs>(args: SelectSubset<T, OilTemperatureReadingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OilTemperatureReadingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OilTemperatureReading.
     * @param {OilTemperatureReadingUpsertArgs} args - Arguments to update or create a OilTemperatureReading.
     * @example
     * // Update or create a OilTemperatureReading
     * const oilTemperatureReading = await prisma.oilTemperatureReading.upsert({
     *   create: {
     *     // ... data to create a OilTemperatureReading
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OilTemperatureReading we want to update
     *   }
     * })
     */
    upsert<T extends OilTemperatureReadingUpsertArgs>(args: SelectSubset<T, OilTemperatureReadingUpsertArgs<ExtArgs>>): Prisma__OilTemperatureReadingClient<$Result.GetResult<Prisma.$OilTemperatureReadingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OilTemperatureReadings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OilTemperatureReadingCountArgs} args - Arguments to filter OilTemperatureReadings to count.
     * @example
     * // Count the number of OilTemperatureReadings
     * const count = await prisma.oilTemperatureReading.count({
     *   where: {
     *     // ... the filter for the OilTemperatureReadings we want to count
     *   }
     * })
    **/
    count<T extends OilTemperatureReadingCountArgs>(
      args?: Subset<T, OilTemperatureReadingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OilTemperatureReadingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OilTemperatureReading.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OilTemperatureReadingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OilTemperatureReadingAggregateArgs>(args: Subset<T, OilTemperatureReadingAggregateArgs>): Prisma.PrismaPromise<GetOilTemperatureReadingAggregateType<T>>

    /**
     * Group by OilTemperatureReading.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OilTemperatureReadingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OilTemperatureReadingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OilTemperatureReadingGroupByArgs['orderBy'] }
        : { orderBy?: OilTemperatureReadingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OilTemperatureReadingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOilTemperatureReadingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OilTemperatureReading model
   */
  readonly fields: OilTemperatureReadingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OilTemperatureReading.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OilTemperatureReadingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    machine<T extends MachineDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MachineDefaultArgs<ExtArgs>>): Prisma__MachineClient<$Result.GetResult<Prisma.$MachinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends OilTemperatureReading$userArgs<ExtArgs> = {}>(args?: Subset<T, OilTemperatureReading$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OilTemperatureReading model
   */
  interface OilTemperatureReadingFieldRefs {
    readonly id: FieldRef<"OilTemperatureReading", 'Int'>
    readonly timestamp: FieldRef<"OilTemperatureReading", 'DateTime'>
    readonly temperature: FieldRef<"OilTemperatureReading", 'Float'>
    readonly machineId: FieldRef<"OilTemperatureReading", 'Int'>
    readonly userId: FieldRef<"OilTemperatureReading", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * OilTemperatureReading findUnique
   */
  export type OilTemperatureReadingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OilTemperatureReading
     */
    select?: OilTemperatureReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OilTemperatureReading
     */
    omit?: OilTemperatureReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OilTemperatureReadingInclude<ExtArgs> | null
    /**
     * Filter, which OilTemperatureReading to fetch.
     */
    where: OilTemperatureReadingWhereUniqueInput
  }

  /**
   * OilTemperatureReading findUniqueOrThrow
   */
  export type OilTemperatureReadingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OilTemperatureReading
     */
    select?: OilTemperatureReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OilTemperatureReading
     */
    omit?: OilTemperatureReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OilTemperatureReadingInclude<ExtArgs> | null
    /**
     * Filter, which OilTemperatureReading to fetch.
     */
    where: OilTemperatureReadingWhereUniqueInput
  }

  /**
   * OilTemperatureReading findFirst
   */
  export type OilTemperatureReadingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OilTemperatureReading
     */
    select?: OilTemperatureReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OilTemperatureReading
     */
    omit?: OilTemperatureReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OilTemperatureReadingInclude<ExtArgs> | null
    /**
     * Filter, which OilTemperatureReading to fetch.
     */
    where?: OilTemperatureReadingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OilTemperatureReadings to fetch.
     */
    orderBy?: OilTemperatureReadingOrderByWithRelationInput | OilTemperatureReadingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OilTemperatureReadings.
     */
    cursor?: OilTemperatureReadingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OilTemperatureReadings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OilTemperatureReadings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OilTemperatureReadings.
     */
    distinct?: OilTemperatureReadingScalarFieldEnum | OilTemperatureReadingScalarFieldEnum[]
  }

  /**
   * OilTemperatureReading findFirstOrThrow
   */
  export type OilTemperatureReadingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OilTemperatureReading
     */
    select?: OilTemperatureReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OilTemperatureReading
     */
    omit?: OilTemperatureReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OilTemperatureReadingInclude<ExtArgs> | null
    /**
     * Filter, which OilTemperatureReading to fetch.
     */
    where?: OilTemperatureReadingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OilTemperatureReadings to fetch.
     */
    orderBy?: OilTemperatureReadingOrderByWithRelationInput | OilTemperatureReadingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OilTemperatureReadings.
     */
    cursor?: OilTemperatureReadingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OilTemperatureReadings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OilTemperatureReadings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OilTemperatureReadings.
     */
    distinct?: OilTemperatureReadingScalarFieldEnum | OilTemperatureReadingScalarFieldEnum[]
  }

  /**
   * OilTemperatureReading findMany
   */
  export type OilTemperatureReadingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OilTemperatureReading
     */
    select?: OilTemperatureReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OilTemperatureReading
     */
    omit?: OilTemperatureReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OilTemperatureReadingInclude<ExtArgs> | null
    /**
     * Filter, which OilTemperatureReadings to fetch.
     */
    where?: OilTemperatureReadingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OilTemperatureReadings to fetch.
     */
    orderBy?: OilTemperatureReadingOrderByWithRelationInput | OilTemperatureReadingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OilTemperatureReadings.
     */
    cursor?: OilTemperatureReadingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OilTemperatureReadings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OilTemperatureReadings.
     */
    skip?: number
    distinct?: OilTemperatureReadingScalarFieldEnum | OilTemperatureReadingScalarFieldEnum[]
  }

  /**
   * OilTemperatureReading create
   */
  export type OilTemperatureReadingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OilTemperatureReading
     */
    select?: OilTemperatureReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OilTemperatureReading
     */
    omit?: OilTemperatureReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OilTemperatureReadingInclude<ExtArgs> | null
    /**
     * The data needed to create a OilTemperatureReading.
     */
    data: XOR<OilTemperatureReadingCreateInput, OilTemperatureReadingUncheckedCreateInput>
  }

  /**
   * OilTemperatureReading createMany
   */
  export type OilTemperatureReadingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OilTemperatureReadings.
     */
    data: OilTemperatureReadingCreateManyInput | OilTemperatureReadingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OilTemperatureReading createManyAndReturn
   */
  export type OilTemperatureReadingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OilTemperatureReading
     */
    select?: OilTemperatureReadingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OilTemperatureReading
     */
    omit?: OilTemperatureReadingOmit<ExtArgs> | null
    /**
     * The data used to create many OilTemperatureReadings.
     */
    data: OilTemperatureReadingCreateManyInput | OilTemperatureReadingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OilTemperatureReadingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OilTemperatureReading update
   */
  export type OilTemperatureReadingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OilTemperatureReading
     */
    select?: OilTemperatureReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OilTemperatureReading
     */
    omit?: OilTemperatureReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OilTemperatureReadingInclude<ExtArgs> | null
    /**
     * The data needed to update a OilTemperatureReading.
     */
    data: XOR<OilTemperatureReadingUpdateInput, OilTemperatureReadingUncheckedUpdateInput>
    /**
     * Choose, which OilTemperatureReading to update.
     */
    where: OilTemperatureReadingWhereUniqueInput
  }

  /**
   * OilTemperatureReading updateMany
   */
  export type OilTemperatureReadingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OilTemperatureReadings.
     */
    data: XOR<OilTemperatureReadingUpdateManyMutationInput, OilTemperatureReadingUncheckedUpdateManyInput>
    /**
     * Filter which OilTemperatureReadings to update
     */
    where?: OilTemperatureReadingWhereInput
    /**
     * Limit how many OilTemperatureReadings to update.
     */
    limit?: number
  }

  /**
   * OilTemperatureReading updateManyAndReturn
   */
  export type OilTemperatureReadingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OilTemperatureReading
     */
    select?: OilTemperatureReadingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OilTemperatureReading
     */
    omit?: OilTemperatureReadingOmit<ExtArgs> | null
    /**
     * The data used to update OilTemperatureReadings.
     */
    data: XOR<OilTemperatureReadingUpdateManyMutationInput, OilTemperatureReadingUncheckedUpdateManyInput>
    /**
     * Filter which OilTemperatureReadings to update
     */
    where?: OilTemperatureReadingWhereInput
    /**
     * Limit how many OilTemperatureReadings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OilTemperatureReadingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OilTemperatureReading upsert
   */
  export type OilTemperatureReadingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OilTemperatureReading
     */
    select?: OilTemperatureReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OilTemperatureReading
     */
    omit?: OilTemperatureReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OilTemperatureReadingInclude<ExtArgs> | null
    /**
     * The filter to search for the OilTemperatureReading to update in case it exists.
     */
    where: OilTemperatureReadingWhereUniqueInput
    /**
     * In case the OilTemperatureReading found by the `where` argument doesn't exist, create a new OilTemperatureReading with this data.
     */
    create: XOR<OilTemperatureReadingCreateInput, OilTemperatureReadingUncheckedCreateInput>
    /**
     * In case the OilTemperatureReading was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OilTemperatureReadingUpdateInput, OilTemperatureReadingUncheckedUpdateInput>
  }

  /**
   * OilTemperatureReading delete
   */
  export type OilTemperatureReadingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OilTemperatureReading
     */
    select?: OilTemperatureReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OilTemperatureReading
     */
    omit?: OilTemperatureReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OilTemperatureReadingInclude<ExtArgs> | null
    /**
     * Filter which OilTemperatureReading to delete.
     */
    where: OilTemperatureReadingWhereUniqueInput
  }

  /**
   * OilTemperatureReading deleteMany
   */
  export type OilTemperatureReadingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OilTemperatureReadings to delete
     */
    where?: OilTemperatureReadingWhereInput
    /**
     * Limit how many OilTemperatureReadings to delete.
     */
    limit?: number
  }

  /**
   * OilTemperatureReading.user
   */
  export type OilTemperatureReading$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * OilTemperatureReading without action
   */
  export type OilTemperatureReadingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OilTemperatureReading
     */
    select?: OilTemperatureReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OilTemperatureReading
     */
    omit?: OilTemperatureReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OilTemperatureReadingInclude<ExtArgs> | null
  }


  /**
   * Model OilLevelReading
   */

  export type AggregateOilLevelReading = {
    _count: OilLevelReadingCountAggregateOutputType | null
    _avg: OilLevelReadingAvgAggregateOutputType | null
    _sum: OilLevelReadingSumAggregateOutputType | null
    _min: OilLevelReadingMinAggregateOutputType | null
    _max: OilLevelReadingMaxAggregateOutputType | null
  }

  export type OilLevelReadingAvgAggregateOutputType = {
    id: number | null
    level: number | null
    machineId: number | null
    userId: number | null
  }

  export type OilLevelReadingSumAggregateOutputType = {
    id: number | null
    level: number | null
    machineId: number | null
    userId: number | null
  }

  export type OilLevelReadingMinAggregateOutputType = {
    id: number | null
    timestamp: Date | null
    level: number | null
    machineId: number | null
    userId: number | null
  }

  export type OilLevelReadingMaxAggregateOutputType = {
    id: number | null
    timestamp: Date | null
    level: number | null
    machineId: number | null
    userId: number | null
  }

  export type OilLevelReadingCountAggregateOutputType = {
    id: number
    timestamp: number
    level: number
    machineId: number
    userId: number
    _all: number
  }


  export type OilLevelReadingAvgAggregateInputType = {
    id?: true
    level?: true
    machineId?: true
    userId?: true
  }

  export type OilLevelReadingSumAggregateInputType = {
    id?: true
    level?: true
    machineId?: true
    userId?: true
  }

  export type OilLevelReadingMinAggregateInputType = {
    id?: true
    timestamp?: true
    level?: true
    machineId?: true
    userId?: true
  }

  export type OilLevelReadingMaxAggregateInputType = {
    id?: true
    timestamp?: true
    level?: true
    machineId?: true
    userId?: true
  }

  export type OilLevelReadingCountAggregateInputType = {
    id?: true
    timestamp?: true
    level?: true
    machineId?: true
    userId?: true
    _all?: true
  }

  export type OilLevelReadingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OilLevelReading to aggregate.
     */
    where?: OilLevelReadingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OilLevelReadings to fetch.
     */
    orderBy?: OilLevelReadingOrderByWithRelationInput | OilLevelReadingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OilLevelReadingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OilLevelReadings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OilLevelReadings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OilLevelReadings
    **/
    _count?: true | OilLevelReadingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OilLevelReadingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OilLevelReadingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OilLevelReadingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OilLevelReadingMaxAggregateInputType
  }

  export type GetOilLevelReadingAggregateType<T extends OilLevelReadingAggregateArgs> = {
        [P in keyof T & keyof AggregateOilLevelReading]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOilLevelReading[P]>
      : GetScalarType<T[P], AggregateOilLevelReading[P]>
  }




  export type OilLevelReadingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OilLevelReadingWhereInput
    orderBy?: OilLevelReadingOrderByWithAggregationInput | OilLevelReadingOrderByWithAggregationInput[]
    by: OilLevelReadingScalarFieldEnum[] | OilLevelReadingScalarFieldEnum
    having?: OilLevelReadingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OilLevelReadingCountAggregateInputType | true
    _avg?: OilLevelReadingAvgAggregateInputType
    _sum?: OilLevelReadingSumAggregateInputType
    _min?: OilLevelReadingMinAggregateInputType
    _max?: OilLevelReadingMaxAggregateInputType
  }

  export type OilLevelReadingGroupByOutputType = {
    id: number
    timestamp: Date
    level: number
    machineId: number
    userId: number | null
    _count: OilLevelReadingCountAggregateOutputType | null
    _avg: OilLevelReadingAvgAggregateOutputType | null
    _sum: OilLevelReadingSumAggregateOutputType | null
    _min: OilLevelReadingMinAggregateOutputType | null
    _max: OilLevelReadingMaxAggregateOutputType | null
  }

  type GetOilLevelReadingGroupByPayload<T extends OilLevelReadingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OilLevelReadingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OilLevelReadingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OilLevelReadingGroupByOutputType[P]>
            : GetScalarType<T[P], OilLevelReadingGroupByOutputType[P]>
        }
      >
    >


  export type OilLevelReadingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    level?: boolean
    machineId?: boolean
    userId?: boolean
    machine?: boolean | MachineDefaultArgs<ExtArgs>
    user?: boolean | OilLevelReading$userArgs<ExtArgs>
  }, ExtArgs["result"]["oilLevelReading"]>

  export type OilLevelReadingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    level?: boolean
    machineId?: boolean
    userId?: boolean
    machine?: boolean | MachineDefaultArgs<ExtArgs>
    user?: boolean | OilLevelReading$userArgs<ExtArgs>
  }, ExtArgs["result"]["oilLevelReading"]>

  export type OilLevelReadingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    level?: boolean
    machineId?: boolean
    userId?: boolean
    machine?: boolean | MachineDefaultArgs<ExtArgs>
    user?: boolean | OilLevelReading$userArgs<ExtArgs>
  }, ExtArgs["result"]["oilLevelReading"]>

  export type OilLevelReadingSelectScalar = {
    id?: boolean
    timestamp?: boolean
    level?: boolean
    machineId?: boolean
    userId?: boolean
  }

  export type OilLevelReadingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "timestamp" | "level" | "machineId" | "userId", ExtArgs["result"]["oilLevelReading"]>
  export type OilLevelReadingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    machine?: boolean | MachineDefaultArgs<ExtArgs>
    user?: boolean | OilLevelReading$userArgs<ExtArgs>
  }
  export type OilLevelReadingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    machine?: boolean | MachineDefaultArgs<ExtArgs>
    user?: boolean | OilLevelReading$userArgs<ExtArgs>
  }
  export type OilLevelReadingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    machine?: boolean | MachineDefaultArgs<ExtArgs>
    user?: boolean | OilLevelReading$userArgs<ExtArgs>
  }

  export type $OilLevelReadingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OilLevelReading"
    objects: {
      machine: Prisma.$MachinePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      timestamp: Date
      level: number
      machineId: number
      userId: number | null
    }, ExtArgs["result"]["oilLevelReading"]>
    composites: {}
  }

  type OilLevelReadingGetPayload<S extends boolean | null | undefined | OilLevelReadingDefaultArgs> = $Result.GetResult<Prisma.$OilLevelReadingPayload, S>

  type OilLevelReadingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OilLevelReadingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OilLevelReadingCountAggregateInputType | true
    }

  export interface OilLevelReadingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OilLevelReading'], meta: { name: 'OilLevelReading' } }
    /**
     * Find zero or one OilLevelReading that matches the filter.
     * @param {OilLevelReadingFindUniqueArgs} args - Arguments to find a OilLevelReading
     * @example
     * // Get one OilLevelReading
     * const oilLevelReading = await prisma.oilLevelReading.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OilLevelReadingFindUniqueArgs>(args: SelectSubset<T, OilLevelReadingFindUniqueArgs<ExtArgs>>): Prisma__OilLevelReadingClient<$Result.GetResult<Prisma.$OilLevelReadingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OilLevelReading that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OilLevelReadingFindUniqueOrThrowArgs} args - Arguments to find a OilLevelReading
     * @example
     * // Get one OilLevelReading
     * const oilLevelReading = await prisma.oilLevelReading.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OilLevelReadingFindUniqueOrThrowArgs>(args: SelectSubset<T, OilLevelReadingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OilLevelReadingClient<$Result.GetResult<Prisma.$OilLevelReadingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OilLevelReading that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OilLevelReadingFindFirstArgs} args - Arguments to find a OilLevelReading
     * @example
     * // Get one OilLevelReading
     * const oilLevelReading = await prisma.oilLevelReading.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OilLevelReadingFindFirstArgs>(args?: SelectSubset<T, OilLevelReadingFindFirstArgs<ExtArgs>>): Prisma__OilLevelReadingClient<$Result.GetResult<Prisma.$OilLevelReadingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OilLevelReading that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OilLevelReadingFindFirstOrThrowArgs} args - Arguments to find a OilLevelReading
     * @example
     * // Get one OilLevelReading
     * const oilLevelReading = await prisma.oilLevelReading.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OilLevelReadingFindFirstOrThrowArgs>(args?: SelectSubset<T, OilLevelReadingFindFirstOrThrowArgs<ExtArgs>>): Prisma__OilLevelReadingClient<$Result.GetResult<Prisma.$OilLevelReadingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OilLevelReadings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OilLevelReadingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OilLevelReadings
     * const oilLevelReadings = await prisma.oilLevelReading.findMany()
     * 
     * // Get first 10 OilLevelReadings
     * const oilLevelReadings = await prisma.oilLevelReading.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const oilLevelReadingWithIdOnly = await prisma.oilLevelReading.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OilLevelReadingFindManyArgs>(args?: SelectSubset<T, OilLevelReadingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OilLevelReadingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OilLevelReading.
     * @param {OilLevelReadingCreateArgs} args - Arguments to create a OilLevelReading.
     * @example
     * // Create one OilLevelReading
     * const OilLevelReading = await prisma.oilLevelReading.create({
     *   data: {
     *     // ... data to create a OilLevelReading
     *   }
     * })
     * 
     */
    create<T extends OilLevelReadingCreateArgs>(args: SelectSubset<T, OilLevelReadingCreateArgs<ExtArgs>>): Prisma__OilLevelReadingClient<$Result.GetResult<Prisma.$OilLevelReadingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OilLevelReadings.
     * @param {OilLevelReadingCreateManyArgs} args - Arguments to create many OilLevelReadings.
     * @example
     * // Create many OilLevelReadings
     * const oilLevelReading = await prisma.oilLevelReading.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OilLevelReadingCreateManyArgs>(args?: SelectSubset<T, OilLevelReadingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OilLevelReadings and returns the data saved in the database.
     * @param {OilLevelReadingCreateManyAndReturnArgs} args - Arguments to create many OilLevelReadings.
     * @example
     * // Create many OilLevelReadings
     * const oilLevelReading = await prisma.oilLevelReading.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OilLevelReadings and only return the `id`
     * const oilLevelReadingWithIdOnly = await prisma.oilLevelReading.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OilLevelReadingCreateManyAndReturnArgs>(args?: SelectSubset<T, OilLevelReadingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OilLevelReadingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OilLevelReading.
     * @param {OilLevelReadingDeleteArgs} args - Arguments to delete one OilLevelReading.
     * @example
     * // Delete one OilLevelReading
     * const OilLevelReading = await prisma.oilLevelReading.delete({
     *   where: {
     *     // ... filter to delete one OilLevelReading
     *   }
     * })
     * 
     */
    delete<T extends OilLevelReadingDeleteArgs>(args: SelectSubset<T, OilLevelReadingDeleteArgs<ExtArgs>>): Prisma__OilLevelReadingClient<$Result.GetResult<Prisma.$OilLevelReadingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OilLevelReading.
     * @param {OilLevelReadingUpdateArgs} args - Arguments to update one OilLevelReading.
     * @example
     * // Update one OilLevelReading
     * const oilLevelReading = await prisma.oilLevelReading.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OilLevelReadingUpdateArgs>(args: SelectSubset<T, OilLevelReadingUpdateArgs<ExtArgs>>): Prisma__OilLevelReadingClient<$Result.GetResult<Prisma.$OilLevelReadingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OilLevelReadings.
     * @param {OilLevelReadingDeleteManyArgs} args - Arguments to filter OilLevelReadings to delete.
     * @example
     * // Delete a few OilLevelReadings
     * const { count } = await prisma.oilLevelReading.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OilLevelReadingDeleteManyArgs>(args?: SelectSubset<T, OilLevelReadingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OilLevelReadings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OilLevelReadingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OilLevelReadings
     * const oilLevelReading = await prisma.oilLevelReading.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OilLevelReadingUpdateManyArgs>(args: SelectSubset<T, OilLevelReadingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OilLevelReadings and returns the data updated in the database.
     * @param {OilLevelReadingUpdateManyAndReturnArgs} args - Arguments to update many OilLevelReadings.
     * @example
     * // Update many OilLevelReadings
     * const oilLevelReading = await prisma.oilLevelReading.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OilLevelReadings and only return the `id`
     * const oilLevelReadingWithIdOnly = await prisma.oilLevelReading.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OilLevelReadingUpdateManyAndReturnArgs>(args: SelectSubset<T, OilLevelReadingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OilLevelReadingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OilLevelReading.
     * @param {OilLevelReadingUpsertArgs} args - Arguments to update or create a OilLevelReading.
     * @example
     * // Update or create a OilLevelReading
     * const oilLevelReading = await prisma.oilLevelReading.upsert({
     *   create: {
     *     // ... data to create a OilLevelReading
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OilLevelReading we want to update
     *   }
     * })
     */
    upsert<T extends OilLevelReadingUpsertArgs>(args: SelectSubset<T, OilLevelReadingUpsertArgs<ExtArgs>>): Prisma__OilLevelReadingClient<$Result.GetResult<Prisma.$OilLevelReadingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OilLevelReadings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OilLevelReadingCountArgs} args - Arguments to filter OilLevelReadings to count.
     * @example
     * // Count the number of OilLevelReadings
     * const count = await prisma.oilLevelReading.count({
     *   where: {
     *     // ... the filter for the OilLevelReadings we want to count
     *   }
     * })
    **/
    count<T extends OilLevelReadingCountArgs>(
      args?: Subset<T, OilLevelReadingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OilLevelReadingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OilLevelReading.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OilLevelReadingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OilLevelReadingAggregateArgs>(args: Subset<T, OilLevelReadingAggregateArgs>): Prisma.PrismaPromise<GetOilLevelReadingAggregateType<T>>

    /**
     * Group by OilLevelReading.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OilLevelReadingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OilLevelReadingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OilLevelReadingGroupByArgs['orderBy'] }
        : { orderBy?: OilLevelReadingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OilLevelReadingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOilLevelReadingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OilLevelReading model
   */
  readonly fields: OilLevelReadingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OilLevelReading.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OilLevelReadingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    machine<T extends MachineDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MachineDefaultArgs<ExtArgs>>): Prisma__MachineClient<$Result.GetResult<Prisma.$MachinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends OilLevelReading$userArgs<ExtArgs> = {}>(args?: Subset<T, OilLevelReading$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OilLevelReading model
   */
  interface OilLevelReadingFieldRefs {
    readonly id: FieldRef<"OilLevelReading", 'Int'>
    readonly timestamp: FieldRef<"OilLevelReading", 'DateTime'>
    readonly level: FieldRef<"OilLevelReading", 'Float'>
    readonly machineId: FieldRef<"OilLevelReading", 'Int'>
    readonly userId: FieldRef<"OilLevelReading", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * OilLevelReading findUnique
   */
  export type OilLevelReadingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OilLevelReading
     */
    select?: OilLevelReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OilLevelReading
     */
    omit?: OilLevelReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OilLevelReadingInclude<ExtArgs> | null
    /**
     * Filter, which OilLevelReading to fetch.
     */
    where: OilLevelReadingWhereUniqueInput
  }

  /**
   * OilLevelReading findUniqueOrThrow
   */
  export type OilLevelReadingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OilLevelReading
     */
    select?: OilLevelReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OilLevelReading
     */
    omit?: OilLevelReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OilLevelReadingInclude<ExtArgs> | null
    /**
     * Filter, which OilLevelReading to fetch.
     */
    where: OilLevelReadingWhereUniqueInput
  }

  /**
   * OilLevelReading findFirst
   */
  export type OilLevelReadingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OilLevelReading
     */
    select?: OilLevelReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OilLevelReading
     */
    omit?: OilLevelReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OilLevelReadingInclude<ExtArgs> | null
    /**
     * Filter, which OilLevelReading to fetch.
     */
    where?: OilLevelReadingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OilLevelReadings to fetch.
     */
    orderBy?: OilLevelReadingOrderByWithRelationInput | OilLevelReadingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OilLevelReadings.
     */
    cursor?: OilLevelReadingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OilLevelReadings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OilLevelReadings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OilLevelReadings.
     */
    distinct?: OilLevelReadingScalarFieldEnum | OilLevelReadingScalarFieldEnum[]
  }

  /**
   * OilLevelReading findFirstOrThrow
   */
  export type OilLevelReadingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OilLevelReading
     */
    select?: OilLevelReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OilLevelReading
     */
    omit?: OilLevelReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OilLevelReadingInclude<ExtArgs> | null
    /**
     * Filter, which OilLevelReading to fetch.
     */
    where?: OilLevelReadingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OilLevelReadings to fetch.
     */
    orderBy?: OilLevelReadingOrderByWithRelationInput | OilLevelReadingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OilLevelReadings.
     */
    cursor?: OilLevelReadingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OilLevelReadings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OilLevelReadings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OilLevelReadings.
     */
    distinct?: OilLevelReadingScalarFieldEnum | OilLevelReadingScalarFieldEnum[]
  }

  /**
   * OilLevelReading findMany
   */
  export type OilLevelReadingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OilLevelReading
     */
    select?: OilLevelReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OilLevelReading
     */
    omit?: OilLevelReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OilLevelReadingInclude<ExtArgs> | null
    /**
     * Filter, which OilLevelReadings to fetch.
     */
    where?: OilLevelReadingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OilLevelReadings to fetch.
     */
    orderBy?: OilLevelReadingOrderByWithRelationInput | OilLevelReadingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OilLevelReadings.
     */
    cursor?: OilLevelReadingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OilLevelReadings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OilLevelReadings.
     */
    skip?: number
    distinct?: OilLevelReadingScalarFieldEnum | OilLevelReadingScalarFieldEnum[]
  }

  /**
   * OilLevelReading create
   */
  export type OilLevelReadingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OilLevelReading
     */
    select?: OilLevelReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OilLevelReading
     */
    omit?: OilLevelReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OilLevelReadingInclude<ExtArgs> | null
    /**
     * The data needed to create a OilLevelReading.
     */
    data: XOR<OilLevelReadingCreateInput, OilLevelReadingUncheckedCreateInput>
  }

  /**
   * OilLevelReading createMany
   */
  export type OilLevelReadingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OilLevelReadings.
     */
    data: OilLevelReadingCreateManyInput | OilLevelReadingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OilLevelReading createManyAndReturn
   */
  export type OilLevelReadingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OilLevelReading
     */
    select?: OilLevelReadingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OilLevelReading
     */
    omit?: OilLevelReadingOmit<ExtArgs> | null
    /**
     * The data used to create many OilLevelReadings.
     */
    data: OilLevelReadingCreateManyInput | OilLevelReadingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OilLevelReadingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OilLevelReading update
   */
  export type OilLevelReadingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OilLevelReading
     */
    select?: OilLevelReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OilLevelReading
     */
    omit?: OilLevelReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OilLevelReadingInclude<ExtArgs> | null
    /**
     * The data needed to update a OilLevelReading.
     */
    data: XOR<OilLevelReadingUpdateInput, OilLevelReadingUncheckedUpdateInput>
    /**
     * Choose, which OilLevelReading to update.
     */
    where: OilLevelReadingWhereUniqueInput
  }

  /**
   * OilLevelReading updateMany
   */
  export type OilLevelReadingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OilLevelReadings.
     */
    data: XOR<OilLevelReadingUpdateManyMutationInput, OilLevelReadingUncheckedUpdateManyInput>
    /**
     * Filter which OilLevelReadings to update
     */
    where?: OilLevelReadingWhereInput
    /**
     * Limit how many OilLevelReadings to update.
     */
    limit?: number
  }

  /**
   * OilLevelReading updateManyAndReturn
   */
  export type OilLevelReadingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OilLevelReading
     */
    select?: OilLevelReadingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OilLevelReading
     */
    omit?: OilLevelReadingOmit<ExtArgs> | null
    /**
     * The data used to update OilLevelReadings.
     */
    data: XOR<OilLevelReadingUpdateManyMutationInput, OilLevelReadingUncheckedUpdateManyInput>
    /**
     * Filter which OilLevelReadings to update
     */
    where?: OilLevelReadingWhereInput
    /**
     * Limit how many OilLevelReadings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OilLevelReadingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OilLevelReading upsert
   */
  export type OilLevelReadingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OilLevelReading
     */
    select?: OilLevelReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OilLevelReading
     */
    omit?: OilLevelReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OilLevelReadingInclude<ExtArgs> | null
    /**
     * The filter to search for the OilLevelReading to update in case it exists.
     */
    where: OilLevelReadingWhereUniqueInput
    /**
     * In case the OilLevelReading found by the `where` argument doesn't exist, create a new OilLevelReading with this data.
     */
    create: XOR<OilLevelReadingCreateInput, OilLevelReadingUncheckedCreateInput>
    /**
     * In case the OilLevelReading was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OilLevelReadingUpdateInput, OilLevelReadingUncheckedUpdateInput>
  }

  /**
   * OilLevelReading delete
   */
  export type OilLevelReadingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OilLevelReading
     */
    select?: OilLevelReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OilLevelReading
     */
    omit?: OilLevelReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OilLevelReadingInclude<ExtArgs> | null
    /**
     * Filter which OilLevelReading to delete.
     */
    where: OilLevelReadingWhereUniqueInput
  }

  /**
   * OilLevelReading deleteMany
   */
  export type OilLevelReadingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OilLevelReadings to delete
     */
    where?: OilLevelReadingWhereInput
    /**
     * Limit how many OilLevelReadings to delete.
     */
    limit?: number
  }

  /**
   * OilLevelReading.user
   */
  export type OilLevelReading$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * OilLevelReading without action
   */
  export type OilLevelReadingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OilLevelReading
     */
    select?: OilLevelReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OilLevelReading
     */
    omit?: OilLevelReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OilLevelReadingInclude<ExtArgs> | null
  }


  /**
   * Model CurrentReading
   */

  export type AggregateCurrentReading = {
    _count: CurrentReadingCountAggregateOutputType | null
    _avg: CurrentReadingAvgAggregateOutputType | null
    _sum: CurrentReadingSumAggregateOutputType | null
    _min: CurrentReadingMinAggregateOutputType | null
    _max: CurrentReadingMaxAggregateOutputType | null
  }

  export type CurrentReadingAvgAggregateOutputType = {
    id: number | null
    current: number | null
    machineId: number | null
    userId: number | null
  }

  export type CurrentReadingSumAggregateOutputType = {
    id: number | null
    current: number | null
    machineId: number | null
    userId: number | null
  }

  export type CurrentReadingMinAggregateOutputType = {
    id: number | null
    timestamp: Date | null
    current: number | null
    machineId: number | null
    userId: number | null
  }

  export type CurrentReadingMaxAggregateOutputType = {
    id: number | null
    timestamp: Date | null
    current: number | null
    machineId: number | null
    userId: number | null
  }

  export type CurrentReadingCountAggregateOutputType = {
    id: number
    timestamp: number
    current: number
    machineId: number
    userId: number
    _all: number
  }


  export type CurrentReadingAvgAggregateInputType = {
    id?: true
    current?: true
    machineId?: true
    userId?: true
  }

  export type CurrentReadingSumAggregateInputType = {
    id?: true
    current?: true
    machineId?: true
    userId?: true
  }

  export type CurrentReadingMinAggregateInputType = {
    id?: true
    timestamp?: true
    current?: true
    machineId?: true
    userId?: true
  }

  export type CurrentReadingMaxAggregateInputType = {
    id?: true
    timestamp?: true
    current?: true
    machineId?: true
    userId?: true
  }

  export type CurrentReadingCountAggregateInputType = {
    id?: true
    timestamp?: true
    current?: true
    machineId?: true
    userId?: true
    _all?: true
  }

  export type CurrentReadingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CurrentReading to aggregate.
     */
    where?: CurrentReadingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CurrentReadings to fetch.
     */
    orderBy?: CurrentReadingOrderByWithRelationInput | CurrentReadingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CurrentReadingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CurrentReadings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CurrentReadings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CurrentReadings
    **/
    _count?: true | CurrentReadingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CurrentReadingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CurrentReadingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CurrentReadingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CurrentReadingMaxAggregateInputType
  }

  export type GetCurrentReadingAggregateType<T extends CurrentReadingAggregateArgs> = {
        [P in keyof T & keyof AggregateCurrentReading]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCurrentReading[P]>
      : GetScalarType<T[P], AggregateCurrentReading[P]>
  }




  export type CurrentReadingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CurrentReadingWhereInput
    orderBy?: CurrentReadingOrderByWithAggregationInput | CurrentReadingOrderByWithAggregationInput[]
    by: CurrentReadingScalarFieldEnum[] | CurrentReadingScalarFieldEnum
    having?: CurrentReadingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CurrentReadingCountAggregateInputType | true
    _avg?: CurrentReadingAvgAggregateInputType
    _sum?: CurrentReadingSumAggregateInputType
    _min?: CurrentReadingMinAggregateInputType
    _max?: CurrentReadingMaxAggregateInputType
  }

  export type CurrentReadingGroupByOutputType = {
    id: number
    timestamp: Date
    current: number
    machineId: number
    userId: number | null
    _count: CurrentReadingCountAggregateOutputType | null
    _avg: CurrentReadingAvgAggregateOutputType | null
    _sum: CurrentReadingSumAggregateOutputType | null
    _min: CurrentReadingMinAggregateOutputType | null
    _max: CurrentReadingMaxAggregateOutputType | null
  }

  type GetCurrentReadingGroupByPayload<T extends CurrentReadingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CurrentReadingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CurrentReadingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CurrentReadingGroupByOutputType[P]>
            : GetScalarType<T[P], CurrentReadingGroupByOutputType[P]>
        }
      >
    >


  export type CurrentReadingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    current?: boolean
    machineId?: boolean
    userId?: boolean
    machine?: boolean | MachineDefaultArgs<ExtArgs>
    user?: boolean | CurrentReading$userArgs<ExtArgs>
  }, ExtArgs["result"]["currentReading"]>

  export type CurrentReadingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    current?: boolean
    machineId?: boolean
    userId?: boolean
    machine?: boolean | MachineDefaultArgs<ExtArgs>
    user?: boolean | CurrentReading$userArgs<ExtArgs>
  }, ExtArgs["result"]["currentReading"]>

  export type CurrentReadingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    current?: boolean
    machineId?: boolean
    userId?: boolean
    machine?: boolean | MachineDefaultArgs<ExtArgs>
    user?: boolean | CurrentReading$userArgs<ExtArgs>
  }, ExtArgs["result"]["currentReading"]>

  export type CurrentReadingSelectScalar = {
    id?: boolean
    timestamp?: boolean
    current?: boolean
    machineId?: boolean
    userId?: boolean
  }

  export type CurrentReadingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "timestamp" | "current" | "machineId" | "userId", ExtArgs["result"]["currentReading"]>
  export type CurrentReadingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    machine?: boolean | MachineDefaultArgs<ExtArgs>
    user?: boolean | CurrentReading$userArgs<ExtArgs>
  }
  export type CurrentReadingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    machine?: boolean | MachineDefaultArgs<ExtArgs>
    user?: boolean | CurrentReading$userArgs<ExtArgs>
  }
  export type CurrentReadingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    machine?: boolean | MachineDefaultArgs<ExtArgs>
    user?: boolean | CurrentReading$userArgs<ExtArgs>
  }

  export type $CurrentReadingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CurrentReading"
    objects: {
      machine: Prisma.$MachinePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      timestamp: Date
      current: number
      machineId: number
      userId: number | null
    }, ExtArgs["result"]["currentReading"]>
    composites: {}
  }

  type CurrentReadingGetPayload<S extends boolean | null | undefined | CurrentReadingDefaultArgs> = $Result.GetResult<Prisma.$CurrentReadingPayload, S>

  type CurrentReadingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CurrentReadingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CurrentReadingCountAggregateInputType | true
    }

  export interface CurrentReadingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CurrentReading'], meta: { name: 'CurrentReading' } }
    /**
     * Find zero or one CurrentReading that matches the filter.
     * @param {CurrentReadingFindUniqueArgs} args - Arguments to find a CurrentReading
     * @example
     * // Get one CurrentReading
     * const currentReading = await prisma.currentReading.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CurrentReadingFindUniqueArgs>(args: SelectSubset<T, CurrentReadingFindUniqueArgs<ExtArgs>>): Prisma__CurrentReadingClient<$Result.GetResult<Prisma.$CurrentReadingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CurrentReading that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CurrentReadingFindUniqueOrThrowArgs} args - Arguments to find a CurrentReading
     * @example
     * // Get one CurrentReading
     * const currentReading = await prisma.currentReading.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CurrentReadingFindUniqueOrThrowArgs>(args: SelectSubset<T, CurrentReadingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CurrentReadingClient<$Result.GetResult<Prisma.$CurrentReadingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CurrentReading that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrentReadingFindFirstArgs} args - Arguments to find a CurrentReading
     * @example
     * // Get one CurrentReading
     * const currentReading = await prisma.currentReading.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CurrentReadingFindFirstArgs>(args?: SelectSubset<T, CurrentReadingFindFirstArgs<ExtArgs>>): Prisma__CurrentReadingClient<$Result.GetResult<Prisma.$CurrentReadingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CurrentReading that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrentReadingFindFirstOrThrowArgs} args - Arguments to find a CurrentReading
     * @example
     * // Get one CurrentReading
     * const currentReading = await prisma.currentReading.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CurrentReadingFindFirstOrThrowArgs>(args?: SelectSubset<T, CurrentReadingFindFirstOrThrowArgs<ExtArgs>>): Prisma__CurrentReadingClient<$Result.GetResult<Prisma.$CurrentReadingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CurrentReadings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrentReadingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CurrentReadings
     * const currentReadings = await prisma.currentReading.findMany()
     * 
     * // Get first 10 CurrentReadings
     * const currentReadings = await prisma.currentReading.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const currentReadingWithIdOnly = await prisma.currentReading.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CurrentReadingFindManyArgs>(args?: SelectSubset<T, CurrentReadingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CurrentReadingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CurrentReading.
     * @param {CurrentReadingCreateArgs} args - Arguments to create a CurrentReading.
     * @example
     * // Create one CurrentReading
     * const CurrentReading = await prisma.currentReading.create({
     *   data: {
     *     // ... data to create a CurrentReading
     *   }
     * })
     * 
     */
    create<T extends CurrentReadingCreateArgs>(args: SelectSubset<T, CurrentReadingCreateArgs<ExtArgs>>): Prisma__CurrentReadingClient<$Result.GetResult<Prisma.$CurrentReadingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CurrentReadings.
     * @param {CurrentReadingCreateManyArgs} args - Arguments to create many CurrentReadings.
     * @example
     * // Create many CurrentReadings
     * const currentReading = await prisma.currentReading.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CurrentReadingCreateManyArgs>(args?: SelectSubset<T, CurrentReadingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CurrentReadings and returns the data saved in the database.
     * @param {CurrentReadingCreateManyAndReturnArgs} args - Arguments to create many CurrentReadings.
     * @example
     * // Create many CurrentReadings
     * const currentReading = await prisma.currentReading.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CurrentReadings and only return the `id`
     * const currentReadingWithIdOnly = await prisma.currentReading.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CurrentReadingCreateManyAndReturnArgs>(args?: SelectSubset<T, CurrentReadingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CurrentReadingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CurrentReading.
     * @param {CurrentReadingDeleteArgs} args - Arguments to delete one CurrentReading.
     * @example
     * // Delete one CurrentReading
     * const CurrentReading = await prisma.currentReading.delete({
     *   where: {
     *     // ... filter to delete one CurrentReading
     *   }
     * })
     * 
     */
    delete<T extends CurrentReadingDeleteArgs>(args: SelectSubset<T, CurrentReadingDeleteArgs<ExtArgs>>): Prisma__CurrentReadingClient<$Result.GetResult<Prisma.$CurrentReadingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CurrentReading.
     * @param {CurrentReadingUpdateArgs} args - Arguments to update one CurrentReading.
     * @example
     * // Update one CurrentReading
     * const currentReading = await prisma.currentReading.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CurrentReadingUpdateArgs>(args: SelectSubset<T, CurrentReadingUpdateArgs<ExtArgs>>): Prisma__CurrentReadingClient<$Result.GetResult<Prisma.$CurrentReadingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CurrentReadings.
     * @param {CurrentReadingDeleteManyArgs} args - Arguments to filter CurrentReadings to delete.
     * @example
     * // Delete a few CurrentReadings
     * const { count } = await prisma.currentReading.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CurrentReadingDeleteManyArgs>(args?: SelectSubset<T, CurrentReadingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CurrentReadings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrentReadingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CurrentReadings
     * const currentReading = await prisma.currentReading.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CurrentReadingUpdateManyArgs>(args: SelectSubset<T, CurrentReadingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CurrentReadings and returns the data updated in the database.
     * @param {CurrentReadingUpdateManyAndReturnArgs} args - Arguments to update many CurrentReadings.
     * @example
     * // Update many CurrentReadings
     * const currentReading = await prisma.currentReading.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CurrentReadings and only return the `id`
     * const currentReadingWithIdOnly = await prisma.currentReading.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CurrentReadingUpdateManyAndReturnArgs>(args: SelectSubset<T, CurrentReadingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CurrentReadingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CurrentReading.
     * @param {CurrentReadingUpsertArgs} args - Arguments to update or create a CurrentReading.
     * @example
     * // Update or create a CurrentReading
     * const currentReading = await prisma.currentReading.upsert({
     *   create: {
     *     // ... data to create a CurrentReading
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CurrentReading we want to update
     *   }
     * })
     */
    upsert<T extends CurrentReadingUpsertArgs>(args: SelectSubset<T, CurrentReadingUpsertArgs<ExtArgs>>): Prisma__CurrentReadingClient<$Result.GetResult<Prisma.$CurrentReadingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CurrentReadings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrentReadingCountArgs} args - Arguments to filter CurrentReadings to count.
     * @example
     * // Count the number of CurrentReadings
     * const count = await prisma.currentReading.count({
     *   where: {
     *     // ... the filter for the CurrentReadings we want to count
     *   }
     * })
    **/
    count<T extends CurrentReadingCountArgs>(
      args?: Subset<T, CurrentReadingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CurrentReadingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CurrentReading.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrentReadingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CurrentReadingAggregateArgs>(args: Subset<T, CurrentReadingAggregateArgs>): Prisma.PrismaPromise<GetCurrentReadingAggregateType<T>>

    /**
     * Group by CurrentReading.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrentReadingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CurrentReadingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CurrentReadingGroupByArgs['orderBy'] }
        : { orderBy?: CurrentReadingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CurrentReadingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCurrentReadingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CurrentReading model
   */
  readonly fields: CurrentReadingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CurrentReading.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CurrentReadingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    machine<T extends MachineDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MachineDefaultArgs<ExtArgs>>): Prisma__MachineClient<$Result.GetResult<Prisma.$MachinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends CurrentReading$userArgs<ExtArgs> = {}>(args?: Subset<T, CurrentReading$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CurrentReading model
   */
  interface CurrentReadingFieldRefs {
    readonly id: FieldRef<"CurrentReading", 'Int'>
    readonly timestamp: FieldRef<"CurrentReading", 'DateTime'>
    readonly current: FieldRef<"CurrentReading", 'Float'>
    readonly machineId: FieldRef<"CurrentReading", 'Int'>
    readonly userId: FieldRef<"CurrentReading", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * CurrentReading findUnique
   */
  export type CurrentReadingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrentReading
     */
    select?: CurrentReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurrentReading
     */
    omit?: CurrentReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrentReadingInclude<ExtArgs> | null
    /**
     * Filter, which CurrentReading to fetch.
     */
    where: CurrentReadingWhereUniqueInput
  }

  /**
   * CurrentReading findUniqueOrThrow
   */
  export type CurrentReadingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrentReading
     */
    select?: CurrentReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurrentReading
     */
    omit?: CurrentReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrentReadingInclude<ExtArgs> | null
    /**
     * Filter, which CurrentReading to fetch.
     */
    where: CurrentReadingWhereUniqueInput
  }

  /**
   * CurrentReading findFirst
   */
  export type CurrentReadingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrentReading
     */
    select?: CurrentReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurrentReading
     */
    omit?: CurrentReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrentReadingInclude<ExtArgs> | null
    /**
     * Filter, which CurrentReading to fetch.
     */
    where?: CurrentReadingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CurrentReadings to fetch.
     */
    orderBy?: CurrentReadingOrderByWithRelationInput | CurrentReadingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CurrentReadings.
     */
    cursor?: CurrentReadingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CurrentReadings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CurrentReadings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CurrentReadings.
     */
    distinct?: CurrentReadingScalarFieldEnum | CurrentReadingScalarFieldEnum[]
  }

  /**
   * CurrentReading findFirstOrThrow
   */
  export type CurrentReadingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrentReading
     */
    select?: CurrentReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurrentReading
     */
    omit?: CurrentReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrentReadingInclude<ExtArgs> | null
    /**
     * Filter, which CurrentReading to fetch.
     */
    where?: CurrentReadingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CurrentReadings to fetch.
     */
    orderBy?: CurrentReadingOrderByWithRelationInput | CurrentReadingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CurrentReadings.
     */
    cursor?: CurrentReadingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CurrentReadings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CurrentReadings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CurrentReadings.
     */
    distinct?: CurrentReadingScalarFieldEnum | CurrentReadingScalarFieldEnum[]
  }

  /**
   * CurrentReading findMany
   */
  export type CurrentReadingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrentReading
     */
    select?: CurrentReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurrentReading
     */
    omit?: CurrentReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrentReadingInclude<ExtArgs> | null
    /**
     * Filter, which CurrentReadings to fetch.
     */
    where?: CurrentReadingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CurrentReadings to fetch.
     */
    orderBy?: CurrentReadingOrderByWithRelationInput | CurrentReadingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CurrentReadings.
     */
    cursor?: CurrentReadingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CurrentReadings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CurrentReadings.
     */
    skip?: number
    distinct?: CurrentReadingScalarFieldEnum | CurrentReadingScalarFieldEnum[]
  }

  /**
   * CurrentReading create
   */
  export type CurrentReadingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrentReading
     */
    select?: CurrentReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurrentReading
     */
    omit?: CurrentReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrentReadingInclude<ExtArgs> | null
    /**
     * The data needed to create a CurrentReading.
     */
    data: XOR<CurrentReadingCreateInput, CurrentReadingUncheckedCreateInput>
  }

  /**
   * CurrentReading createMany
   */
  export type CurrentReadingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CurrentReadings.
     */
    data: CurrentReadingCreateManyInput | CurrentReadingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CurrentReading createManyAndReturn
   */
  export type CurrentReadingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrentReading
     */
    select?: CurrentReadingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CurrentReading
     */
    omit?: CurrentReadingOmit<ExtArgs> | null
    /**
     * The data used to create many CurrentReadings.
     */
    data: CurrentReadingCreateManyInput | CurrentReadingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrentReadingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CurrentReading update
   */
  export type CurrentReadingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrentReading
     */
    select?: CurrentReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurrentReading
     */
    omit?: CurrentReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrentReadingInclude<ExtArgs> | null
    /**
     * The data needed to update a CurrentReading.
     */
    data: XOR<CurrentReadingUpdateInput, CurrentReadingUncheckedUpdateInput>
    /**
     * Choose, which CurrentReading to update.
     */
    where: CurrentReadingWhereUniqueInput
  }

  /**
   * CurrentReading updateMany
   */
  export type CurrentReadingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CurrentReadings.
     */
    data: XOR<CurrentReadingUpdateManyMutationInput, CurrentReadingUncheckedUpdateManyInput>
    /**
     * Filter which CurrentReadings to update
     */
    where?: CurrentReadingWhereInput
    /**
     * Limit how many CurrentReadings to update.
     */
    limit?: number
  }

  /**
   * CurrentReading updateManyAndReturn
   */
  export type CurrentReadingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrentReading
     */
    select?: CurrentReadingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CurrentReading
     */
    omit?: CurrentReadingOmit<ExtArgs> | null
    /**
     * The data used to update CurrentReadings.
     */
    data: XOR<CurrentReadingUpdateManyMutationInput, CurrentReadingUncheckedUpdateManyInput>
    /**
     * Filter which CurrentReadings to update
     */
    where?: CurrentReadingWhereInput
    /**
     * Limit how many CurrentReadings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrentReadingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CurrentReading upsert
   */
  export type CurrentReadingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrentReading
     */
    select?: CurrentReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurrentReading
     */
    omit?: CurrentReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrentReadingInclude<ExtArgs> | null
    /**
     * The filter to search for the CurrentReading to update in case it exists.
     */
    where: CurrentReadingWhereUniqueInput
    /**
     * In case the CurrentReading found by the `where` argument doesn't exist, create a new CurrentReading with this data.
     */
    create: XOR<CurrentReadingCreateInput, CurrentReadingUncheckedCreateInput>
    /**
     * In case the CurrentReading was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CurrentReadingUpdateInput, CurrentReadingUncheckedUpdateInput>
  }

  /**
   * CurrentReading delete
   */
  export type CurrentReadingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrentReading
     */
    select?: CurrentReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurrentReading
     */
    omit?: CurrentReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrentReadingInclude<ExtArgs> | null
    /**
     * Filter which CurrentReading to delete.
     */
    where: CurrentReadingWhereUniqueInput
  }

  /**
   * CurrentReading deleteMany
   */
  export type CurrentReadingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CurrentReadings to delete
     */
    where?: CurrentReadingWhereInput
    /**
     * Limit how many CurrentReadings to delete.
     */
    limit?: number
  }

  /**
   * CurrentReading.user
   */
  export type CurrentReading$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * CurrentReading without action
   */
  export type CurrentReadingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrentReading
     */
    select?: CurrentReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurrentReading
     */
    omit?: CurrentReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrentReadingInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const InteracaoIAScalarFieldEnum: {
    id: 'id',
    perguntaUsuario: 'perguntaUsuario',
    queryMontada: 'queryMontada',
    respostaHumanizada: 'respostaHumanizada',
    feedbackUsuario: 'feedbackUsuario',
    criadoEm: 'criadoEm',
    atualizadoEm: 'atualizadoEm',
    hyperparameterArmId: 'hyperparameterArmId'
  };

  export type InteracaoIAScalarFieldEnum = (typeof InteracaoIAScalarFieldEnum)[keyof typeof InteracaoIAScalarFieldEnum]


  export const HyperparameterArmScalarFieldEnum: {
    id: 'id',
    modelName: 'modelName',
    version: 'version',
    temperature: 'temperature',
    topP: 'topP',
    topK: 'topK',
    maxOutputTokens: 'maxOutputTokens',
    responseMimeType: 'responseMimeType',
    successes: 'successes',
    failures: 'failures',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HyperparameterArmScalarFieldEnum = (typeof HyperparameterArmScalarFieldEnum)[keyof typeof HyperparameterArmScalarFieldEnum]


  export const ClientScalarFieldEnum: {
    id: 'id',
    companyName: 'companyName',
    cnpj: 'cnpj',
    phone: 'phone',
    address: 'address',
    email: 'email',
    password: 'password',
    contractDate: 'contractDate',
    status: 'status'
  };

  export type ClientScalarFieldEnum = (typeof ClientScalarFieldEnum)[keyof typeof ClientScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password: 'password',
    userType: 'userType',
    status: 'status',
    clientId: 'clientId',
    createdAt: 'createdAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const MachineScalarFieldEnum: {
    id: 'id',
    name: 'name',
    model: 'model',
    manufacturer: 'manufacturer',
    serialNumber: 'serialNumber',
    status: 'status',
    clientId: 'clientId',
    responsibleUserId: 'responsibleUserId',
    deviceId: 'deviceId'
  };

  export type MachineScalarFieldEnum = (typeof MachineScalarFieldEnum)[keyof typeof MachineScalarFieldEnum]


  export const UnifiedMachineStateScalarFieldEnum: {
    id: 'id',
    timestamp: 'timestamp',
    machineId: 'machineId',
    current: 'current',
    rpm: 'rpm',
    oilTemperature: 'oilTemperature',
    oilLevel: 'oilLevel',
    clusterPredict: 'clusterPredict',
    clusterStrength: 'clusterStrength',
    currentIsMissing: 'currentIsMissing',
    rpmIsMissing: 'rpmIsMissing',
    oilTemperatureIsMissing: 'oilTemperatureIsMissing',
    oilLevelIsMissing: 'oilLevelIsMissing'
  };

  export type UnifiedMachineStateScalarFieldEnum = (typeof UnifiedMachineStateScalarFieldEnum)[keyof typeof UnifiedMachineStateScalarFieldEnum]


  export const DeviceScalarFieldEnum: {
    id: 'id',
    nodeId: 'nodeId',
    description: 'description',
    status: 'status',
    lastHeartbeat: 'lastHeartbeat',
    gatewayId: 'gatewayId',
    clientId: 'clientId'
  };

  export type DeviceScalarFieldEnum = (typeof DeviceScalarFieldEnum)[keyof typeof DeviceScalarFieldEnum]


  export const GatewayScalarFieldEnum: {
    id: 'id',
    gatewayId: 'gatewayId',
    description: 'description',
    status: 'status',
    lastHeartbeat: 'lastHeartbeat',
    clientId: 'clientId'
  };

  export type GatewayScalarFieldEnum = (typeof GatewayScalarFieldEnum)[keyof typeof GatewayScalarFieldEnum]


  export const RpmReadingScalarFieldEnum: {
    id: 'id',
    timestamp: 'timestamp',
    rpm: 'rpm',
    machineId: 'machineId',
    userId: 'userId'
  };

  export type RpmReadingScalarFieldEnum = (typeof RpmReadingScalarFieldEnum)[keyof typeof RpmReadingScalarFieldEnum]


  export const OilTemperatureReadingScalarFieldEnum: {
    id: 'id',
    timestamp: 'timestamp',
    temperature: 'temperature',
    machineId: 'machineId',
    userId: 'userId'
  };

  export type OilTemperatureReadingScalarFieldEnum = (typeof OilTemperatureReadingScalarFieldEnum)[keyof typeof OilTemperatureReadingScalarFieldEnum]


  export const OilLevelReadingScalarFieldEnum: {
    id: 'id',
    timestamp: 'timestamp',
    level: 'level',
    machineId: 'machineId',
    userId: 'userId'
  };

  export type OilLevelReadingScalarFieldEnum = (typeof OilLevelReadingScalarFieldEnum)[keyof typeof OilLevelReadingScalarFieldEnum]


  export const CurrentReadingScalarFieldEnum: {
    id: 'id',
    timestamp: 'timestamp',
    current: 'current',
    machineId: 'machineId',
    userId: 'userId'
  };

  export type CurrentReadingScalarFieldEnum = (typeof CurrentReadingScalarFieldEnum)[keyof typeof CurrentReadingScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Status'
   */
  export type EnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status'>
    


  /**
   * Reference to a field of type 'Status[]'
   */
  export type ListEnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status[]'>
    


  /**
   * Reference to a field of type 'UserType'
   */
  export type EnumUserTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserType'>
    


  /**
   * Reference to a field of type 'UserType[]'
   */
  export type ListEnumUserTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserType[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DeviceStatus'
   */
  export type EnumDeviceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeviceStatus'>
    


  /**
   * Reference to a field of type 'DeviceStatus[]'
   */
  export type ListEnumDeviceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeviceStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type InteracaoIAWhereInput = {
    AND?: InteracaoIAWhereInput | InteracaoIAWhereInput[]
    OR?: InteracaoIAWhereInput[]
    NOT?: InteracaoIAWhereInput | InteracaoIAWhereInput[]
    id?: IntFilter<"InteracaoIA"> | number
    perguntaUsuario?: StringFilter<"InteracaoIA"> | string
    queryMontada?: StringFilter<"InteracaoIA"> | string
    respostaHumanizada?: StringFilter<"InteracaoIA"> | string
    feedbackUsuario?: IntNullableFilter<"InteracaoIA"> | number | null
    criadoEm?: DateTimeFilter<"InteracaoIA"> | Date | string
    atualizadoEm?: DateTimeFilter<"InteracaoIA"> | Date | string
    hyperparameterArmId?: StringFilter<"InteracaoIA"> | string
    hyperparameterArm?: XOR<HyperparameterArmScalarRelationFilter, HyperparameterArmWhereInput>
  }

  export type InteracaoIAOrderByWithRelationInput = {
    id?: SortOrder
    perguntaUsuario?: SortOrder
    queryMontada?: SortOrder
    respostaHumanizada?: SortOrder
    feedbackUsuario?: SortOrderInput | SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    hyperparameterArmId?: SortOrder
    hyperparameterArm?: HyperparameterArmOrderByWithRelationInput
  }

  export type InteracaoIAWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: InteracaoIAWhereInput | InteracaoIAWhereInput[]
    OR?: InteracaoIAWhereInput[]
    NOT?: InteracaoIAWhereInput | InteracaoIAWhereInput[]
    perguntaUsuario?: StringFilter<"InteracaoIA"> | string
    queryMontada?: StringFilter<"InteracaoIA"> | string
    respostaHumanizada?: StringFilter<"InteracaoIA"> | string
    feedbackUsuario?: IntNullableFilter<"InteracaoIA"> | number | null
    criadoEm?: DateTimeFilter<"InteracaoIA"> | Date | string
    atualizadoEm?: DateTimeFilter<"InteracaoIA"> | Date | string
    hyperparameterArmId?: StringFilter<"InteracaoIA"> | string
    hyperparameterArm?: XOR<HyperparameterArmScalarRelationFilter, HyperparameterArmWhereInput>
  }, "id">

  export type InteracaoIAOrderByWithAggregationInput = {
    id?: SortOrder
    perguntaUsuario?: SortOrder
    queryMontada?: SortOrder
    respostaHumanizada?: SortOrder
    feedbackUsuario?: SortOrderInput | SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    hyperparameterArmId?: SortOrder
    _count?: InteracaoIACountOrderByAggregateInput
    _avg?: InteracaoIAAvgOrderByAggregateInput
    _max?: InteracaoIAMaxOrderByAggregateInput
    _min?: InteracaoIAMinOrderByAggregateInput
    _sum?: InteracaoIASumOrderByAggregateInput
  }

  export type InteracaoIAScalarWhereWithAggregatesInput = {
    AND?: InteracaoIAScalarWhereWithAggregatesInput | InteracaoIAScalarWhereWithAggregatesInput[]
    OR?: InteracaoIAScalarWhereWithAggregatesInput[]
    NOT?: InteracaoIAScalarWhereWithAggregatesInput | InteracaoIAScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"InteracaoIA"> | number
    perguntaUsuario?: StringWithAggregatesFilter<"InteracaoIA"> | string
    queryMontada?: StringWithAggregatesFilter<"InteracaoIA"> | string
    respostaHumanizada?: StringWithAggregatesFilter<"InteracaoIA"> | string
    feedbackUsuario?: IntNullableWithAggregatesFilter<"InteracaoIA"> | number | null
    criadoEm?: DateTimeWithAggregatesFilter<"InteracaoIA"> | Date | string
    atualizadoEm?: DateTimeWithAggregatesFilter<"InteracaoIA"> | Date | string
    hyperparameterArmId?: StringWithAggregatesFilter<"InteracaoIA"> | string
  }

  export type HyperparameterArmWhereInput = {
    AND?: HyperparameterArmWhereInput | HyperparameterArmWhereInput[]
    OR?: HyperparameterArmWhereInput[]
    NOT?: HyperparameterArmWhereInput | HyperparameterArmWhereInput[]
    id?: StringFilter<"HyperparameterArm"> | string
    modelName?: StringNullableFilter<"HyperparameterArm"> | string | null
    version?: StringNullableFilter<"HyperparameterArm"> | string | null
    temperature?: FloatFilter<"HyperparameterArm"> | number
    topP?: FloatFilter<"HyperparameterArm"> | number
    topK?: IntFilter<"HyperparameterArm"> | number
    maxOutputTokens?: IntFilter<"HyperparameterArm"> | number
    responseMimeType?: StringFilter<"HyperparameterArm"> | string
    successes?: IntNullableFilter<"HyperparameterArm"> | number | null
    failures?: IntNullableFilter<"HyperparameterArm"> | number | null
    createdAt?: DateTimeFilter<"HyperparameterArm"> | Date | string
    updatedAt?: DateTimeFilter<"HyperparameterArm"> | Date | string
    interacoes?: InteracaoIAListRelationFilter
  }

  export type HyperparameterArmOrderByWithRelationInput = {
    id?: SortOrder
    modelName?: SortOrderInput | SortOrder
    version?: SortOrderInput | SortOrder
    temperature?: SortOrder
    topP?: SortOrder
    topK?: SortOrder
    maxOutputTokens?: SortOrder
    responseMimeType?: SortOrder
    successes?: SortOrderInput | SortOrder
    failures?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    interacoes?: InteracaoIAOrderByRelationAggregateInput
  }

  export type HyperparameterArmWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HyperparameterArmWhereInput | HyperparameterArmWhereInput[]
    OR?: HyperparameterArmWhereInput[]
    NOT?: HyperparameterArmWhereInput | HyperparameterArmWhereInput[]
    modelName?: StringNullableFilter<"HyperparameterArm"> | string | null
    version?: StringNullableFilter<"HyperparameterArm"> | string | null
    temperature?: FloatFilter<"HyperparameterArm"> | number
    topP?: FloatFilter<"HyperparameterArm"> | number
    topK?: IntFilter<"HyperparameterArm"> | number
    maxOutputTokens?: IntFilter<"HyperparameterArm"> | number
    responseMimeType?: StringFilter<"HyperparameterArm"> | string
    successes?: IntNullableFilter<"HyperparameterArm"> | number | null
    failures?: IntNullableFilter<"HyperparameterArm"> | number | null
    createdAt?: DateTimeFilter<"HyperparameterArm"> | Date | string
    updatedAt?: DateTimeFilter<"HyperparameterArm"> | Date | string
    interacoes?: InteracaoIAListRelationFilter
  }, "id">

  export type HyperparameterArmOrderByWithAggregationInput = {
    id?: SortOrder
    modelName?: SortOrderInput | SortOrder
    version?: SortOrderInput | SortOrder
    temperature?: SortOrder
    topP?: SortOrder
    topK?: SortOrder
    maxOutputTokens?: SortOrder
    responseMimeType?: SortOrder
    successes?: SortOrderInput | SortOrder
    failures?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HyperparameterArmCountOrderByAggregateInput
    _avg?: HyperparameterArmAvgOrderByAggregateInput
    _max?: HyperparameterArmMaxOrderByAggregateInput
    _min?: HyperparameterArmMinOrderByAggregateInput
    _sum?: HyperparameterArmSumOrderByAggregateInput
  }

  export type HyperparameterArmScalarWhereWithAggregatesInput = {
    AND?: HyperparameterArmScalarWhereWithAggregatesInput | HyperparameterArmScalarWhereWithAggregatesInput[]
    OR?: HyperparameterArmScalarWhereWithAggregatesInput[]
    NOT?: HyperparameterArmScalarWhereWithAggregatesInput | HyperparameterArmScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HyperparameterArm"> | string
    modelName?: StringNullableWithAggregatesFilter<"HyperparameterArm"> | string | null
    version?: StringNullableWithAggregatesFilter<"HyperparameterArm"> | string | null
    temperature?: FloatWithAggregatesFilter<"HyperparameterArm"> | number
    topP?: FloatWithAggregatesFilter<"HyperparameterArm"> | number
    topK?: IntWithAggregatesFilter<"HyperparameterArm"> | number
    maxOutputTokens?: IntWithAggregatesFilter<"HyperparameterArm"> | number
    responseMimeType?: StringWithAggregatesFilter<"HyperparameterArm"> | string
    successes?: IntNullableWithAggregatesFilter<"HyperparameterArm"> | number | null
    failures?: IntNullableWithAggregatesFilter<"HyperparameterArm"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"HyperparameterArm"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"HyperparameterArm"> | Date | string
  }

  export type ClientWhereInput = {
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    id?: IntFilter<"Client"> | number
    companyName?: StringFilter<"Client"> | string
    cnpj?: StringFilter<"Client"> | string
    phone?: StringNullableFilter<"Client"> | string | null
    address?: StringNullableFilter<"Client"> | string | null
    email?: StringFilter<"Client"> | string
    password?: StringFilter<"Client"> | string
    contractDate?: DateTimeFilter<"Client"> | Date | string
    status?: EnumStatusFilter<"Client"> | $Enums.Status
    machines?: MachineListRelationFilter
    users?: UserListRelationFilter
    devices?: DeviceListRelationFilter
    gateways?: GatewayListRelationFilter
  }

  export type ClientOrderByWithRelationInput = {
    id?: SortOrder
    companyName?: SortOrder
    cnpj?: SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    email?: SortOrder
    password?: SortOrder
    contractDate?: SortOrder
    status?: SortOrder
    machines?: MachineOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
    devices?: DeviceOrderByRelationAggregateInput
    gateways?: GatewayOrderByRelationAggregateInput
  }

  export type ClientWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    cnpj?: string
    email?: string
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    companyName?: StringFilter<"Client"> | string
    phone?: StringNullableFilter<"Client"> | string | null
    address?: StringNullableFilter<"Client"> | string | null
    password?: StringFilter<"Client"> | string
    contractDate?: DateTimeFilter<"Client"> | Date | string
    status?: EnumStatusFilter<"Client"> | $Enums.Status
    machines?: MachineListRelationFilter
    users?: UserListRelationFilter
    devices?: DeviceListRelationFilter
    gateways?: GatewayListRelationFilter
  }, "id" | "cnpj" | "email">

  export type ClientOrderByWithAggregationInput = {
    id?: SortOrder
    companyName?: SortOrder
    cnpj?: SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    email?: SortOrder
    password?: SortOrder
    contractDate?: SortOrder
    status?: SortOrder
    _count?: ClientCountOrderByAggregateInput
    _avg?: ClientAvgOrderByAggregateInput
    _max?: ClientMaxOrderByAggregateInput
    _min?: ClientMinOrderByAggregateInput
    _sum?: ClientSumOrderByAggregateInput
  }

  export type ClientScalarWhereWithAggregatesInput = {
    AND?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    OR?: ClientScalarWhereWithAggregatesInput[]
    NOT?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Client"> | number
    companyName?: StringWithAggregatesFilter<"Client"> | string
    cnpj?: StringWithAggregatesFilter<"Client"> | string
    phone?: StringNullableWithAggregatesFilter<"Client"> | string | null
    address?: StringNullableWithAggregatesFilter<"Client"> | string | null
    email?: StringWithAggregatesFilter<"Client"> | string
    password?: StringWithAggregatesFilter<"Client"> | string
    contractDate?: DateTimeWithAggregatesFilter<"Client"> | Date | string
    status?: EnumStatusWithAggregatesFilter<"Client"> | $Enums.Status
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    userType?: EnumUserTypeFilter<"User"> | $Enums.UserType
    status?: EnumStatusFilter<"User"> | $Enums.Status
    clientId?: IntFilter<"User"> | number
    createdAt?: DateTimeFilter<"User"> | Date | string
    currentReadings?: CurrentReadingListRelationFilter
    responsibleMachines?: MachineListRelationFilter
    oilLevelReadings?: OilLevelReadingListRelationFilter
    oilTemperatureReadings?: OilTemperatureReadingListRelationFilter
    rpmReadings?: RpmReadingListRelationFilter
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    userType?: SortOrder
    status?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    currentReadings?: CurrentReadingOrderByRelationAggregateInput
    responsibleMachines?: MachineOrderByRelationAggregateInput
    oilLevelReadings?: OilLevelReadingOrderByRelationAggregateInput
    oilTemperatureReadings?: OilTemperatureReadingOrderByRelationAggregateInput
    rpmReadings?: RpmReadingOrderByRelationAggregateInput
    client?: ClientOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    userType?: EnumUserTypeFilter<"User"> | $Enums.UserType
    status?: EnumStatusFilter<"User"> | $Enums.Status
    clientId?: IntFilter<"User"> | number
    createdAt?: DateTimeFilter<"User"> | Date | string
    currentReadings?: CurrentReadingListRelationFilter
    responsibleMachines?: MachineListRelationFilter
    oilLevelReadings?: OilLevelReadingListRelationFilter
    oilTemperatureReadings?: OilTemperatureReadingListRelationFilter
    rpmReadings?: RpmReadingListRelationFilter
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    userType?: SortOrder
    status?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    userType?: EnumUserTypeWithAggregatesFilter<"User"> | $Enums.UserType
    status?: EnumStatusWithAggregatesFilter<"User"> | $Enums.Status
    clientId?: IntWithAggregatesFilter<"User"> | number
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type MachineWhereInput = {
    AND?: MachineWhereInput | MachineWhereInput[]
    OR?: MachineWhereInput[]
    NOT?: MachineWhereInput | MachineWhereInput[]
    id?: IntFilter<"Machine"> | number
    name?: StringFilter<"Machine"> | string
    model?: StringNullableFilter<"Machine"> | string | null
    manufacturer?: StringNullableFilter<"Machine"> | string | null
    serialNumber?: StringFilter<"Machine"> | string
    status?: EnumStatusFilter<"Machine"> | $Enums.Status
    clientId?: IntFilter<"Machine"> | number
    responsibleUserId?: IntNullableFilter<"Machine"> | number | null
    deviceId?: IntNullableFilter<"Machine"> | number | null
    UnifiedMachineState?: UnifiedMachineStateListRelationFilter
    currentReadings?: CurrentReadingListRelationFilter
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    device?: XOR<DeviceNullableScalarRelationFilter, DeviceWhereInput> | null
    responsibleUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    oilLevelReadings?: OilLevelReadingListRelationFilter
    oilTemperatureReadings?: OilTemperatureReadingListRelationFilter
    rpmReadings?: RpmReadingListRelationFilter
  }

  export type MachineOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    model?: SortOrderInput | SortOrder
    manufacturer?: SortOrderInput | SortOrder
    serialNumber?: SortOrder
    status?: SortOrder
    clientId?: SortOrder
    responsibleUserId?: SortOrderInput | SortOrder
    deviceId?: SortOrderInput | SortOrder
    UnifiedMachineState?: UnifiedMachineStateOrderByRelationAggregateInput
    currentReadings?: CurrentReadingOrderByRelationAggregateInput
    client?: ClientOrderByWithRelationInput
    device?: DeviceOrderByWithRelationInput
    responsibleUser?: UserOrderByWithRelationInput
    oilLevelReadings?: OilLevelReadingOrderByRelationAggregateInput
    oilTemperatureReadings?: OilTemperatureReadingOrderByRelationAggregateInput
    rpmReadings?: RpmReadingOrderByRelationAggregateInput
  }

  export type MachineWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    serialNumber?: string
    deviceId?: number
    AND?: MachineWhereInput | MachineWhereInput[]
    OR?: MachineWhereInput[]
    NOT?: MachineWhereInput | MachineWhereInput[]
    name?: StringFilter<"Machine"> | string
    model?: StringNullableFilter<"Machine"> | string | null
    manufacturer?: StringNullableFilter<"Machine"> | string | null
    status?: EnumStatusFilter<"Machine"> | $Enums.Status
    clientId?: IntFilter<"Machine"> | number
    responsibleUserId?: IntNullableFilter<"Machine"> | number | null
    UnifiedMachineState?: UnifiedMachineStateListRelationFilter
    currentReadings?: CurrentReadingListRelationFilter
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    device?: XOR<DeviceNullableScalarRelationFilter, DeviceWhereInput> | null
    responsibleUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    oilLevelReadings?: OilLevelReadingListRelationFilter
    oilTemperatureReadings?: OilTemperatureReadingListRelationFilter
    rpmReadings?: RpmReadingListRelationFilter
  }, "id" | "serialNumber" | "deviceId">

  export type MachineOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    model?: SortOrderInput | SortOrder
    manufacturer?: SortOrderInput | SortOrder
    serialNumber?: SortOrder
    status?: SortOrder
    clientId?: SortOrder
    responsibleUserId?: SortOrderInput | SortOrder
    deviceId?: SortOrderInput | SortOrder
    _count?: MachineCountOrderByAggregateInput
    _avg?: MachineAvgOrderByAggregateInput
    _max?: MachineMaxOrderByAggregateInput
    _min?: MachineMinOrderByAggregateInput
    _sum?: MachineSumOrderByAggregateInput
  }

  export type MachineScalarWhereWithAggregatesInput = {
    AND?: MachineScalarWhereWithAggregatesInput | MachineScalarWhereWithAggregatesInput[]
    OR?: MachineScalarWhereWithAggregatesInput[]
    NOT?: MachineScalarWhereWithAggregatesInput | MachineScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Machine"> | number
    name?: StringWithAggregatesFilter<"Machine"> | string
    model?: StringNullableWithAggregatesFilter<"Machine"> | string | null
    manufacturer?: StringNullableWithAggregatesFilter<"Machine"> | string | null
    serialNumber?: StringWithAggregatesFilter<"Machine"> | string
    status?: EnumStatusWithAggregatesFilter<"Machine"> | $Enums.Status
    clientId?: IntWithAggregatesFilter<"Machine"> | number
    responsibleUserId?: IntNullableWithAggregatesFilter<"Machine"> | number | null
    deviceId?: IntNullableWithAggregatesFilter<"Machine"> | number | null
  }

  export type UnifiedMachineStateWhereInput = {
    AND?: UnifiedMachineStateWhereInput | UnifiedMachineStateWhereInput[]
    OR?: UnifiedMachineStateWhereInput[]
    NOT?: UnifiedMachineStateWhereInput | UnifiedMachineStateWhereInput[]
    id?: StringFilter<"UnifiedMachineState"> | string
    timestamp?: DateTimeFilter<"UnifiedMachineState"> | Date | string
    machineId?: IntFilter<"UnifiedMachineState"> | number
    current?: FloatNullableFilter<"UnifiedMachineState"> | number | null
    rpm?: IntNullableFilter<"UnifiedMachineState"> | number | null
    oilTemperature?: FloatNullableFilter<"UnifiedMachineState"> | number | null
    oilLevel?: FloatNullableFilter<"UnifiedMachineState"> | number | null
    clusterPredict?: IntNullableFilter<"UnifiedMachineState"> | number | null
    clusterStrength?: FloatNullableFilter<"UnifiedMachineState"> | number | null
    currentIsMissing?: BoolFilter<"UnifiedMachineState"> | boolean
    rpmIsMissing?: BoolFilter<"UnifiedMachineState"> | boolean
    oilTemperatureIsMissing?: BoolFilter<"UnifiedMachineState"> | boolean
    oilLevelIsMissing?: BoolFilter<"UnifiedMachineState"> | boolean
    machine?: XOR<MachineScalarRelationFilter, MachineWhereInput>
  }

  export type UnifiedMachineStateOrderByWithRelationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    machineId?: SortOrder
    current?: SortOrderInput | SortOrder
    rpm?: SortOrderInput | SortOrder
    oilTemperature?: SortOrderInput | SortOrder
    oilLevel?: SortOrderInput | SortOrder
    clusterPredict?: SortOrderInput | SortOrder
    clusterStrength?: SortOrderInput | SortOrder
    currentIsMissing?: SortOrder
    rpmIsMissing?: SortOrder
    oilTemperatureIsMissing?: SortOrder
    oilLevelIsMissing?: SortOrder
    machine?: MachineOrderByWithRelationInput
  }

  export type UnifiedMachineStateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UnifiedMachineStateWhereInput | UnifiedMachineStateWhereInput[]
    OR?: UnifiedMachineStateWhereInput[]
    NOT?: UnifiedMachineStateWhereInput | UnifiedMachineStateWhereInput[]
    timestamp?: DateTimeFilter<"UnifiedMachineState"> | Date | string
    machineId?: IntFilter<"UnifiedMachineState"> | number
    current?: FloatNullableFilter<"UnifiedMachineState"> | number | null
    rpm?: IntNullableFilter<"UnifiedMachineState"> | number | null
    oilTemperature?: FloatNullableFilter<"UnifiedMachineState"> | number | null
    oilLevel?: FloatNullableFilter<"UnifiedMachineState"> | number | null
    clusterPredict?: IntNullableFilter<"UnifiedMachineState"> | number | null
    clusterStrength?: FloatNullableFilter<"UnifiedMachineState"> | number | null
    currentIsMissing?: BoolFilter<"UnifiedMachineState"> | boolean
    rpmIsMissing?: BoolFilter<"UnifiedMachineState"> | boolean
    oilTemperatureIsMissing?: BoolFilter<"UnifiedMachineState"> | boolean
    oilLevelIsMissing?: BoolFilter<"UnifiedMachineState"> | boolean
    machine?: XOR<MachineScalarRelationFilter, MachineWhereInput>
  }, "id">

  export type UnifiedMachineStateOrderByWithAggregationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    machineId?: SortOrder
    current?: SortOrderInput | SortOrder
    rpm?: SortOrderInput | SortOrder
    oilTemperature?: SortOrderInput | SortOrder
    oilLevel?: SortOrderInput | SortOrder
    clusterPredict?: SortOrderInput | SortOrder
    clusterStrength?: SortOrderInput | SortOrder
    currentIsMissing?: SortOrder
    rpmIsMissing?: SortOrder
    oilTemperatureIsMissing?: SortOrder
    oilLevelIsMissing?: SortOrder
    _count?: UnifiedMachineStateCountOrderByAggregateInput
    _avg?: UnifiedMachineStateAvgOrderByAggregateInput
    _max?: UnifiedMachineStateMaxOrderByAggregateInput
    _min?: UnifiedMachineStateMinOrderByAggregateInput
    _sum?: UnifiedMachineStateSumOrderByAggregateInput
  }

  export type UnifiedMachineStateScalarWhereWithAggregatesInput = {
    AND?: UnifiedMachineStateScalarWhereWithAggregatesInput | UnifiedMachineStateScalarWhereWithAggregatesInput[]
    OR?: UnifiedMachineStateScalarWhereWithAggregatesInput[]
    NOT?: UnifiedMachineStateScalarWhereWithAggregatesInput | UnifiedMachineStateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UnifiedMachineState"> | string
    timestamp?: DateTimeWithAggregatesFilter<"UnifiedMachineState"> | Date | string
    machineId?: IntWithAggregatesFilter<"UnifiedMachineState"> | number
    current?: FloatNullableWithAggregatesFilter<"UnifiedMachineState"> | number | null
    rpm?: IntNullableWithAggregatesFilter<"UnifiedMachineState"> | number | null
    oilTemperature?: FloatNullableWithAggregatesFilter<"UnifiedMachineState"> | number | null
    oilLevel?: FloatNullableWithAggregatesFilter<"UnifiedMachineState"> | number | null
    clusterPredict?: IntNullableWithAggregatesFilter<"UnifiedMachineState"> | number | null
    clusterStrength?: FloatNullableWithAggregatesFilter<"UnifiedMachineState"> | number | null
    currentIsMissing?: BoolWithAggregatesFilter<"UnifiedMachineState"> | boolean
    rpmIsMissing?: BoolWithAggregatesFilter<"UnifiedMachineState"> | boolean
    oilTemperatureIsMissing?: BoolWithAggregatesFilter<"UnifiedMachineState"> | boolean
    oilLevelIsMissing?: BoolWithAggregatesFilter<"UnifiedMachineState"> | boolean
  }

  export type DeviceWhereInput = {
    AND?: DeviceWhereInput | DeviceWhereInput[]
    OR?: DeviceWhereInput[]
    NOT?: DeviceWhereInput | DeviceWhereInput[]
    id?: IntFilter<"Device"> | number
    nodeId?: StringFilter<"Device"> | string
    description?: StringNullableFilter<"Device"> | string | null
    status?: EnumDeviceStatusFilter<"Device"> | $Enums.DeviceStatus
    lastHeartbeat?: DateTimeFilter<"Device"> | Date | string
    gatewayId?: IntNullableFilter<"Device"> | number | null
    clientId?: IntFilter<"Device"> | number
    gateway?: XOR<GatewayNullableScalarRelationFilter, GatewayWhereInput> | null
    machine?: XOR<MachineNullableScalarRelationFilter, MachineWhereInput> | null
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
  }

  export type DeviceOrderByWithRelationInput = {
    id?: SortOrder
    nodeId?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    lastHeartbeat?: SortOrder
    gatewayId?: SortOrderInput | SortOrder
    clientId?: SortOrder
    gateway?: GatewayOrderByWithRelationInput
    machine?: MachineOrderByWithRelationInput
    client?: ClientOrderByWithRelationInput
  }

  export type DeviceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nodeId?: string
    AND?: DeviceWhereInput | DeviceWhereInput[]
    OR?: DeviceWhereInput[]
    NOT?: DeviceWhereInput | DeviceWhereInput[]
    description?: StringNullableFilter<"Device"> | string | null
    status?: EnumDeviceStatusFilter<"Device"> | $Enums.DeviceStatus
    lastHeartbeat?: DateTimeFilter<"Device"> | Date | string
    gatewayId?: IntNullableFilter<"Device"> | number | null
    clientId?: IntFilter<"Device"> | number
    gateway?: XOR<GatewayNullableScalarRelationFilter, GatewayWhereInput> | null
    machine?: XOR<MachineNullableScalarRelationFilter, MachineWhereInput> | null
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
  }, "id" | "nodeId">

  export type DeviceOrderByWithAggregationInput = {
    id?: SortOrder
    nodeId?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    lastHeartbeat?: SortOrder
    gatewayId?: SortOrderInput | SortOrder
    clientId?: SortOrder
    _count?: DeviceCountOrderByAggregateInput
    _avg?: DeviceAvgOrderByAggregateInput
    _max?: DeviceMaxOrderByAggregateInput
    _min?: DeviceMinOrderByAggregateInput
    _sum?: DeviceSumOrderByAggregateInput
  }

  export type DeviceScalarWhereWithAggregatesInput = {
    AND?: DeviceScalarWhereWithAggregatesInput | DeviceScalarWhereWithAggregatesInput[]
    OR?: DeviceScalarWhereWithAggregatesInput[]
    NOT?: DeviceScalarWhereWithAggregatesInput | DeviceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Device"> | number
    nodeId?: StringWithAggregatesFilter<"Device"> | string
    description?: StringNullableWithAggregatesFilter<"Device"> | string | null
    status?: EnumDeviceStatusWithAggregatesFilter<"Device"> | $Enums.DeviceStatus
    lastHeartbeat?: DateTimeWithAggregatesFilter<"Device"> | Date | string
    gatewayId?: IntNullableWithAggregatesFilter<"Device"> | number | null
    clientId?: IntWithAggregatesFilter<"Device"> | number
  }

  export type GatewayWhereInput = {
    AND?: GatewayWhereInput | GatewayWhereInput[]
    OR?: GatewayWhereInput[]
    NOT?: GatewayWhereInput | GatewayWhereInput[]
    id?: IntFilter<"Gateway"> | number
    gatewayId?: StringFilter<"Gateway"> | string
    description?: StringNullableFilter<"Gateway"> | string | null
    status?: EnumDeviceStatusFilter<"Gateway"> | $Enums.DeviceStatus
    lastHeartbeat?: DateTimeFilter<"Gateway"> | Date | string
    clientId?: IntFilter<"Gateway"> | number
    responsibleFor?: DeviceListRelationFilter
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
  }

  export type GatewayOrderByWithRelationInput = {
    id?: SortOrder
    gatewayId?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    lastHeartbeat?: SortOrder
    clientId?: SortOrder
    responsibleFor?: DeviceOrderByRelationAggregateInput
    client?: ClientOrderByWithRelationInput
  }

  export type GatewayWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    gatewayId?: string
    AND?: GatewayWhereInput | GatewayWhereInput[]
    OR?: GatewayWhereInput[]
    NOT?: GatewayWhereInput | GatewayWhereInput[]
    description?: StringNullableFilter<"Gateway"> | string | null
    status?: EnumDeviceStatusFilter<"Gateway"> | $Enums.DeviceStatus
    lastHeartbeat?: DateTimeFilter<"Gateway"> | Date | string
    clientId?: IntFilter<"Gateway"> | number
    responsibleFor?: DeviceListRelationFilter
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
  }, "id" | "gatewayId">

  export type GatewayOrderByWithAggregationInput = {
    id?: SortOrder
    gatewayId?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    lastHeartbeat?: SortOrder
    clientId?: SortOrder
    _count?: GatewayCountOrderByAggregateInput
    _avg?: GatewayAvgOrderByAggregateInput
    _max?: GatewayMaxOrderByAggregateInput
    _min?: GatewayMinOrderByAggregateInput
    _sum?: GatewaySumOrderByAggregateInput
  }

  export type GatewayScalarWhereWithAggregatesInput = {
    AND?: GatewayScalarWhereWithAggregatesInput | GatewayScalarWhereWithAggregatesInput[]
    OR?: GatewayScalarWhereWithAggregatesInput[]
    NOT?: GatewayScalarWhereWithAggregatesInput | GatewayScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Gateway"> | number
    gatewayId?: StringWithAggregatesFilter<"Gateway"> | string
    description?: StringNullableWithAggregatesFilter<"Gateway"> | string | null
    status?: EnumDeviceStatusWithAggregatesFilter<"Gateway"> | $Enums.DeviceStatus
    lastHeartbeat?: DateTimeWithAggregatesFilter<"Gateway"> | Date | string
    clientId?: IntWithAggregatesFilter<"Gateway"> | number
  }

  export type RpmReadingWhereInput = {
    AND?: RpmReadingWhereInput | RpmReadingWhereInput[]
    OR?: RpmReadingWhereInput[]
    NOT?: RpmReadingWhereInput | RpmReadingWhereInput[]
    id?: IntFilter<"RpmReading"> | number
    timestamp?: DateTimeFilter<"RpmReading"> | Date | string
    rpm?: IntFilter<"RpmReading"> | number
    machineId?: IntFilter<"RpmReading"> | number
    userId?: IntNullableFilter<"RpmReading"> | number | null
    machine?: XOR<MachineScalarRelationFilter, MachineWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type RpmReadingOrderByWithRelationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    rpm?: SortOrder
    machineId?: SortOrder
    userId?: SortOrderInput | SortOrder
    machine?: MachineOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type RpmReadingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RpmReadingWhereInput | RpmReadingWhereInput[]
    OR?: RpmReadingWhereInput[]
    NOT?: RpmReadingWhereInput | RpmReadingWhereInput[]
    timestamp?: DateTimeFilter<"RpmReading"> | Date | string
    rpm?: IntFilter<"RpmReading"> | number
    machineId?: IntFilter<"RpmReading"> | number
    userId?: IntNullableFilter<"RpmReading"> | number | null
    machine?: XOR<MachineScalarRelationFilter, MachineWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type RpmReadingOrderByWithAggregationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    rpm?: SortOrder
    machineId?: SortOrder
    userId?: SortOrderInput | SortOrder
    _count?: RpmReadingCountOrderByAggregateInput
    _avg?: RpmReadingAvgOrderByAggregateInput
    _max?: RpmReadingMaxOrderByAggregateInput
    _min?: RpmReadingMinOrderByAggregateInput
    _sum?: RpmReadingSumOrderByAggregateInput
  }

  export type RpmReadingScalarWhereWithAggregatesInput = {
    AND?: RpmReadingScalarWhereWithAggregatesInput | RpmReadingScalarWhereWithAggregatesInput[]
    OR?: RpmReadingScalarWhereWithAggregatesInput[]
    NOT?: RpmReadingScalarWhereWithAggregatesInput | RpmReadingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RpmReading"> | number
    timestamp?: DateTimeWithAggregatesFilter<"RpmReading"> | Date | string
    rpm?: IntWithAggregatesFilter<"RpmReading"> | number
    machineId?: IntWithAggregatesFilter<"RpmReading"> | number
    userId?: IntNullableWithAggregatesFilter<"RpmReading"> | number | null
  }

  export type OilTemperatureReadingWhereInput = {
    AND?: OilTemperatureReadingWhereInput | OilTemperatureReadingWhereInput[]
    OR?: OilTemperatureReadingWhereInput[]
    NOT?: OilTemperatureReadingWhereInput | OilTemperatureReadingWhereInput[]
    id?: IntFilter<"OilTemperatureReading"> | number
    timestamp?: DateTimeFilter<"OilTemperatureReading"> | Date | string
    temperature?: FloatFilter<"OilTemperatureReading"> | number
    machineId?: IntFilter<"OilTemperatureReading"> | number
    userId?: IntNullableFilter<"OilTemperatureReading"> | number | null
    machine?: XOR<MachineScalarRelationFilter, MachineWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type OilTemperatureReadingOrderByWithRelationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    temperature?: SortOrder
    machineId?: SortOrder
    userId?: SortOrderInput | SortOrder
    machine?: MachineOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type OilTemperatureReadingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OilTemperatureReadingWhereInput | OilTemperatureReadingWhereInput[]
    OR?: OilTemperatureReadingWhereInput[]
    NOT?: OilTemperatureReadingWhereInput | OilTemperatureReadingWhereInput[]
    timestamp?: DateTimeFilter<"OilTemperatureReading"> | Date | string
    temperature?: FloatFilter<"OilTemperatureReading"> | number
    machineId?: IntFilter<"OilTemperatureReading"> | number
    userId?: IntNullableFilter<"OilTemperatureReading"> | number | null
    machine?: XOR<MachineScalarRelationFilter, MachineWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type OilTemperatureReadingOrderByWithAggregationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    temperature?: SortOrder
    machineId?: SortOrder
    userId?: SortOrderInput | SortOrder
    _count?: OilTemperatureReadingCountOrderByAggregateInput
    _avg?: OilTemperatureReadingAvgOrderByAggregateInput
    _max?: OilTemperatureReadingMaxOrderByAggregateInput
    _min?: OilTemperatureReadingMinOrderByAggregateInput
    _sum?: OilTemperatureReadingSumOrderByAggregateInput
  }

  export type OilTemperatureReadingScalarWhereWithAggregatesInput = {
    AND?: OilTemperatureReadingScalarWhereWithAggregatesInput | OilTemperatureReadingScalarWhereWithAggregatesInput[]
    OR?: OilTemperatureReadingScalarWhereWithAggregatesInput[]
    NOT?: OilTemperatureReadingScalarWhereWithAggregatesInput | OilTemperatureReadingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OilTemperatureReading"> | number
    timestamp?: DateTimeWithAggregatesFilter<"OilTemperatureReading"> | Date | string
    temperature?: FloatWithAggregatesFilter<"OilTemperatureReading"> | number
    machineId?: IntWithAggregatesFilter<"OilTemperatureReading"> | number
    userId?: IntNullableWithAggregatesFilter<"OilTemperatureReading"> | number | null
  }

  export type OilLevelReadingWhereInput = {
    AND?: OilLevelReadingWhereInput | OilLevelReadingWhereInput[]
    OR?: OilLevelReadingWhereInput[]
    NOT?: OilLevelReadingWhereInput | OilLevelReadingWhereInput[]
    id?: IntFilter<"OilLevelReading"> | number
    timestamp?: DateTimeFilter<"OilLevelReading"> | Date | string
    level?: FloatFilter<"OilLevelReading"> | number
    machineId?: IntFilter<"OilLevelReading"> | number
    userId?: IntNullableFilter<"OilLevelReading"> | number | null
    machine?: XOR<MachineScalarRelationFilter, MachineWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type OilLevelReadingOrderByWithRelationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    level?: SortOrder
    machineId?: SortOrder
    userId?: SortOrderInput | SortOrder
    machine?: MachineOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type OilLevelReadingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OilLevelReadingWhereInput | OilLevelReadingWhereInput[]
    OR?: OilLevelReadingWhereInput[]
    NOT?: OilLevelReadingWhereInput | OilLevelReadingWhereInput[]
    timestamp?: DateTimeFilter<"OilLevelReading"> | Date | string
    level?: FloatFilter<"OilLevelReading"> | number
    machineId?: IntFilter<"OilLevelReading"> | number
    userId?: IntNullableFilter<"OilLevelReading"> | number | null
    machine?: XOR<MachineScalarRelationFilter, MachineWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type OilLevelReadingOrderByWithAggregationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    level?: SortOrder
    machineId?: SortOrder
    userId?: SortOrderInput | SortOrder
    _count?: OilLevelReadingCountOrderByAggregateInput
    _avg?: OilLevelReadingAvgOrderByAggregateInput
    _max?: OilLevelReadingMaxOrderByAggregateInput
    _min?: OilLevelReadingMinOrderByAggregateInput
    _sum?: OilLevelReadingSumOrderByAggregateInput
  }

  export type OilLevelReadingScalarWhereWithAggregatesInput = {
    AND?: OilLevelReadingScalarWhereWithAggregatesInput | OilLevelReadingScalarWhereWithAggregatesInput[]
    OR?: OilLevelReadingScalarWhereWithAggregatesInput[]
    NOT?: OilLevelReadingScalarWhereWithAggregatesInput | OilLevelReadingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OilLevelReading"> | number
    timestamp?: DateTimeWithAggregatesFilter<"OilLevelReading"> | Date | string
    level?: FloatWithAggregatesFilter<"OilLevelReading"> | number
    machineId?: IntWithAggregatesFilter<"OilLevelReading"> | number
    userId?: IntNullableWithAggregatesFilter<"OilLevelReading"> | number | null
  }

  export type CurrentReadingWhereInput = {
    AND?: CurrentReadingWhereInput | CurrentReadingWhereInput[]
    OR?: CurrentReadingWhereInput[]
    NOT?: CurrentReadingWhereInput | CurrentReadingWhereInput[]
    id?: IntFilter<"CurrentReading"> | number
    timestamp?: DateTimeFilter<"CurrentReading"> | Date | string
    current?: FloatFilter<"CurrentReading"> | number
    machineId?: IntFilter<"CurrentReading"> | number
    userId?: IntNullableFilter<"CurrentReading"> | number | null
    machine?: XOR<MachineScalarRelationFilter, MachineWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type CurrentReadingOrderByWithRelationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    current?: SortOrder
    machineId?: SortOrder
    userId?: SortOrderInput | SortOrder
    machine?: MachineOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type CurrentReadingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CurrentReadingWhereInput | CurrentReadingWhereInput[]
    OR?: CurrentReadingWhereInput[]
    NOT?: CurrentReadingWhereInput | CurrentReadingWhereInput[]
    timestamp?: DateTimeFilter<"CurrentReading"> | Date | string
    current?: FloatFilter<"CurrentReading"> | number
    machineId?: IntFilter<"CurrentReading"> | number
    userId?: IntNullableFilter<"CurrentReading"> | number | null
    machine?: XOR<MachineScalarRelationFilter, MachineWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type CurrentReadingOrderByWithAggregationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    current?: SortOrder
    machineId?: SortOrder
    userId?: SortOrderInput | SortOrder
    _count?: CurrentReadingCountOrderByAggregateInput
    _avg?: CurrentReadingAvgOrderByAggregateInput
    _max?: CurrentReadingMaxOrderByAggregateInput
    _min?: CurrentReadingMinOrderByAggregateInput
    _sum?: CurrentReadingSumOrderByAggregateInput
  }

  export type CurrentReadingScalarWhereWithAggregatesInput = {
    AND?: CurrentReadingScalarWhereWithAggregatesInput | CurrentReadingScalarWhereWithAggregatesInput[]
    OR?: CurrentReadingScalarWhereWithAggregatesInput[]
    NOT?: CurrentReadingScalarWhereWithAggregatesInput | CurrentReadingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CurrentReading"> | number
    timestamp?: DateTimeWithAggregatesFilter<"CurrentReading"> | Date | string
    current?: FloatWithAggregatesFilter<"CurrentReading"> | number
    machineId?: IntWithAggregatesFilter<"CurrentReading"> | number
    userId?: IntNullableWithAggregatesFilter<"CurrentReading"> | number | null
  }

  export type InteracaoIACreateInput = {
    perguntaUsuario: string
    queryMontada: string
    respostaHumanizada: string
    feedbackUsuario?: number | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    hyperparameterArm: HyperparameterArmCreateNestedOneWithoutInteracoesInput
  }

  export type InteracaoIAUncheckedCreateInput = {
    id?: number
    perguntaUsuario: string
    queryMontada: string
    respostaHumanizada: string
    feedbackUsuario?: number | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    hyperparameterArmId: string
  }

  export type InteracaoIAUpdateInput = {
    perguntaUsuario?: StringFieldUpdateOperationsInput | string
    queryMontada?: StringFieldUpdateOperationsInput | string
    respostaHumanizada?: StringFieldUpdateOperationsInput | string
    feedbackUsuario?: NullableIntFieldUpdateOperationsInput | number | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    hyperparameterArm?: HyperparameterArmUpdateOneRequiredWithoutInteracoesNestedInput
  }

  export type InteracaoIAUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    perguntaUsuario?: StringFieldUpdateOperationsInput | string
    queryMontada?: StringFieldUpdateOperationsInput | string
    respostaHumanizada?: StringFieldUpdateOperationsInput | string
    feedbackUsuario?: NullableIntFieldUpdateOperationsInput | number | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    hyperparameterArmId?: StringFieldUpdateOperationsInput | string
  }

  export type InteracaoIACreateManyInput = {
    id?: number
    perguntaUsuario: string
    queryMontada: string
    respostaHumanizada: string
    feedbackUsuario?: number | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    hyperparameterArmId: string
  }

  export type InteracaoIAUpdateManyMutationInput = {
    perguntaUsuario?: StringFieldUpdateOperationsInput | string
    queryMontada?: StringFieldUpdateOperationsInput | string
    respostaHumanizada?: StringFieldUpdateOperationsInput | string
    feedbackUsuario?: NullableIntFieldUpdateOperationsInput | number | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InteracaoIAUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    perguntaUsuario?: StringFieldUpdateOperationsInput | string
    queryMontada?: StringFieldUpdateOperationsInput | string
    respostaHumanizada?: StringFieldUpdateOperationsInput | string
    feedbackUsuario?: NullableIntFieldUpdateOperationsInput | number | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    hyperparameterArmId?: StringFieldUpdateOperationsInput | string
  }

  export type HyperparameterArmCreateInput = {
    id?: string
    modelName?: string | null
    version?: string | null
    temperature: number
    topP: number
    topK: number
    maxOutputTokens: number
    responseMimeType: string
    successes?: number | null
    failures?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    interacoes?: InteracaoIACreateNestedManyWithoutHyperparameterArmInput
  }

  export type HyperparameterArmUncheckedCreateInput = {
    id?: string
    modelName?: string | null
    version?: string | null
    temperature: number
    topP: number
    topK: number
    maxOutputTokens: number
    responseMimeType: string
    successes?: number | null
    failures?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    interacoes?: InteracaoIAUncheckedCreateNestedManyWithoutHyperparameterArmInput
  }

  export type HyperparameterArmUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: FloatFieldUpdateOperationsInput | number
    topP?: FloatFieldUpdateOperationsInput | number
    topK?: IntFieldUpdateOperationsInput | number
    maxOutputTokens?: IntFieldUpdateOperationsInput | number
    responseMimeType?: StringFieldUpdateOperationsInput | string
    successes?: NullableIntFieldUpdateOperationsInput | number | null
    failures?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interacoes?: InteracaoIAUpdateManyWithoutHyperparameterArmNestedInput
  }

  export type HyperparameterArmUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: FloatFieldUpdateOperationsInput | number
    topP?: FloatFieldUpdateOperationsInput | number
    topK?: IntFieldUpdateOperationsInput | number
    maxOutputTokens?: IntFieldUpdateOperationsInput | number
    responseMimeType?: StringFieldUpdateOperationsInput | string
    successes?: NullableIntFieldUpdateOperationsInput | number | null
    failures?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interacoes?: InteracaoIAUncheckedUpdateManyWithoutHyperparameterArmNestedInput
  }

  export type HyperparameterArmCreateManyInput = {
    id?: string
    modelName?: string | null
    version?: string | null
    temperature: number
    topP: number
    topK: number
    maxOutputTokens: number
    responseMimeType: string
    successes?: number | null
    failures?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HyperparameterArmUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: FloatFieldUpdateOperationsInput | number
    topP?: FloatFieldUpdateOperationsInput | number
    topK?: IntFieldUpdateOperationsInput | number
    maxOutputTokens?: IntFieldUpdateOperationsInput | number
    responseMimeType?: StringFieldUpdateOperationsInput | string
    successes?: NullableIntFieldUpdateOperationsInput | number | null
    failures?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HyperparameterArmUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: FloatFieldUpdateOperationsInput | number
    topP?: FloatFieldUpdateOperationsInput | number
    topK?: IntFieldUpdateOperationsInput | number
    maxOutputTokens?: IntFieldUpdateOperationsInput | number
    responseMimeType?: StringFieldUpdateOperationsInput | string
    successes?: NullableIntFieldUpdateOperationsInput | number | null
    failures?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCreateInput = {
    companyName: string
    cnpj: string
    phone?: string | null
    address?: string | null
    email: string
    password: string
    contractDate?: Date | string
    status?: $Enums.Status
    machines?: MachineCreateNestedManyWithoutClientInput
    users?: UserCreateNestedManyWithoutClientInput
    devices?: DeviceCreateNestedManyWithoutClientInput
    gateways?: GatewayCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateInput = {
    id?: number
    companyName: string
    cnpj: string
    phone?: string | null
    address?: string | null
    email: string
    password: string
    contractDate?: Date | string
    status?: $Enums.Status
    machines?: MachineUncheckedCreateNestedManyWithoutClientInput
    users?: UserUncheckedCreateNestedManyWithoutClientInput
    devices?: DeviceUncheckedCreateNestedManyWithoutClientInput
    gateways?: GatewayUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientUpdateInput = {
    companyName?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    contractDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    machines?: MachineUpdateManyWithoutClientNestedInput
    users?: UserUpdateManyWithoutClientNestedInput
    devices?: DeviceUpdateManyWithoutClientNestedInput
    gateways?: GatewayUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyName?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    contractDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    machines?: MachineUncheckedUpdateManyWithoutClientNestedInput
    users?: UserUncheckedUpdateManyWithoutClientNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutClientNestedInput
    gateways?: GatewayUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientCreateManyInput = {
    id?: number
    companyName: string
    cnpj: string
    phone?: string | null
    address?: string | null
    email: string
    password: string
    contractDate?: Date | string
    status?: $Enums.Status
  }

  export type ClientUpdateManyMutationInput = {
    companyName?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    contractDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
  }

  export type ClientUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyName?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    contractDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
  }

  export type UserCreateInput = {
    name: string
    email: string
    password: string
    userType: $Enums.UserType
    status?: $Enums.Status
    createdAt?: Date | string
    currentReadings?: CurrentReadingCreateNestedManyWithoutUserInput
    responsibleMachines?: MachineCreateNestedManyWithoutResponsibleUserInput
    oilLevelReadings?: OilLevelReadingCreateNestedManyWithoutUserInput
    oilTemperatureReadings?: OilTemperatureReadingCreateNestedManyWithoutUserInput
    rpmReadings?: RpmReadingCreateNestedManyWithoutUserInput
    client: ClientCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    name: string
    email: string
    password: string
    userType: $Enums.UserType
    status?: $Enums.Status
    clientId: number
    createdAt?: Date | string
    currentReadings?: CurrentReadingUncheckedCreateNestedManyWithoutUserInput
    responsibleMachines?: MachineUncheckedCreateNestedManyWithoutResponsibleUserInput
    oilLevelReadings?: OilLevelReadingUncheckedCreateNestedManyWithoutUserInput
    oilTemperatureReadings?: OilTemperatureReadingUncheckedCreateNestedManyWithoutUserInput
    rpmReadings?: RpmReadingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentReadings?: CurrentReadingUpdateManyWithoutUserNestedInput
    responsibleMachines?: MachineUpdateManyWithoutResponsibleUserNestedInput
    oilLevelReadings?: OilLevelReadingUpdateManyWithoutUserNestedInput
    oilTemperatureReadings?: OilTemperatureReadingUpdateManyWithoutUserNestedInput
    rpmReadings?: RpmReadingUpdateManyWithoutUserNestedInput
    client?: ClientUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    clientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentReadings?: CurrentReadingUncheckedUpdateManyWithoutUserNestedInput
    responsibleMachines?: MachineUncheckedUpdateManyWithoutResponsibleUserNestedInput
    oilLevelReadings?: OilLevelReadingUncheckedUpdateManyWithoutUserNestedInput
    oilTemperatureReadings?: OilTemperatureReadingUncheckedUpdateManyWithoutUserNestedInput
    rpmReadings?: RpmReadingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    name: string
    email: string
    password: string
    userType: $Enums.UserType
    status?: $Enums.Status
    clientId: number
    createdAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    clientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineCreateInput = {
    name: string
    model?: string | null
    manufacturer?: string | null
    serialNumber: string
    status?: $Enums.Status
    UnifiedMachineState?: UnifiedMachineStateCreateNestedManyWithoutMachineInput
    currentReadings?: CurrentReadingCreateNestedManyWithoutMachineInput
    client: ClientCreateNestedOneWithoutMachinesInput
    device?: DeviceCreateNestedOneWithoutMachineInput
    responsibleUser?: UserCreateNestedOneWithoutResponsibleMachinesInput
    oilLevelReadings?: OilLevelReadingCreateNestedManyWithoutMachineInput
    oilTemperatureReadings?: OilTemperatureReadingCreateNestedManyWithoutMachineInput
    rpmReadings?: RpmReadingCreateNestedManyWithoutMachineInput
  }

  export type MachineUncheckedCreateInput = {
    id?: number
    name: string
    model?: string | null
    manufacturer?: string | null
    serialNumber: string
    status?: $Enums.Status
    clientId: number
    responsibleUserId?: number | null
    deviceId?: number | null
    UnifiedMachineState?: UnifiedMachineStateUncheckedCreateNestedManyWithoutMachineInput
    currentReadings?: CurrentReadingUncheckedCreateNestedManyWithoutMachineInput
    oilLevelReadings?: OilLevelReadingUncheckedCreateNestedManyWithoutMachineInput
    oilTemperatureReadings?: OilTemperatureReadingUncheckedCreateNestedManyWithoutMachineInput
    rpmReadings?: RpmReadingUncheckedCreateNestedManyWithoutMachineInput
  }

  export type MachineUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    UnifiedMachineState?: UnifiedMachineStateUpdateManyWithoutMachineNestedInput
    currentReadings?: CurrentReadingUpdateManyWithoutMachineNestedInput
    client?: ClientUpdateOneRequiredWithoutMachinesNestedInput
    device?: DeviceUpdateOneWithoutMachineNestedInput
    responsibleUser?: UserUpdateOneWithoutResponsibleMachinesNestedInput
    oilLevelReadings?: OilLevelReadingUpdateManyWithoutMachineNestedInput
    oilTemperatureReadings?: OilTemperatureReadingUpdateManyWithoutMachineNestedInput
    rpmReadings?: RpmReadingUpdateManyWithoutMachineNestedInput
  }

  export type MachineUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    clientId?: IntFieldUpdateOperationsInput | number
    responsibleUserId?: NullableIntFieldUpdateOperationsInput | number | null
    deviceId?: NullableIntFieldUpdateOperationsInput | number | null
    UnifiedMachineState?: UnifiedMachineStateUncheckedUpdateManyWithoutMachineNestedInput
    currentReadings?: CurrentReadingUncheckedUpdateManyWithoutMachineNestedInput
    oilLevelReadings?: OilLevelReadingUncheckedUpdateManyWithoutMachineNestedInput
    oilTemperatureReadings?: OilTemperatureReadingUncheckedUpdateManyWithoutMachineNestedInput
    rpmReadings?: RpmReadingUncheckedUpdateManyWithoutMachineNestedInput
  }

  export type MachineCreateManyInput = {
    id?: number
    name: string
    model?: string | null
    manufacturer?: string | null
    serialNumber: string
    status?: $Enums.Status
    clientId: number
    responsibleUserId?: number | null
    deviceId?: number | null
  }

  export type MachineUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
  }

  export type MachineUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    clientId?: IntFieldUpdateOperationsInput | number
    responsibleUserId?: NullableIntFieldUpdateOperationsInput | number | null
    deviceId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UnifiedMachineStateCreateInput = {
    id?: string
    timestamp: Date | string
    current?: number | null
    rpm?: number | null
    oilTemperature?: number | null
    oilLevel?: number | null
    clusterPredict?: number | null
    clusterStrength?: number | null
    currentIsMissing?: boolean
    rpmIsMissing?: boolean
    oilTemperatureIsMissing?: boolean
    oilLevelIsMissing?: boolean
    machine: MachineCreateNestedOneWithoutUnifiedMachineStateInput
  }

  export type UnifiedMachineStateUncheckedCreateInput = {
    id?: string
    timestamp: Date | string
    machineId: number
    current?: number | null
    rpm?: number | null
    oilTemperature?: number | null
    oilLevel?: number | null
    clusterPredict?: number | null
    clusterStrength?: number | null
    currentIsMissing?: boolean
    rpmIsMissing?: boolean
    oilTemperatureIsMissing?: boolean
    oilLevelIsMissing?: boolean
  }

  export type UnifiedMachineStateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    current?: NullableFloatFieldUpdateOperationsInput | number | null
    rpm?: NullableIntFieldUpdateOperationsInput | number | null
    oilTemperature?: NullableFloatFieldUpdateOperationsInput | number | null
    oilLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    clusterPredict?: NullableIntFieldUpdateOperationsInput | number | null
    clusterStrength?: NullableFloatFieldUpdateOperationsInput | number | null
    currentIsMissing?: BoolFieldUpdateOperationsInput | boolean
    rpmIsMissing?: BoolFieldUpdateOperationsInput | boolean
    oilTemperatureIsMissing?: BoolFieldUpdateOperationsInput | boolean
    oilLevelIsMissing?: BoolFieldUpdateOperationsInput | boolean
    machine?: MachineUpdateOneRequiredWithoutUnifiedMachineStateNestedInput
  }

  export type UnifiedMachineStateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    machineId?: IntFieldUpdateOperationsInput | number
    current?: NullableFloatFieldUpdateOperationsInput | number | null
    rpm?: NullableIntFieldUpdateOperationsInput | number | null
    oilTemperature?: NullableFloatFieldUpdateOperationsInput | number | null
    oilLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    clusterPredict?: NullableIntFieldUpdateOperationsInput | number | null
    clusterStrength?: NullableFloatFieldUpdateOperationsInput | number | null
    currentIsMissing?: BoolFieldUpdateOperationsInput | boolean
    rpmIsMissing?: BoolFieldUpdateOperationsInput | boolean
    oilTemperatureIsMissing?: BoolFieldUpdateOperationsInput | boolean
    oilLevelIsMissing?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UnifiedMachineStateCreateManyInput = {
    id?: string
    timestamp: Date | string
    machineId: number
    current?: number | null
    rpm?: number | null
    oilTemperature?: number | null
    oilLevel?: number | null
    clusterPredict?: number | null
    clusterStrength?: number | null
    currentIsMissing?: boolean
    rpmIsMissing?: boolean
    oilTemperatureIsMissing?: boolean
    oilLevelIsMissing?: boolean
  }

  export type UnifiedMachineStateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    current?: NullableFloatFieldUpdateOperationsInput | number | null
    rpm?: NullableIntFieldUpdateOperationsInput | number | null
    oilTemperature?: NullableFloatFieldUpdateOperationsInput | number | null
    oilLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    clusterPredict?: NullableIntFieldUpdateOperationsInput | number | null
    clusterStrength?: NullableFloatFieldUpdateOperationsInput | number | null
    currentIsMissing?: BoolFieldUpdateOperationsInput | boolean
    rpmIsMissing?: BoolFieldUpdateOperationsInput | boolean
    oilTemperatureIsMissing?: BoolFieldUpdateOperationsInput | boolean
    oilLevelIsMissing?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UnifiedMachineStateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    machineId?: IntFieldUpdateOperationsInput | number
    current?: NullableFloatFieldUpdateOperationsInput | number | null
    rpm?: NullableIntFieldUpdateOperationsInput | number | null
    oilTemperature?: NullableFloatFieldUpdateOperationsInput | number | null
    oilLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    clusterPredict?: NullableIntFieldUpdateOperationsInput | number | null
    clusterStrength?: NullableFloatFieldUpdateOperationsInput | number | null
    currentIsMissing?: BoolFieldUpdateOperationsInput | boolean
    rpmIsMissing?: BoolFieldUpdateOperationsInput | boolean
    oilTemperatureIsMissing?: BoolFieldUpdateOperationsInput | boolean
    oilLevelIsMissing?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DeviceCreateInput = {
    nodeId: string
    description?: string | null
    status?: $Enums.DeviceStatus
    lastHeartbeat?: Date | string
    gateway?: GatewayCreateNestedOneWithoutResponsibleForInput
    machine?: MachineCreateNestedOneWithoutDeviceInput
    client: ClientCreateNestedOneWithoutDevicesInput
  }

  export type DeviceUncheckedCreateInput = {
    id?: number
    nodeId: string
    description?: string | null
    status?: $Enums.DeviceStatus
    lastHeartbeat?: Date | string
    gatewayId?: number | null
    clientId: number
    machine?: MachineUncheckedCreateNestedOneWithoutDeviceInput
  }

  export type DeviceUpdateInput = {
    nodeId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    lastHeartbeat?: DateTimeFieldUpdateOperationsInput | Date | string
    gateway?: GatewayUpdateOneWithoutResponsibleForNestedInput
    machine?: MachineUpdateOneWithoutDeviceNestedInput
    client?: ClientUpdateOneRequiredWithoutDevicesNestedInput
  }

  export type DeviceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nodeId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    lastHeartbeat?: DateTimeFieldUpdateOperationsInput | Date | string
    gatewayId?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: IntFieldUpdateOperationsInput | number
    machine?: MachineUncheckedUpdateOneWithoutDeviceNestedInput
  }

  export type DeviceCreateManyInput = {
    id?: number
    nodeId: string
    description?: string | null
    status?: $Enums.DeviceStatus
    lastHeartbeat?: Date | string
    gatewayId?: number | null
    clientId: number
  }

  export type DeviceUpdateManyMutationInput = {
    nodeId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    lastHeartbeat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nodeId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    lastHeartbeat?: DateTimeFieldUpdateOperationsInput | Date | string
    gatewayId?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: IntFieldUpdateOperationsInput | number
  }

  export type GatewayCreateInput = {
    gatewayId: string
    description?: string | null
    status?: $Enums.DeviceStatus
    lastHeartbeat?: Date | string
    responsibleFor?: DeviceCreateNestedManyWithoutGatewayInput
    client: ClientCreateNestedOneWithoutGatewaysInput
  }

  export type GatewayUncheckedCreateInput = {
    id?: number
    gatewayId: string
    description?: string | null
    status?: $Enums.DeviceStatus
    lastHeartbeat?: Date | string
    clientId: number
    responsibleFor?: DeviceUncheckedCreateNestedManyWithoutGatewayInput
  }

  export type GatewayUpdateInput = {
    gatewayId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    lastHeartbeat?: DateTimeFieldUpdateOperationsInput | Date | string
    responsibleFor?: DeviceUpdateManyWithoutGatewayNestedInput
    client?: ClientUpdateOneRequiredWithoutGatewaysNestedInput
  }

  export type GatewayUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    gatewayId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    lastHeartbeat?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: IntFieldUpdateOperationsInput | number
    responsibleFor?: DeviceUncheckedUpdateManyWithoutGatewayNestedInput
  }

  export type GatewayCreateManyInput = {
    id?: number
    gatewayId: string
    description?: string | null
    status?: $Enums.DeviceStatus
    lastHeartbeat?: Date | string
    clientId: number
  }

  export type GatewayUpdateManyMutationInput = {
    gatewayId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    lastHeartbeat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GatewayUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    gatewayId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    lastHeartbeat?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: IntFieldUpdateOperationsInput | number
  }

  export type RpmReadingCreateInput = {
    timestamp?: Date | string
    rpm: number
    machine: MachineCreateNestedOneWithoutRpmReadingsInput
    user?: UserCreateNestedOneWithoutRpmReadingsInput
  }

  export type RpmReadingUncheckedCreateInput = {
    id?: number
    timestamp?: Date | string
    rpm: number
    machineId: number
    userId?: number | null
  }

  export type RpmReadingUpdateInput = {
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    rpm?: IntFieldUpdateOperationsInput | number
    machine?: MachineUpdateOneRequiredWithoutRpmReadingsNestedInput
    user?: UserUpdateOneWithoutRpmReadingsNestedInput
  }

  export type RpmReadingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    rpm?: IntFieldUpdateOperationsInput | number
    machineId?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RpmReadingCreateManyInput = {
    id?: number
    timestamp?: Date | string
    rpm: number
    machineId: number
    userId?: number | null
  }

  export type RpmReadingUpdateManyMutationInput = {
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    rpm?: IntFieldUpdateOperationsInput | number
  }

  export type RpmReadingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    rpm?: IntFieldUpdateOperationsInput | number
    machineId?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OilTemperatureReadingCreateInput = {
    timestamp?: Date | string
    temperature: number
    machine: MachineCreateNestedOneWithoutOilTemperatureReadingsInput
    user?: UserCreateNestedOneWithoutOilTemperatureReadingsInput
  }

  export type OilTemperatureReadingUncheckedCreateInput = {
    id?: number
    timestamp?: Date | string
    temperature: number
    machineId: number
    userId?: number | null
  }

  export type OilTemperatureReadingUpdateInput = {
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    temperature?: FloatFieldUpdateOperationsInput | number
    machine?: MachineUpdateOneRequiredWithoutOilTemperatureReadingsNestedInput
    user?: UserUpdateOneWithoutOilTemperatureReadingsNestedInput
  }

  export type OilTemperatureReadingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    temperature?: FloatFieldUpdateOperationsInput | number
    machineId?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OilTemperatureReadingCreateManyInput = {
    id?: number
    timestamp?: Date | string
    temperature: number
    machineId: number
    userId?: number | null
  }

  export type OilTemperatureReadingUpdateManyMutationInput = {
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    temperature?: FloatFieldUpdateOperationsInput | number
  }

  export type OilTemperatureReadingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    temperature?: FloatFieldUpdateOperationsInput | number
    machineId?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OilLevelReadingCreateInput = {
    timestamp?: Date | string
    level: number
    machine: MachineCreateNestedOneWithoutOilLevelReadingsInput
    user?: UserCreateNestedOneWithoutOilLevelReadingsInput
  }

  export type OilLevelReadingUncheckedCreateInput = {
    id?: number
    timestamp?: Date | string
    level: number
    machineId: number
    userId?: number | null
  }

  export type OilLevelReadingUpdateInput = {
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    level?: FloatFieldUpdateOperationsInput | number
    machine?: MachineUpdateOneRequiredWithoutOilLevelReadingsNestedInput
    user?: UserUpdateOneWithoutOilLevelReadingsNestedInput
  }

  export type OilLevelReadingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    level?: FloatFieldUpdateOperationsInput | number
    machineId?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OilLevelReadingCreateManyInput = {
    id?: number
    timestamp?: Date | string
    level: number
    machineId: number
    userId?: number | null
  }

  export type OilLevelReadingUpdateManyMutationInput = {
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    level?: FloatFieldUpdateOperationsInput | number
  }

  export type OilLevelReadingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    level?: FloatFieldUpdateOperationsInput | number
    machineId?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CurrentReadingCreateInput = {
    timestamp?: Date | string
    current: number
    machine: MachineCreateNestedOneWithoutCurrentReadingsInput
    user?: UserCreateNestedOneWithoutCurrentReadingsInput
  }

  export type CurrentReadingUncheckedCreateInput = {
    id?: number
    timestamp?: Date | string
    current: number
    machineId: number
    userId?: number | null
  }

  export type CurrentReadingUpdateInput = {
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    current?: FloatFieldUpdateOperationsInput | number
    machine?: MachineUpdateOneRequiredWithoutCurrentReadingsNestedInput
    user?: UserUpdateOneWithoutCurrentReadingsNestedInput
  }

  export type CurrentReadingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    current?: FloatFieldUpdateOperationsInput | number
    machineId?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CurrentReadingCreateManyInput = {
    id?: number
    timestamp?: Date | string
    current: number
    machineId: number
    userId?: number | null
  }

  export type CurrentReadingUpdateManyMutationInput = {
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    current?: FloatFieldUpdateOperationsInput | number
  }

  export type CurrentReadingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    current?: FloatFieldUpdateOperationsInput | number
    machineId?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type HyperparameterArmScalarRelationFilter = {
    is?: HyperparameterArmWhereInput
    isNot?: HyperparameterArmWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type InteracaoIACountOrderByAggregateInput = {
    id?: SortOrder
    perguntaUsuario?: SortOrder
    queryMontada?: SortOrder
    respostaHumanizada?: SortOrder
    feedbackUsuario?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    hyperparameterArmId?: SortOrder
  }

  export type InteracaoIAAvgOrderByAggregateInput = {
    id?: SortOrder
    feedbackUsuario?: SortOrder
  }

  export type InteracaoIAMaxOrderByAggregateInput = {
    id?: SortOrder
    perguntaUsuario?: SortOrder
    queryMontada?: SortOrder
    respostaHumanizada?: SortOrder
    feedbackUsuario?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    hyperparameterArmId?: SortOrder
  }

  export type InteracaoIAMinOrderByAggregateInput = {
    id?: SortOrder
    perguntaUsuario?: SortOrder
    queryMontada?: SortOrder
    respostaHumanizada?: SortOrder
    feedbackUsuario?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    hyperparameterArmId?: SortOrder
  }

  export type InteracaoIASumOrderByAggregateInput = {
    id?: SortOrder
    feedbackUsuario?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type InteracaoIAListRelationFilter = {
    every?: InteracaoIAWhereInput
    some?: InteracaoIAWhereInput
    none?: InteracaoIAWhereInput
  }

  export type InteracaoIAOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HyperparameterArmCountOrderByAggregateInput = {
    id?: SortOrder
    modelName?: SortOrder
    version?: SortOrder
    temperature?: SortOrder
    topP?: SortOrder
    topK?: SortOrder
    maxOutputTokens?: SortOrder
    responseMimeType?: SortOrder
    successes?: SortOrder
    failures?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HyperparameterArmAvgOrderByAggregateInput = {
    temperature?: SortOrder
    topP?: SortOrder
    topK?: SortOrder
    maxOutputTokens?: SortOrder
    successes?: SortOrder
    failures?: SortOrder
  }

  export type HyperparameterArmMaxOrderByAggregateInput = {
    id?: SortOrder
    modelName?: SortOrder
    version?: SortOrder
    temperature?: SortOrder
    topP?: SortOrder
    topK?: SortOrder
    maxOutputTokens?: SortOrder
    responseMimeType?: SortOrder
    successes?: SortOrder
    failures?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HyperparameterArmMinOrderByAggregateInput = {
    id?: SortOrder
    modelName?: SortOrder
    version?: SortOrder
    temperature?: SortOrder
    topP?: SortOrder
    topK?: SortOrder
    maxOutputTokens?: SortOrder
    responseMimeType?: SortOrder
    successes?: SortOrder
    failures?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HyperparameterArmSumOrderByAggregateInput = {
    temperature?: SortOrder
    topP?: SortOrder
    topK?: SortOrder
    maxOutputTokens?: SortOrder
    successes?: SortOrder
    failures?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusFilter<$PrismaModel> | $Enums.Status
  }

  export type MachineListRelationFilter = {
    every?: MachineWhereInput
    some?: MachineWhereInput
    none?: MachineWhereInput
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type DeviceListRelationFilter = {
    every?: DeviceWhereInput
    some?: DeviceWhereInput
    none?: DeviceWhereInput
  }

  export type GatewayListRelationFilter = {
    every?: GatewayWhereInput
    some?: GatewayWhereInput
    none?: GatewayWhereInput
  }

  export type MachineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeviceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GatewayOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientCountOrderByAggregateInput = {
    id?: SortOrder
    companyName?: SortOrder
    cnpj?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    email?: SortOrder
    password?: SortOrder
    contractDate?: SortOrder
    status?: SortOrder
  }

  export type ClientAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ClientMaxOrderByAggregateInput = {
    id?: SortOrder
    companyName?: SortOrder
    cnpj?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    email?: SortOrder
    password?: SortOrder
    contractDate?: SortOrder
    status?: SortOrder
  }

  export type ClientMinOrderByAggregateInput = {
    id?: SortOrder
    companyName?: SortOrder
    cnpj?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    email?: SortOrder
    password?: SortOrder
    contractDate?: SortOrder
    status?: SortOrder
  }

  export type ClientSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusWithAggregatesFilter<$PrismaModel> | $Enums.Status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusFilter<$PrismaModel>
    _max?: NestedEnumStatusFilter<$PrismaModel>
  }

  export type EnumUserTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.UserType | EnumUserTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTypeFilter<$PrismaModel> | $Enums.UserType
  }

  export type CurrentReadingListRelationFilter = {
    every?: CurrentReadingWhereInput
    some?: CurrentReadingWhereInput
    none?: CurrentReadingWhereInput
  }

  export type OilLevelReadingListRelationFilter = {
    every?: OilLevelReadingWhereInput
    some?: OilLevelReadingWhereInput
    none?: OilLevelReadingWhereInput
  }

  export type OilTemperatureReadingListRelationFilter = {
    every?: OilTemperatureReadingWhereInput
    some?: OilTemperatureReadingWhereInput
    none?: OilTemperatureReadingWhereInput
  }

  export type RpmReadingListRelationFilter = {
    every?: RpmReadingWhereInput
    some?: RpmReadingWhereInput
    none?: RpmReadingWhereInput
  }

  export type ClientScalarRelationFilter = {
    is?: ClientWhereInput
    isNot?: ClientWhereInput
  }

  export type CurrentReadingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OilLevelReadingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OilTemperatureReadingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RpmReadingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    userType?: SortOrder
    status?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    userType?: SortOrder
    status?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    userType?: SortOrder
    status?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
  }

  export type EnumUserTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserType | EnumUserTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTypeWithAggregatesFilter<$PrismaModel> | $Enums.UserType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserTypeFilter<$PrismaModel>
    _max?: NestedEnumUserTypeFilter<$PrismaModel>
  }

  export type UnifiedMachineStateListRelationFilter = {
    every?: UnifiedMachineStateWhereInput
    some?: UnifiedMachineStateWhereInput
    none?: UnifiedMachineStateWhereInput
  }

  export type DeviceNullableScalarRelationFilter = {
    is?: DeviceWhereInput | null
    isNot?: DeviceWhereInput | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type UnifiedMachineStateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MachineCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    model?: SortOrder
    manufacturer?: SortOrder
    serialNumber?: SortOrder
    status?: SortOrder
    clientId?: SortOrder
    responsibleUserId?: SortOrder
    deviceId?: SortOrder
  }

  export type MachineAvgOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    responsibleUserId?: SortOrder
    deviceId?: SortOrder
  }

  export type MachineMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    model?: SortOrder
    manufacturer?: SortOrder
    serialNumber?: SortOrder
    status?: SortOrder
    clientId?: SortOrder
    responsibleUserId?: SortOrder
    deviceId?: SortOrder
  }

  export type MachineMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    model?: SortOrder
    manufacturer?: SortOrder
    serialNumber?: SortOrder
    status?: SortOrder
    clientId?: SortOrder
    responsibleUserId?: SortOrder
    deviceId?: SortOrder
  }

  export type MachineSumOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    responsibleUserId?: SortOrder
    deviceId?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type MachineScalarRelationFilter = {
    is?: MachineWhereInput
    isNot?: MachineWhereInput
  }

  export type UnifiedMachineStateCountOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    machineId?: SortOrder
    current?: SortOrder
    rpm?: SortOrder
    oilTemperature?: SortOrder
    oilLevel?: SortOrder
    clusterPredict?: SortOrder
    clusterStrength?: SortOrder
    currentIsMissing?: SortOrder
    rpmIsMissing?: SortOrder
    oilTemperatureIsMissing?: SortOrder
    oilLevelIsMissing?: SortOrder
  }

  export type UnifiedMachineStateAvgOrderByAggregateInput = {
    machineId?: SortOrder
    current?: SortOrder
    rpm?: SortOrder
    oilTemperature?: SortOrder
    oilLevel?: SortOrder
    clusterPredict?: SortOrder
    clusterStrength?: SortOrder
  }

  export type UnifiedMachineStateMaxOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    machineId?: SortOrder
    current?: SortOrder
    rpm?: SortOrder
    oilTemperature?: SortOrder
    oilLevel?: SortOrder
    clusterPredict?: SortOrder
    clusterStrength?: SortOrder
    currentIsMissing?: SortOrder
    rpmIsMissing?: SortOrder
    oilTemperatureIsMissing?: SortOrder
    oilLevelIsMissing?: SortOrder
  }

  export type UnifiedMachineStateMinOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    machineId?: SortOrder
    current?: SortOrder
    rpm?: SortOrder
    oilTemperature?: SortOrder
    oilLevel?: SortOrder
    clusterPredict?: SortOrder
    clusterStrength?: SortOrder
    currentIsMissing?: SortOrder
    rpmIsMissing?: SortOrder
    oilTemperatureIsMissing?: SortOrder
    oilLevelIsMissing?: SortOrder
  }

  export type UnifiedMachineStateSumOrderByAggregateInput = {
    machineId?: SortOrder
    current?: SortOrder
    rpm?: SortOrder
    oilTemperature?: SortOrder
    oilLevel?: SortOrder
    clusterPredict?: SortOrder
    clusterStrength?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumDeviceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DeviceStatus | EnumDeviceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DeviceStatus[] | ListEnumDeviceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeviceStatus[] | ListEnumDeviceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDeviceStatusFilter<$PrismaModel> | $Enums.DeviceStatus
  }

  export type GatewayNullableScalarRelationFilter = {
    is?: GatewayWhereInput | null
    isNot?: GatewayWhereInput | null
  }

  export type MachineNullableScalarRelationFilter = {
    is?: MachineWhereInput | null
    isNot?: MachineWhereInput | null
  }

  export type DeviceCountOrderByAggregateInput = {
    id?: SortOrder
    nodeId?: SortOrder
    description?: SortOrder
    status?: SortOrder
    lastHeartbeat?: SortOrder
    gatewayId?: SortOrder
    clientId?: SortOrder
  }

  export type DeviceAvgOrderByAggregateInput = {
    id?: SortOrder
    gatewayId?: SortOrder
    clientId?: SortOrder
  }

  export type DeviceMaxOrderByAggregateInput = {
    id?: SortOrder
    nodeId?: SortOrder
    description?: SortOrder
    status?: SortOrder
    lastHeartbeat?: SortOrder
    gatewayId?: SortOrder
    clientId?: SortOrder
  }

  export type DeviceMinOrderByAggregateInput = {
    id?: SortOrder
    nodeId?: SortOrder
    description?: SortOrder
    status?: SortOrder
    lastHeartbeat?: SortOrder
    gatewayId?: SortOrder
    clientId?: SortOrder
  }

  export type DeviceSumOrderByAggregateInput = {
    id?: SortOrder
    gatewayId?: SortOrder
    clientId?: SortOrder
  }

  export type EnumDeviceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeviceStatus | EnumDeviceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DeviceStatus[] | ListEnumDeviceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeviceStatus[] | ListEnumDeviceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDeviceStatusWithAggregatesFilter<$PrismaModel> | $Enums.DeviceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDeviceStatusFilter<$PrismaModel>
    _max?: NestedEnumDeviceStatusFilter<$PrismaModel>
  }

  export type GatewayCountOrderByAggregateInput = {
    id?: SortOrder
    gatewayId?: SortOrder
    description?: SortOrder
    status?: SortOrder
    lastHeartbeat?: SortOrder
    clientId?: SortOrder
  }

  export type GatewayAvgOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
  }

  export type GatewayMaxOrderByAggregateInput = {
    id?: SortOrder
    gatewayId?: SortOrder
    description?: SortOrder
    status?: SortOrder
    lastHeartbeat?: SortOrder
    clientId?: SortOrder
  }

  export type GatewayMinOrderByAggregateInput = {
    id?: SortOrder
    gatewayId?: SortOrder
    description?: SortOrder
    status?: SortOrder
    lastHeartbeat?: SortOrder
    clientId?: SortOrder
  }

  export type GatewaySumOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
  }

  export type RpmReadingCountOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    rpm?: SortOrder
    machineId?: SortOrder
    userId?: SortOrder
  }

  export type RpmReadingAvgOrderByAggregateInput = {
    id?: SortOrder
    rpm?: SortOrder
    machineId?: SortOrder
    userId?: SortOrder
  }

  export type RpmReadingMaxOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    rpm?: SortOrder
    machineId?: SortOrder
    userId?: SortOrder
  }

  export type RpmReadingMinOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    rpm?: SortOrder
    machineId?: SortOrder
    userId?: SortOrder
  }

  export type RpmReadingSumOrderByAggregateInput = {
    id?: SortOrder
    rpm?: SortOrder
    machineId?: SortOrder
    userId?: SortOrder
  }

  export type OilTemperatureReadingCountOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    temperature?: SortOrder
    machineId?: SortOrder
    userId?: SortOrder
  }

  export type OilTemperatureReadingAvgOrderByAggregateInput = {
    id?: SortOrder
    temperature?: SortOrder
    machineId?: SortOrder
    userId?: SortOrder
  }

  export type OilTemperatureReadingMaxOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    temperature?: SortOrder
    machineId?: SortOrder
    userId?: SortOrder
  }

  export type OilTemperatureReadingMinOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    temperature?: SortOrder
    machineId?: SortOrder
    userId?: SortOrder
  }

  export type OilTemperatureReadingSumOrderByAggregateInput = {
    id?: SortOrder
    temperature?: SortOrder
    machineId?: SortOrder
    userId?: SortOrder
  }

  export type OilLevelReadingCountOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    level?: SortOrder
    machineId?: SortOrder
    userId?: SortOrder
  }

  export type OilLevelReadingAvgOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    machineId?: SortOrder
    userId?: SortOrder
  }

  export type OilLevelReadingMaxOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    level?: SortOrder
    machineId?: SortOrder
    userId?: SortOrder
  }

  export type OilLevelReadingMinOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    level?: SortOrder
    machineId?: SortOrder
    userId?: SortOrder
  }

  export type OilLevelReadingSumOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    machineId?: SortOrder
    userId?: SortOrder
  }

  export type CurrentReadingCountOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    current?: SortOrder
    machineId?: SortOrder
    userId?: SortOrder
  }

  export type CurrentReadingAvgOrderByAggregateInput = {
    id?: SortOrder
    current?: SortOrder
    machineId?: SortOrder
    userId?: SortOrder
  }

  export type CurrentReadingMaxOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    current?: SortOrder
    machineId?: SortOrder
    userId?: SortOrder
  }

  export type CurrentReadingMinOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    current?: SortOrder
    machineId?: SortOrder
    userId?: SortOrder
  }

  export type CurrentReadingSumOrderByAggregateInput = {
    id?: SortOrder
    current?: SortOrder
    machineId?: SortOrder
    userId?: SortOrder
  }

  export type HyperparameterArmCreateNestedOneWithoutInteracoesInput = {
    create?: XOR<HyperparameterArmCreateWithoutInteracoesInput, HyperparameterArmUncheckedCreateWithoutInteracoesInput>
    connectOrCreate?: HyperparameterArmCreateOrConnectWithoutInteracoesInput
    connect?: HyperparameterArmWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type HyperparameterArmUpdateOneRequiredWithoutInteracoesNestedInput = {
    create?: XOR<HyperparameterArmCreateWithoutInteracoesInput, HyperparameterArmUncheckedCreateWithoutInteracoesInput>
    connectOrCreate?: HyperparameterArmCreateOrConnectWithoutInteracoesInput
    upsert?: HyperparameterArmUpsertWithoutInteracoesInput
    connect?: HyperparameterArmWhereUniqueInput
    update?: XOR<XOR<HyperparameterArmUpdateToOneWithWhereWithoutInteracoesInput, HyperparameterArmUpdateWithoutInteracoesInput>, HyperparameterArmUncheckedUpdateWithoutInteracoesInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type InteracaoIACreateNestedManyWithoutHyperparameterArmInput = {
    create?: XOR<InteracaoIACreateWithoutHyperparameterArmInput, InteracaoIAUncheckedCreateWithoutHyperparameterArmInput> | InteracaoIACreateWithoutHyperparameterArmInput[] | InteracaoIAUncheckedCreateWithoutHyperparameterArmInput[]
    connectOrCreate?: InteracaoIACreateOrConnectWithoutHyperparameterArmInput | InteracaoIACreateOrConnectWithoutHyperparameterArmInput[]
    createMany?: InteracaoIACreateManyHyperparameterArmInputEnvelope
    connect?: InteracaoIAWhereUniqueInput | InteracaoIAWhereUniqueInput[]
  }

  export type InteracaoIAUncheckedCreateNestedManyWithoutHyperparameterArmInput = {
    create?: XOR<InteracaoIACreateWithoutHyperparameterArmInput, InteracaoIAUncheckedCreateWithoutHyperparameterArmInput> | InteracaoIACreateWithoutHyperparameterArmInput[] | InteracaoIAUncheckedCreateWithoutHyperparameterArmInput[]
    connectOrCreate?: InteracaoIACreateOrConnectWithoutHyperparameterArmInput | InteracaoIACreateOrConnectWithoutHyperparameterArmInput[]
    createMany?: InteracaoIACreateManyHyperparameterArmInputEnvelope
    connect?: InteracaoIAWhereUniqueInput | InteracaoIAWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type InteracaoIAUpdateManyWithoutHyperparameterArmNestedInput = {
    create?: XOR<InteracaoIACreateWithoutHyperparameterArmInput, InteracaoIAUncheckedCreateWithoutHyperparameterArmInput> | InteracaoIACreateWithoutHyperparameterArmInput[] | InteracaoIAUncheckedCreateWithoutHyperparameterArmInput[]
    connectOrCreate?: InteracaoIACreateOrConnectWithoutHyperparameterArmInput | InteracaoIACreateOrConnectWithoutHyperparameterArmInput[]
    upsert?: InteracaoIAUpsertWithWhereUniqueWithoutHyperparameterArmInput | InteracaoIAUpsertWithWhereUniqueWithoutHyperparameterArmInput[]
    createMany?: InteracaoIACreateManyHyperparameterArmInputEnvelope
    set?: InteracaoIAWhereUniqueInput | InteracaoIAWhereUniqueInput[]
    disconnect?: InteracaoIAWhereUniqueInput | InteracaoIAWhereUniqueInput[]
    delete?: InteracaoIAWhereUniqueInput | InteracaoIAWhereUniqueInput[]
    connect?: InteracaoIAWhereUniqueInput | InteracaoIAWhereUniqueInput[]
    update?: InteracaoIAUpdateWithWhereUniqueWithoutHyperparameterArmInput | InteracaoIAUpdateWithWhereUniqueWithoutHyperparameterArmInput[]
    updateMany?: InteracaoIAUpdateManyWithWhereWithoutHyperparameterArmInput | InteracaoIAUpdateManyWithWhereWithoutHyperparameterArmInput[]
    deleteMany?: InteracaoIAScalarWhereInput | InteracaoIAScalarWhereInput[]
  }

  export type InteracaoIAUncheckedUpdateManyWithoutHyperparameterArmNestedInput = {
    create?: XOR<InteracaoIACreateWithoutHyperparameterArmInput, InteracaoIAUncheckedCreateWithoutHyperparameterArmInput> | InteracaoIACreateWithoutHyperparameterArmInput[] | InteracaoIAUncheckedCreateWithoutHyperparameterArmInput[]
    connectOrCreate?: InteracaoIACreateOrConnectWithoutHyperparameterArmInput | InteracaoIACreateOrConnectWithoutHyperparameterArmInput[]
    upsert?: InteracaoIAUpsertWithWhereUniqueWithoutHyperparameterArmInput | InteracaoIAUpsertWithWhereUniqueWithoutHyperparameterArmInput[]
    createMany?: InteracaoIACreateManyHyperparameterArmInputEnvelope
    set?: InteracaoIAWhereUniqueInput | InteracaoIAWhereUniqueInput[]
    disconnect?: InteracaoIAWhereUniqueInput | InteracaoIAWhereUniqueInput[]
    delete?: InteracaoIAWhereUniqueInput | InteracaoIAWhereUniqueInput[]
    connect?: InteracaoIAWhereUniqueInput | InteracaoIAWhereUniqueInput[]
    update?: InteracaoIAUpdateWithWhereUniqueWithoutHyperparameterArmInput | InteracaoIAUpdateWithWhereUniqueWithoutHyperparameterArmInput[]
    updateMany?: InteracaoIAUpdateManyWithWhereWithoutHyperparameterArmInput | InteracaoIAUpdateManyWithWhereWithoutHyperparameterArmInput[]
    deleteMany?: InteracaoIAScalarWhereInput | InteracaoIAScalarWhereInput[]
  }

  export type MachineCreateNestedManyWithoutClientInput = {
    create?: XOR<MachineCreateWithoutClientInput, MachineUncheckedCreateWithoutClientInput> | MachineCreateWithoutClientInput[] | MachineUncheckedCreateWithoutClientInput[]
    connectOrCreate?: MachineCreateOrConnectWithoutClientInput | MachineCreateOrConnectWithoutClientInput[]
    createMany?: MachineCreateManyClientInputEnvelope
    connect?: MachineWhereUniqueInput | MachineWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutClientInput = {
    create?: XOR<UserCreateWithoutClientInput, UserUncheckedCreateWithoutClientInput> | UserCreateWithoutClientInput[] | UserUncheckedCreateWithoutClientInput[]
    connectOrCreate?: UserCreateOrConnectWithoutClientInput | UserCreateOrConnectWithoutClientInput[]
    createMany?: UserCreateManyClientInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type DeviceCreateNestedManyWithoutClientInput = {
    create?: XOR<DeviceCreateWithoutClientInput, DeviceUncheckedCreateWithoutClientInput> | DeviceCreateWithoutClientInput[] | DeviceUncheckedCreateWithoutClientInput[]
    connectOrCreate?: DeviceCreateOrConnectWithoutClientInput | DeviceCreateOrConnectWithoutClientInput[]
    createMany?: DeviceCreateManyClientInputEnvelope
    connect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
  }

  export type GatewayCreateNestedManyWithoutClientInput = {
    create?: XOR<GatewayCreateWithoutClientInput, GatewayUncheckedCreateWithoutClientInput> | GatewayCreateWithoutClientInput[] | GatewayUncheckedCreateWithoutClientInput[]
    connectOrCreate?: GatewayCreateOrConnectWithoutClientInput | GatewayCreateOrConnectWithoutClientInput[]
    createMany?: GatewayCreateManyClientInputEnvelope
    connect?: GatewayWhereUniqueInput | GatewayWhereUniqueInput[]
  }

  export type MachineUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<MachineCreateWithoutClientInput, MachineUncheckedCreateWithoutClientInput> | MachineCreateWithoutClientInput[] | MachineUncheckedCreateWithoutClientInput[]
    connectOrCreate?: MachineCreateOrConnectWithoutClientInput | MachineCreateOrConnectWithoutClientInput[]
    createMany?: MachineCreateManyClientInputEnvelope
    connect?: MachineWhereUniqueInput | MachineWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<UserCreateWithoutClientInput, UserUncheckedCreateWithoutClientInput> | UserCreateWithoutClientInput[] | UserUncheckedCreateWithoutClientInput[]
    connectOrCreate?: UserCreateOrConnectWithoutClientInput | UserCreateOrConnectWithoutClientInput[]
    createMany?: UserCreateManyClientInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type DeviceUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<DeviceCreateWithoutClientInput, DeviceUncheckedCreateWithoutClientInput> | DeviceCreateWithoutClientInput[] | DeviceUncheckedCreateWithoutClientInput[]
    connectOrCreate?: DeviceCreateOrConnectWithoutClientInput | DeviceCreateOrConnectWithoutClientInput[]
    createMany?: DeviceCreateManyClientInputEnvelope
    connect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
  }

  export type GatewayUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<GatewayCreateWithoutClientInput, GatewayUncheckedCreateWithoutClientInput> | GatewayCreateWithoutClientInput[] | GatewayUncheckedCreateWithoutClientInput[]
    connectOrCreate?: GatewayCreateOrConnectWithoutClientInput | GatewayCreateOrConnectWithoutClientInput[]
    createMany?: GatewayCreateManyClientInputEnvelope
    connect?: GatewayWhereUniqueInput | GatewayWhereUniqueInput[]
  }

  export type EnumStatusFieldUpdateOperationsInput = {
    set?: $Enums.Status
  }

  export type MachineUpdateManyWithoutClientNestedInput = {
    create?: XOR<MachineCreateWithoutClientInput, MachineUncheckedCreateWithoutClientInput> | MachineCreateWithoutClientInput[] | MachineUncheckedCreateWithoutClientInput[]
    connectOrCreate?: MachineCreateOrConnectWithoutClientInput | MachineCreateOrConnectWithoutClientInput[]
    upsert?: MachineUpsertWithWhereUniqueWithoutClientInput | MachineUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: MachineCreateManyClientInputEnvelope
    set?: MachineWhereUniqueInput | MachineWhereUniqueInput[]
    disconnect?: MachineWhereUniqueInput | MachineWhereUniqueInput[]
    delete?: MachineWhereUniqueInput | MachineWhereUniqueInput[]
    connect?: MachineWhereUniqueInput | MachineWhereUniqueInput[]
    update?: MachineUpdateWithWhereUniqueWithoutClientInput | MachineUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: MachineUpdateManyWithWhereWithoutClientInput | MachineUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: MachineScalarWhereInput | MachineScalarWhereInput[]
  }

  export type UserUpdateManyWithoutClientNestedInput = {
    create?: XOR<UserCreateWithoutClientInput, UserUncheckedCreateWithoutClientInput> | UserCreateWithoutClientInput[] | UserUncheckedCreateWithoutClientInput[]
    connectOrCreate?: UserCreateOrConnectWithoutClientInput | UserCreateOrConnectWithoutClientInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutClientInput | UserUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: UserCreateManyClientInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutClientInput | UserUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: UserUpdateManyWithWhereWithoutClientInput | UserUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type DeviceUpdateManyWithoutClientNestedInput = {
    create?: XOR<DeviceCreateWithoutClientInput, DeviceUncheckedCreateWithoutClientInput> | DeviceCreateWithoutClientInput[] | DeviceUncheckedCreateWithoutClientInput[]
    connectOrCreate?: DeviceCreateOrConnectWithoutClientInput | DeviceCreateOrConnectWithoutClientInput[]
    upsert?: DeviceUpsertWithWhereUniqueWithoutClientInput | DeviceUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: DeviceCreateManyClientInputEnvelope
    set?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    disconnect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    delete?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    connect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    update?: DeviceUpdateWithWhereUniqueWithoutClientInput | DeviceUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: DeviceUpdateManyWithWhereWithoutClientInput | DeviceUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: DeviceScalarWhereInput | DeviceScalarWhereInput[]
  }

  export type GatewayUpdateManyWithoutClientNestedInput = {
    create?: XOR<GatewayCreateWithoutClientInput, GatewayUncheckedCreateWithoutClientInput> | GatewayCreateWithoutClientInput[] | GatewayUncheckedCreateWithoutClientInput[]
    connectOrCreate?: GatewayCreateOrConnectWithoutClientInput | GatewayCreateOrConnectWithoutClientInput[]
    upsert?: GatewayUpsertWithWhereUniqueWithoutClientInput | GatewayUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: GatewayCreateManyClientInputEnvelope
    set?: GatewayWhereUniqueInput | GatewayWhereUniqueInput[]
    disconnect?: GatewayWhereUniqueInput | GatewayWhereUniqueInput[]
    delete?: GatewayWhereUniqueInput | GatewayWhereUniqueInput[]
    connect?: GatewayWhereUniqueInput | GatewayWhereUniqueInput[]
    update?: GatewayUpdateWithWhereUniqueWithoutClientInput | GatewayUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: GatewayUpdateManyWithWhereWithoutClientInput | GatewayUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: GatewayScalarWhereInput | GatewayScalarWhereInput[]
  }

  export type MachineUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<MachineCreateWithoutClientInput, MachineUncheckedCreateWithoutClientInput> | MachineCreateWithoutClientInput[] | MachineUncheckedCreateWithoutClientInput[]
    connectOrCreate?: MachineCreateOrConnectWithoutClientInput | MachineCreateOrConnectWithoutClientInput[]
    upsert?: MachineUpsertWithWhereUniqueWithoutClientInput | MachineUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: MachineCreateManyClientInputEnvelope
    set?: MachineWhereUniqueInput | MachineWhereUniqueInput[]
    disconnect?: MachineWhereUniqueInput | MachineWhereUniqueInput[]
    delete?: MachineWhereUniqueInput | MachineWhereUniqueInput[]
    connect?: MachineWhereUniqueInput | MachineWhereUniqueInput[]
    update?: MachineUpdateWithWhereUniqueWithoutClientInput | MachineUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: MachineUpdateManyWithWhereWithoutClientInput | MachineUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: MachineScalarWhereInput | MachineScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<UserCreateWithoutClientInput, UserUncheckedCreateWithoutClientInput> | UserCreateWithoutClientInput[] | UserUncheckedCreateWithoutClientInput[]
    connectOrCreate?: UserCreateOrConnectWithoutClientInput | UserCreateOrConnectWithoutClientInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutClientInput | UserUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: UserCreateManyClientInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutClientInput | UserUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: UserUpdateManyWithWhereWithoutClientInput | UserUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type DeviceUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<DeviceCreateWithoutClientInput, DeviceUncheckedCreateWithoutClientInput> | DeviceCreateWithoutClientInput[] | DeviceUncheckedCreateWithoutClientInput[]
    connectOrCreate?: DeviceCreateOrConnectWithoutClientInput | DeviceCreateOrConnectWithoutClientInput[]
    upsert?: DeviceUpsertWithWhereUniqueWithoutClientInput | DeviceUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: DeviceCreateManyClientInputEnvelope
    set?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    disconnect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    delete?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    connect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    update?: DeviceUpdateWithWhereUniqueWithoutClientInput | DeviceUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: DeviceUpdateManyWithWhereWithoutClientInput | DeviceUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: DeviceScalarWhereInput | DeviceScalarWhereInput[]
  }

  export type GatewayUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<GatewayCreateWithoutClientInput, GatewayUncheckedCreateWithoutClientInput> | GatewayCreateWithoutClientInput[] | GatewayUncheckedCreateWithoutClientInput[]
    connectOrCreate?: GatewayCreateOrConnectWithoutClientInput | GatewayCreateOrConnectWithoutClientInput[]
    upsert?: GatewayUpsertWithWhereUniqueWithoutClientInput | GatewayUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: GatewayCreateManyClientInputEnvelope
    set?: GatewayWhereUniqueInput | GatewayWhereUniqueInput[]
    disconnect?: GatewayWhereUniqueInput | GatewayWhereUniqueInput[]
    delete?: GatewayWhereUniqueInput | GatewayWhereUniqueInput[]
    connect?: GatewayWhereUniqueInput | GatewayWhereUniqueInput[]
    update?: GatewayUpdateWithWhereUniqueWithoutClientInput | GatewayUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: GatewayUpdateManyWithWhereWithoutClientInput | GatewayUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: GatewayScalarWhereInput | GatewayScalarWhereInput[]
  }

  export type CurrentReadingCreateNestedManyWithoutUserInput = {
    create?: XOR<CurrentReadingCreateWithoutUserInput, CurrentReadingUncheckedCreateWithoutUserInput> | CurrentReadingCreateWithoutUserInput[] | CurrentReadingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CurrentReadingCreateOrConnectWithoutUserInput | CurrentReadingCreateOrConnectWithoutUserInput[]
    createMany?: CurrentReadingCreateManyUserInputEnvelope
    connect?: CurrentReadingWhereUniqueInput | CurrentReadingWhereUniqueInput[]
  }

  export type MachineCreateNestedManyWithoutResponsibleUserInput = {
    create?: XOR<MachineCreateWithoutResponsibleUserInput, MachineUncheckedCreateWithoutResponsibleUserInput> | MachineCreateWithoutResponsibleUserInput[] | MachineUncheckedCreateWithoutResponsibleUserInput[]
    connectOrCreate?: MachineCreateOrConnectWithoutResponsibleUserInput | MachineCreateOrConnectWithoutResponsibleUserInput[]
    createMany?: MachineCreateManyResponsibleUserInputEnvelope
    connect?: MachineWhereUniqueInput | MachineWhereUniqueInput[]
  }

  export type OilLevelReadingCreateNestedManyWithoutUserInput = {
    create?: XOR<OilLevelReadingCreateWithoutUserInput, OilLevelReadingUncheckedCreateWithoutUserInput> | OilLevelReadingCreateWithoutUserInput[] | OilLevelReadingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OilLevelReadingCreateOrConnectWithoutUserInput | OilLevelReadingCreateOrConnectWithoutUserInput[]
    createMany?: OilLevelReadingCreateManyUserInputEnvelope
    connect?: OilLevelReadingWhereUniqueInput | OilLevelReadingWhereUniqueInput[]
  }

  export type OilTemperatureReadingCreateNestedManyWithoutUserInput = {
    create?: XOR<OilTemperatureReadingCreateWithoutUserInput, OilTemperatureReadingUncheckedCreateWithoutUserInput> | OilTemperatureReadingCreateWithoutUserInput[] | OilTemperatureReadingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OilTemperatureReadingCreateOrConnectWithoutUserInput | OilTemperatureReadingCreateOrConnectWithoutUserInput[]
    createMany?: OilTemperatureReadingCreateManyUserInputEnvelope
    connect?: OilTemperatureReadingWhereUniqueInput | OilTemperatureReadingWhereUniqueInput[]
  }

  export type RpmReadingCreateNestedManyWithoutUserInput = {
    create?: XOR<RpmReadingCreateWithoutUserInput, RpmReadingUncheckedCreateWithoutUserInput> | RpmReadingCreateWithoutUserInput[] | RpmReadingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RpmReadingCreateOrConnectWithoutUserInput | RpmReadingCreateOrConnectWithoutUserInput[]
    createMany?: RpmReadingCreateManyUserInputEnvelope
    connect?: RpmReadingWhereUniqueInput | RpmReadingWhereUniqueInput[]
  }

  export type ClientCreateNestedOneWithoutUsersInput = {
    create?: XOR<ClientCreateWithoutUsersInput, ClientUncheckedCreateWithoutUsersInput>
    connectOrCreate?: ClientCreateOrConnectWithoutUsersInput
    connect?: ClientWhereUniqueInput
  }

  export type CurrentReadingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CurrentReadingCreateWithoutUserInput, CurrentReadingUncheckedCreateWithoutUserInput> | CurrentReadingCreateWithoutUserInput[] | CurrentReadingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CurrentReadingCreateOrConnectWithoutUserInput | CurrentReadingCreateOrConnectWithoutUserInput[]
    createMany?: CurrentReadingCreateManyUserInputEnvelope
    connect?: CurrentReadingWhereUniqueInput | CurrentReadingWhereUniqueInput[]
  }

  export type MachineUncheckedCreateNestedManyWithoutResponsibleUserInput = {
    create?: XOR<MachineCreateWithoutResponsibleUserInput, MachineUncheckedCreateWithoutResponsibleUserInput> | MachineCreateWithoutResponsibleUserInput[] | MachineUncheckedCreateWithoutResponsibleUserInput[]
    connectOrCreate?: MachineCreateOrConnectWithoutResponsibleUserInput | MachineCreateOrConnectWithoutResponsibleUserInput[]
    createMany?: MachineCreateManyResponsibleUserInputEnvelope
    connect?: MachineWhereUniqueInput | MachineWhereUniqueInput[]
  }

  export type OilLevelReadingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OilLevelReadingCreateWithoutUserInput, OilLevelReadingUncheckedCreateWithoutUserInput> | OilLevelReadingCreateWithoutUserInput[] | OilLevelReadingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OilLevelReadingCreateOrConnectWithoutUserInput | OilLevelReadingCreateOrConnectWithoutUserInput[]
    createMany?: OilLevelReadingCreateManyUserInputEnvelope
    connect?: OilLevelReadingWhereUniqueInput | OilLevelReadingWhereUniqueInput[]
  }

  export type OilTemperatureReadingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OilTemperatureReadingCreateWithoutUserInput, OilTemperatureReadingUncheckedCreateWithoutUserInput> | OilTemperatureReadingCreateWithoutUserInput[] | OilTemperatureReadingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OilTemperatureReadingCreateOrConnectWithoutUserInput | OilTemperatureReadingCreateOrConnectWithoutUserInput[]
    createMany?: OilTemperatureReadingCreateManyUserInputEnvelope
    connect?: OilTemperatureReadingWhereUniqueInput | OilTemperatureReadingWhereUniqueInput[]
  }

  export type RpmReadingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RpmReadingCreateWithoutUserInput, RpmReadingUncheckedCreateWithoutUserInput> | RpmReadingCreateWithoutUserInput[] | RpmReadingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RpmReadingCreateOrConnectWithoutUserInput | RpmReadingCreateOrConnectWithoutUserInput[]
    createMany?: RpmReadingCreateManyUserInputEnvelope
    connect?: RpmReadingWhereUniqueInput | RpmReadingWhereUniqueInput[]
  }

  export type EnumUserTypeFieldUpdateOperationsInput = {
    set?: $Enums.UserType
  }

  export type CurrentReadingUpdateManyWithoutUserNestedInput = {
    create?: XOR<CurrentReadingCreateWithoutUserInput, CurrentReadingUncheckedCreateWithoutUserInput> | CurrentReadingCreateWithoutUserInput[] | CurrentReadingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CurrentReadingCreateOrConnectWithoutUserInput | CurrentReadingCreateOrConnectWithoutUserInput[]
    upsert?: CurrentReadingUpsertWithWhereUniqueWithoutUserInput | CurrentReadingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CurrentReadingCreateManyUserInputEnvelope
    set?: CurrentReadingWhereUniqueInput | CurrentReadingWhereUniqueInput[]
    disconnect?: CurrentReadingWhereUniqueInput | CurrentReadingWhereUniqueInput[]
    delete?: CurrentReadingWhereUniqueInput | CurrentReadingWhereUniqueInput[]
    connect?: CurrentReadingWhereUniqueInput | CurrentReadingWhereUniqueInput[]
    update?: CurrentReadingUpdateWithWhereUniqueWithoutUserInput | CurrentReadingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CurrentReadingUpdateManyWithWhereWithoutUserInput | CurrentReadingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CurrentReadingScalarWhereInput | CurrentReadingScalarWhereInput[]
  }

  export type MachineUpdateManyWithoutResponsibleUserNestedInput = {
    create?: XOR<MachineCreateWithoutResponsibleUserInput, MachineUncheckedCreateWithoutResponsibleUserInput> | MachineCreateWithoutResponsibleUserInput[] | MachineUncheckedCreateWithoutResponsibleUserInput[]
    connectOrCreate?: MachineCreateOrConnectWithoutResponsibleUserInput | MachineCreateOrConnectWithoutResponsibleUserInput[]
    upsert?: MachineUpsertWithWhereUniqueWithoutResponsibleUserInput | MachineUpsertWithWhereUniqueWithoutResponsibleUserInput[]
    createMany?: MachineCreateManyResponsibleUserInputEnvelope
    set?: MachineWhereUniqueInput | MachineWhereUniqueInput[]
    disconnect?: MachineWhereUniqueInput | MachineWhereUniqueInput[]
    delete?: MachineWhereUniqueInput | MachineWhereUniqueInput[]
    connect?: MachineWhereUniqueInput | MachineWhereUniqueInput[]
    update?: MachineUpdateWithWhereUniqueWithoutResponsibleUserInput | MachineUpdateWithWhereUniqueWithoutResponsibleUserInput[]
    updateMany?: MachineUpdateManyWithWhereWithoutResponsibleUserInput | MachineUpdateManyWithWhereWithoutResponsibleUserInput[]
    deleteMany?: MachineScalarWhereInput | MachineScalarWhereInput[]
  }

  export type OilLevelReadingUpdateManyWithoutUserNestedInput = {
    create?: XOR<OilLevelReadingCreateWithoutUserInput, OilLevelReadingUncheckedCreateWithoutUserInput> | OilLevelReadingCreateWithoutUserInput[] | OilLevelReadingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OilLevelReadingCreateOrConnectWithoutUserInput | OilLevelReadingCreateOrConnectWithoutUserInput[]
    upsert?: OilLevelReadingUpsertWithWhereUniqueWithoutUserInput | OilLevelReadingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OilLevelReadingCreateManyUserInputEnvelope
    set?: OilLevelReadingWhereUniqueInput | OilLevelReadingWhereUniqueInput[]
    disconnect?: OilLevelReadingWhereUniqueInput | OilLevelReadingWhereUniqueInput[]
    delete?: OilLevelReadingWhereUniqueInput | OilLevelReadingWhereUniqueInput[]
    connect?: OilLevelReadingWhereUniqueInput | OilLevelReadingWhereUniqueInput[]
    update?: OilLevelReadingUpdateWithWhereUniqueWithoutUserInput | OilLevelReadingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OilLevelReadingUpdateManyWithWhereWithoutUserInput | OilLevelReadingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OilLevelReadingScalarWhereInput | OilLevelReadingScalarWhereInput[]
  }

  export type OilTemperatureReadingUpdateManyWithoutUserNestedInput = {
    create?: XOR<OilTemperatureReadingCreateWithoutUserInput, OilTemperatureReadingUncheckedCreateWithoutUserInput> | OilTemperatureReadingCreateWithoutUserInput[] | OilTemperatureReadingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OilTemperatureReadingCreateOrConnectWithoutUserInput | OilTemperatureReadingCreateOrConnectWithoutUserInput[]
    upsert?: OilTemperatureReadingUpsertWithWhereUniqueWithoutUserInput | OilTemperatureReadingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OilTemperatureReadingCreateManyUserInputEnvelope
    set?: OilTemperatureReadingWhereUniqueInput | OilTemperatureReadingWhereUniqueInput[]
    disconnect?: OilTemperatureReadingWhereUniqueInput | OilTemperatureReadingWhereUniqueInput[]
    delete?: OilTemperatureReadingWhereUniqueInput | OilTemperatureReadingWhereUniqueInput[]
    connect?: OilTemperatureReadingWhereUniqueInput | OilTemperatureReadingWhereUniqueInput[]
    update?: OilTemperatureReadingUpdateWithWhereUniqueWithoutUserInput | OilTemperatureReadingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OilTemperatureReadingUpdateManyWithWhereWithoutUserInput | OilTemperatureReadingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OilTemperatureReadingScalarWhereInput | OilTemperatureReadingScalarWhereInput[]
  }

  export type RpmReadingUpdateManyWithoutUserNestedInput = {
    create?: XOR<RpmReadingCreateWithoutUserInput, RpmReadingUncheckedCreateWithoutUserInput> | RpmReadingCreateWithoutUserInput[] | RpmReadingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RpmReadingCreateOrConnectWithoutUserInput | RpmReadingCreateOrConnectWithoutUserInput[]
    upsert?: RpmReadingUpsertWithWhereUniqueWithoutUserInput | RpmReadingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RpmReadingCreateManyUserInputEnvelope
    set?: RpmReadingWhereUniqueInput | RpmReadingWhereUniqueInput[]
    disconnect?: RpmReadingWhereUniqueInput | RpmReadingWhereUniqueInput[]
    delete?: RpmReadingWhereUniqueInput | RpmReadingWhereUniqueInput[]
    connect?: RpmReadingWhereUniqueInput | RpmReadingWhereUniqueInput[]
    update?: RpmReadingUpdateWithWhereUniqueWithoutUserInput | RpmReadingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RpmReadingUpdateManyWithWhereWithoutUserInput | RpmReadingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RpmReadingScalarWhereInput | RpmReadingScalarWhereInput[]
  }

  export type ClientUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<ClientCreateWithoutUsersInput, ClientUncheckedCreateWithoutUsersInput>
    connectOrCreate?: ClientCreateOrConnectWithoutUsersInput
    upsert?: ClientUpsertWithoutUsersInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutUsersInput, ClientUpdateWithoutUsersInput>, ClientUncheckedUpdateWithoutUsersInput>
  }

  export type CurrentReadingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CurrentReadingCreateWithoutUserInput, CurrentReadingUncheckedCreateWithoutUserInput> | CurrentReadingCreateWithoutUserInput[] | CurrentReadingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CurrentReadingCreateOrConnectWithoutUserInput | CurrentReadingCreateOrConnectWithoutUserInput[]
    upsert?: CurrentReadingUpsertWithWhereUniqueWithoutUserInput | CurrentReadingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CurrentReadingCreateManyUserInputEnvelope
    set?: CurrentReadingWhereUniqueInput | CurrentReadingWhereUniqueInput[]
    disconnect?: CurrentReadingWhereUniqueInput | CurrentReadingWhereUniqueInput[]
    delete?: CurrentReadingWhereUniqueInput | CurrentReadingWhereUniqueInput[]
    connect?: CurrentReadingWhereUniqueInput | CurrentReadingWhereUniqueInput[]
    update?: CurrentReadingUpdateWithWhereUniqueWithoutUserInput | CurrentReadingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CurrentReadingUpdateManyWithWhereWithoutUserInput | CurrentReadingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CurrentReadingScalarWhereInput | CurrentReadingScalarWhereInput[]
  }

  export type MachineUncheckedUpdateManyWithoutResponsibleUserNestedInput = {
    create?: XOR<MachineCreateWithoutResponsibleUserInput, MachineUncheckedCreateWithoutResponsibleUserInput> | MachineCreateWithoutResponsibleUserInput[] | MachineUncheckedCreateWithoutResponsibleUserInput[]
    connectOrCreate?: MachineCreateOrConnectWithoutResponsibleUserInput | MachineCreateOrConnectWithoutResponsibleUserInput[]
    upsert?: MachineUpsertWithWhereUniqueWithoutResponsibleUserInput | MachineUpsertWithWhereUniqueWithoutResponsibleUserInput[]
    createMany?: MachineCreateManyResponsibleUserInputEnvelope
    set?: MachineWhereUniqueInput | MachineWhereUniqueInput[]
    disconnect?: MachineWhereUniqueInput | MachineWhereUniqueInput[]
    delete?: MachineWhereUniqueInput | MachineWhereUniqueInput[]
    connect?: MachineWhereUniqueInput | MachineWhereUniqueInput[]
    update?: MachineUpdateWithWhereUniqueWithoutResponsibleUserInput | MachineUpdateWithWhereUniqueWithoutResponsibleUserInput[]
    updateMany?: MachineUpdateManyWithWhereWithoutResponsibleUserInput | MachineUpdateManyWithWhereWithoutResponsibleUserInput[]
    deleteMany?: MachineScalarWhereInput | MachineScalarWhereInput[]
  }

  export type OilLevelReadingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OilLevelReadingCreateWithoutUserInput, OilLevelReadingUncheckedCreateWithoutUserInput> | OilLevelReadingCreateWithoutUserInput[] | OilLevelReadingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OilLevelReadingCreateOrConnectWithoutUserInput | OilLevelReadingCreateOrConnectWithoutUserInput[]
    upsert?: OilLevelReadingUpsertWithWhereUniqueWithoutUserInput | OilLevelReadingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OilLevelReadingCreateManyUserInputEnvelope
    set?: OilLevelReadingWhereUniqueInput | OilLevelReadingWhereUniqueInput[]
    disconnect?: OilLevelReadingWhereUniqueInput | OilLevelReadingWhereUniqueInput[]
    delete?: OilLevelReadingWhereUniqueInput | OilLevelReadingWhereUniqueInput[]
    connect?: OilLevelReadingWhereUniqueInput | OilLevelReadingWhereUniqueInput[]
    update?: OilLevelReadingUpdateWithWhereUniqueWithoutUserInput | OilLevelReadingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OilLevelReadingUpdateManyWithWhereWithoutUserInput | OilLevelReadingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OilLevelReadingScalarWhereInput | OilLevelReadingScalarWhereInput[]
  }

  export type OilTemperatureReadingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OilTemperatureReadingCreateWithoutUserInput, OilTemperatureReadingUncheckedCreateWithoutUserInput> | OilTemperatureReadingCreateWithoutUserInput[] | OilTemperatureReadingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OilTemperatureReadingCreateOrConnectWithoutUserInput | OilTemperatureReadingCreateOrConnectWithoutUserInput[]
    upsert?: OilTemperatureReadingUpsertWithWhereUniqueWithoutUserInput | OilTemperatureReadingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OilTemperatureReadingCreateManyUserInputEnvelope
    set?: OilTemperatureReadingWhereUniqueInput | OilTemperatureReadingWhereUniqueInput[]
    disconnect?: OilTemperatureReadingWhereUniqueInput | OilTemperatureReadingWhereUniqueInput[]
    delete?: OilTemperatureReadingWhereUniqueInput | OilTemperatureReadingWhereUniqueInput[]
    connect?: OilTemperatureReadingWhereUniqueInput | OilTemperatureReadingWhereUniqueInput[]
    update?: OilTemperatureReadingUpdateWithWhereUniqueWithoutUserInput | OilTemperatureReadingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OilTemperatureReadingUpdateManyWithWhereWithoutUserInput | OilTemperatureReadingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OilTemperatureReadingScalarWhereInput | OilTemperatureReadingScalarWhereInput[]
  }

  export type RpmReadingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RpmReadingCreateWithoutUserInput, RpmReadingUncheckedCreateWithoutUserInput> | RpmReadingCreateWithoutUserInput[] | RpmReadingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RpmReadingCreateOrConnectWithoutUserInput | RpmReadingCreateOrConnectWithoutUserInput[]
    upsert?: RpmReadingUpsertWithWhereUniqueWithoutUserInput | RpmReadingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RpmReadingCreateManyUserInputEnvelope
    set?: RpmReadingWhereUniqueInput | RpmReadingWhereUniqueInput[]
    disconnect?: RpmReadingWhereUniqueInput | RpmReadingWhereUniqueInput[]
    delete?: RpmReadingWhereUniqueInput | RpmReadingWhereUniqueInput[]
    connect?: RpmReadingWhereUniqueInput | RpmReadingWhereUniqueInput[]
    update?: RpmReadingUpdateWithWhereUniqueWithoutUserInput | RpmReadingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RpmReadingUpdateManyWithWhereWithoutUserInput | RpmReadingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RpmReadingScalarWhereInput | RpmReadingScalarWhereInput[]
  }

  export type UnifiedMachineStateCreateNestedManyWithoutMachineInput = {
    create?: XOR<UnifiedMachineStateCreateWithoutMachineInput, UnifiedMachineStateUncheckedCreateWithoutMachineInput> | UnifiedMachineStateCreateWithoutMachineInput[] | UnifiedMachineStateUncheckedCreateWithoutMachineInput[]
    connectOrCreate?: UnifiedMachineStateCreateOrConnectWithoutMachineInput | UnifiedMachineStateCreateOrConnectWithoutMachineInput[]
    createMany?: UnifiedMachineStateCreateManyMachineInputEnvelope
    connect?: UnifiedMachineStateWhereUniqueInput | UnifiedMachineStateWhereUniqueInput[]
  }

  export type CurrentReadingCreateNestedManyWithoutMachineInput = {
    create?: XOR<CurrentReadingCreateWithoutMachineInput, CurrentReadingUncheckedCreateWithoutMachineInput> | CurrentReadingCreateWithoutMachineInput[] | CurrentReadingUncheckedCreateWithoutMachineInput[]
    connectOrCreate?: CurrentReadingCreateOrConnectWithoutMachineInput | CurrentReadingCreateOrConnectWithoutMachineInput[]
    createMany?: CurrentReadingCreateManyMachineInputEnvelope
    connect?: CurrentReadingWhereUniqueInput | CurrentReadingWhereUniqueInput[]
  }

  export type ClientCreateNestedOneWithoutMachinesInput = {
    create?: XOR<ClientCreateWithoutMachinesInput, ClientUncheckedCreateWithoutMachinesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutMachinesInput
    connect?: ClientWhereUniqueInput
  }

  export type DeviceCreateNestedOneWithoutMachineInput = {
    create?: XOR<DeviceCreateWithoutMachineInput, DeviceUncheckedCreateWithoutMachineInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutMachineInput
    connect?: DeviceWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutResponsibleMachinesInput = {
    create?: XOR<UserCreateWithoutResponsibleMachinesInput, UserUncheckedCreateWithoutResponsibleMachinesInput>
    connectOrCreate?: UserCreateOrConnectWithoutResponsibleMachinesInput
    connect?: UserWhereUniqueInput
  }

  export type OilLevelReadingCreateNestedManyWithoutMachineInput = {
    create?: XOR<OilLevelReadingCreateWithoutMachineInput, OilLevelReadingUncheckedCreateWithoutMachineInput> | OilLevelReadingCreateWithoutMachineInput[] | OilLevelReadingUncheckedCreateWithoutMachineInput[]
    connectOrCreate?: OilLevelReadingCreateOrConnectWithoutMachineInput | OilLevelReadingCreateOrConnectWithoutMachineInput[]
    createMany?: OilLevelReadingCreateManyMachineInputEnvelope
    connect?: OilLevelReadingWhereUniqueInput | OilLevelReadingWhereUniqueInput[]
  }

  export type OilTemperatureReadingCreateNestedManyWithoutMachineInput = {
    create?: XOR<OilTemperatureReadingCreateWithoutMachineInput, OilTemperatureReadingUncheckedCreateWithoutMachineInput> | OilTemperatureReadingCreateWithoutMachineInput[] | OilTemperatureReadingUncheckedCreateWithoutMachineInput[]
    connectOrCreate?: OilTemperatureReadingCreateOrConnectWithoutMachineInput | OilTemperatureReadingCreateOrConnectWithoutMachineInput[]
    createMany?: OilTemperatureReadingCreateManyMachineInputEnvelope
    connect?: OilTemperatureReadingWhereUniqueInput | OilTemperatureReadingWhereUniqueInput[]
  }

  export type RpmReadingCreateNestedManyWithoutMachineInput = {
    create?: XOR<RpmReadingCreateWithoutMachineInput, RpmReadingUncheckedCreateWithoutMachineInput> | RpmReadingCreateWithoutMachineInput[] | RpmReadingUncheckedCreateWithoutMachineInput[]
    connectOrCreate?: RpmReadingCreateOrConnectWithoutMachineInput | RpmReadingCreateOrConnectWithoutMachineInput[]
    createMany?: RpmReadingCreateManyMachineInputEnvelope
    connect?: RpmReadingWhereUniqueInput | RpmReadingWhereUniqueInput[]
  }

  export type UnifiedMachineStateUncheckedCreateNestedManyWithoutMachineInput = {
    create?: XOR<UnifiedMachineStateCreateWithoutMachineInput, UnifiedMachineStateUncheckedCreateWithoutMachineInput> | UnifiedMachineStateCreateWithoutMachineInput[] | UnifiedMachineStateUncheckedCreateWithoutMachineInput[]
    connectOrCreate?: UnifiedMachineStateCreateOrConnectWithoutMachineInput | UnifiedMachineStateCreateOrConnectWithoutMachineInput[]
    createMany?: UnifiedMachineStateCreateManyMachineInputEnvelope
    connect?: UnifiedMachineStateWhereUniqueInput | UnifiedMachineStateWhereUniqueInput[]
  }

  export type CurrentReadingUncheckedCreateNestedManyWithoutMachineInput = {
    create?: XOR<CurrentReadingCreateWithoutMachineInput, CurrentReadingUncheckedCreateWithoutMachineInput> | CurrentReadingCreateWithoutMachineInput[] | CurrentReadingUncheckedCreateWithoutMachineInput[]
    connectOrCreate?: CurrentReadingCreateOrConnectWithoutMachineInput | CurrentReadingCreateOrConnectWithoutMachineInput[]
    createMany?: CurrentReadingCreateManyMachineInputEnvelope
    connect?: CurrentReadingWhereUniqueInput | CurrentReadingWhereUniqueInput[]
  }

  export type OilLevelReadingUncheckedCreateNestedManyWithoutMachineInput = {
    create?: XOR<OilLevelReadingCreateWithoutMachineInput, OilLevelReadingUncheckedCreateWithoutMachineInput> | OilLevelReadingCreateWithoutMachineInput[] | OilLevelReadingUncheckedCreateWithoutMachineInput[]
    connectOrCreate?: OilLevelReadingCreateOrConnectWithoutMachineInput | OilLevelReadingCreateOrConnectWithoutMachineInput[]
    createMany?: OilLevelReadingCreateManyMachineInputEnvelope
    connect?: OilLevelReadingWhereUniqueInput | OilLevelReadingWhereUniqueInput[]
  }

  export type OilTemperatureReadingUncheckedCreateNestedManyWithoutMachineInput = {
    create?: XOR<OilTemperatureReadingCreateWithoutMachineInput, OilTemperatureReadingUncheckedCreateWithoutMachineInput> | OilTemperatureReadingCreateWithoutMachineInput[] | OilTemperatureReadingUncheckedCreateWithoutMachineInput[]
    connectOrCreate?: OilTemperatureReadingCreateOrConnectWithoutMachineInput | OilTemperatureReadingCreateOrConnectWithoutMachineInput[]
    createMany?: OilTemperatureReadingCreateManyMachineInputEnvelope
    connect?: OilTemperatureReadingWhereUniqueInput | OilTemperatureReadingWhereUniqueInput[]
  }

  export type RpmReadingUncheckedCreateNestedManyWithoutMachineInput = {
    create?: XOR<RpmReadingCreateWithoutMachineInput, RpmReadingUncheckedCreateWithoutMachineInput> | RpmReadingCreateWithoutMachineInput[] | RpmReadingUncheckedCreateWithoutMachineInput[]
    connectOrCreate?: RpmReadingCreateOrConnectWithoutMachineInput | RpmReadingCreateOrConnectWithoutMachineInput[]
    createMany?: RpmReadingCreateManyMachineInputEnvelope
    connect?: RpmReadingWhereUniqueInput | RpmReadingWhereUniqueInput[]
  }

  export type UnifiedMachineStateUpdateManyWithoutMachineNestedInput = {
    create?: XOR<UnifiedMachineStateCreateWithoutMachineInput, UnifiedMachineStateUncheckedCreateWithoutMachineInput> | UnifiedMachineStateCreateWithoutMachineInput[] | UnifiedMachineStateUncheckedCreateWithoutMachineInput[]
    connectOrCreate?: UnifiedMachineStateCreateOrConnectWithoutMachineInput | UnifiedMachineStateCreateOrConnectWithoutMachineInput[]
    upsert?: UnifiedMachineStateUpsertWithWhereUniqueWithoutMachineInput | UnifiedMachineStateUpsertWithWhereUniqueWithoutMachineInput[]
    createMany?: UnifiedMachineStateCreateManyMachineInputEnvelope
    set?: UnifiedMachineStateWhereUniqueInput | UnifiedMachineStateWhereUniqueInput[]
    disconnect?: UnifiedMachineStateWhereUniqueInput | UnifiedMachineStateWhereUniqueInput[]
    delete?: UnifiedMachineStateWhereUniqueInput | UnifiedMachineStateWhereUniqueInput[]
    connect?: UnifiedMachineStateWhereUniqueInput | UnifiedMachineStateWhereUniqueInput[]
    update?: UnifiedMachineStateUpdateWithWhereUniqueWithoutMachineInput | UnifiedMachineStateUpdateWithWhereUniqueWithoutMachineInput[]
    updateMany?: UnifiedMachineStateUpdateManyWithWhereWithoutMachineInput | UnifiedMachineStateUpdateManyWithWhereWithoutMachineInput[]
    deleteMany?: UnifiedMachineStateScalarWhereInput | UnifiedMachineStateScalarWhereInput[]
  }

  export type CurrentReadingUpdateManyWithoutMachineNestedInput = {
    create?: XOR<CurrentReadingCreateWithoutMachineInput, CurrentReadingUncheckedCreateWithoutMachineInput> | CurrentReadingCreateWithoutMachineInput[] | CurrentReadingUncheckedCreateWithoutMachineInput[]
    connectOrCreate?: CurrentReadingCreateOrConnectWithoutMachineInput | CurrentReadingCreateOrConnectWithoutMachineInput[]
    upsert?: CurrentReadingUpsertWithWhereUniqueWithoutMachineInput | CurrentReadingUpsertWithWhereUniqueWithoutMachineInput[]
    createMany?: CurrentReadingCreateManyMachineInputEnvelope
    set?: CurrentReadingWhereUniqueInput | CurrentReadingWhereUniqueInput[]
    disconnect?: CurrentReadingWhereUniqueInput | CurrentReadingWhereUniqueInput[]
    delete?: CurrentReadingWhereUniqueInput | CurrentReadingWhereUniqueInput[]
    connect?: CurrentReadingWhereUniqueInput | CurrentReadingWhereUniqueInput[]
    update?: CurrentReadingUpdateWithWhereUniqueWithoutMachineInput | CurrentReadingUpdateWithWhereUniqueWithoutMachineInput[]
    updateMany?: CurrentReadingUpdateManyWithWhereWithoutMachineInput | CurrentReadingUpdateManyWithWhereWithoutMachineInput[]
    deleteMany?: CurrentReadingScalarWhereInput | CurrentReadingScalarWhereInput[]
  }

  export type ClientUpdateOneRequiredWithoutMachinesNestedInput = {
    create?: XOR<ClientCreateWithoutMachinesInput, ClientUncheckedCreateWithoutMachinesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutMachinesInput
    upsert?: ClientUpsertWithoutMachinesInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutMachinesInput, ClientUpdateWithoutMachinesInput>, ClientUncheckedUpdateWithoutMachinesInput>
  }

  export type DeviceUpdateOneWithoutMachineNestedInput = {
    create?: XOR<DeviceCreateWithoutMachineInput, DeviceUncheckedCreateWithoutMachineInput>
    connectOrCreate?: DeviceCreateOrConnectWithoutMachineInput
    upsert?: DeviceUpsertWithoutMachineInput
    disconnect?: DeviceWhereInput | boolean
    delete?: DeviceWhereInput | boolean
    connect?: DeviceWhereUniqueInput
    update?: XOR<XOR<DeviceUpdateToOneWithWhereWithoutMachineInput, DeviceUpdateWithoutMachineInput>, DeviceUncheckedUpdateWithoutMachineInput>
  }

  export type UserUpdateOneWithoutResponsibleMachinesNestedInput = {
    create?: XOR<UserCreateWithoutResponsibleMachinesInput, UserUncheckedCreateWithoutResponsibleMachinesInput>
    connectOrCreate?: UserCreateOrConnectWithoutResponsibleMachinesInput
    upsert?: UserUpsertWithoutResponsibleMachinesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutResponsibleMachinesInput, UserUpdateWithoutResponsibleMachinesInput>, UserUncheckedUpdateWithoutResponsibleMachinesInput>
  }

  export type OilLevelReadingUpdateManyWithoutMachineNestedInput = {
    create?: XOR<OilLevelReadingCreateWithoutMachineInput, OilLevelReadingUncheckedCreateWithoutMachineInput> | OilLevelReadingCreateWithoutMachineInput[] | OilLevelReadingUncheckedCreateWithoutMachineInput[]
    connectOrCreate?: OilLevelReadingCreateOrConnectWithoutMachineInput | OilLevelReadingCreateOrConnectWithoutMachineInput[]
    upsert?: OilLevelReadingUpsertWithWhereUniqueWithoutMachineInput | OilLevelReadingUpsertWithWhereUniqueWithoutMachineInput[]
    createMany?: OilLevelReadingCreateManyMachineInputEnvelope
    set?: OilLevelReadingWhereUniqueInput | OilLevelReadingWhereUniqueInput[]
    disconnect?: OilLevelReadingWhereUniqueInput | OilLevelReadingWhereUniqueInput[]
    delete?: OilLevelReadingWhereUniqueInput | OilLevelReadingWhereUniqueInput[]
    connect?: OilLevelReadingWhereUniqueInput | OilLevelReadingWhereUniqueInput[]
    update?: OilLevelReadingUpdateWithWhereUniqueWithoutMachineInput | OilLevelReadingUpdateWithWhereUniqueWithoutMachineInput[]
    updateMany?: OilLevelReadingUpdateManyWithWhereWithoutMachineInput | OilLevelReadingUpdateManyWithWhereWithoutMachineInput[]
    deleteMany?: OilLevelReadingScalarWhereInput | OilLevelReadingScalarWhereInput[]
  }

  export type OilTemperatureReadingUpdateManyWithoutMachineNestedInput = {
    create?: XOR<OilTemperatureReadingCreateWithoutMachineInput, OilTemperatureReadingUncheckedCreateWithoutMachineInput> | OilTemperatureReadingCreateWithoutMachineInput[] | OilTemperatureReadingUncheckedCreateWithoutMachineInput[]
    connectOrCreate?: OilTemperatureReadingCreateOrConnectWithoutMachineInput | OilTemperatureReadingCreateOrConnectWithoutMachineInput[]
    upsert?: OilTemperatureReadingUpsertWithWhereUniqueWithoutMachineInput | OilTemperatureReadingUpsertWithWhereUniqueWithoutMachineInput[]
    createMany?: OilTemperatureReadingCreateManyMachineInputEnvelope
    set?: OilTemperatureReadingWhereUniqueInput | OilTemperatureReadingWhereUniqueInput[]
    disconnect?: OilTemperatureReadingWhereUniqueInput | OilTemperatureReadingWhereUniqueInput[]
    delete?: OilTemperatureReadingWhereUniqueInput | OilTemperatureReadingWhereUniqueInput[]
    connect?: OilTemperatureReadingWhereUniqueInput | OilTemperatureReadingWhereUniqueInput[]
    update?: OilTemperatureReadingUpdateWithWhereUniqueWithoutMachineInput | OilTemperatureReadingUpdateWithWhereUniqueWithoutMachineInput[]
    updateMany?: OilTemperatureReadingUpdateManyWithWhereWithoutMachineInput | OilTemperatureReadingUpdateManyWithWhereWithoutMachineInput[]
    deleteMany?: OilTemperatureReadingScalarWhereInput | OilTemperatureReadingScalarWhereInput[]
  }

  export type RpmReadingUpdateManyWithoutMachineNestedInput = {
    create?: XOR<RpmReadingCreateWithoutMachineInput, RpmReadingUncheckedCreateWithoutMachineInput> | RpmReadingCreateWithoutMachineInput[] | RpmReadingUncheckedCreateWithoutMachineInput[]
    connectOrCreate?: RpmReadingCreateOrConnectWithoutMachineInput | RpmReadingCreateOrConnectWithoutMachineInput[]
    upsert?: RpmReadingUpsertWithWhereUniqueWithoutMachineInput | RpmReadingUpsertWithWhereUniqueWithoutMachineInput[]
    createMany?: RpmReadingCreateManyMachineInputEnvelope
    set?: RpmReadingWhereUniqueInput | RpmReadingWhereUniqueInput[]
    disconnect?: RpmReadingWhereUniqueInput | RpmReadingWhereUniqueInput[]
    delete?: RpmReadingWhereUniqueInput | RpmReadingWhereUniqueInput[]
    connect?: RpmReadingWhereUniqueInput | RpmReadingWhereUniqueInput[]
    update?: RpmReadingUpdateWithWhereUniqueWithoutMachineInput | RpmReadingUpdateWithWhereUniqueWithoutMachineInput[]
    updateMany?: RpmReadingUpdateManyWithWhereWithoutMachineInput | RpmReadingUpdateManyWithWhereWithoutMachineInput[]
    deleteMany?: RpmReadingScalarWhereInput | RpmReadingScalarWhereInput[]
  }

  export type UnifiedMachineStateUncheckedUpdateManyWithoutMachineNestedInput = {
    create?: XOR<UnifiedMachineStateCreateWithoutMachineInput, UnifiedMachineStateUncheckedCreateWithoutMachineInput> | UnifiedMachineStateCreateWithoutMachineInput[] | UnifiedMachineStateUncheckedCreateWithoutMachineInput[]
    connectOrCreate?: UnifiedMachineStateCreateOrConnectWithoutMachineInput | UnifiedMachineStateCreateOrConnectWithoutMachineInput[]
    upsert?: UnifiedMachineStateUpsertWithWhereUniqueWithoutMachineInput | UnifiedMachineStateUpsertWithWhereUniqueWithoutMachineInput[]
    createMany?: UnifiedMachineStateCreateManyMachineInputEnvelope
    set?: UnifiedMachineStateWhereUniqueInput | UnifiedMachineStateWhereUniqueInput[]
    disconnect?: UnifiedMachineStateWhereUniqueInput | UnifiedMachineStateWhereUniqueInput[]
    delete?: UnifiedMachineStateWhereUniqueInput | UnifiedMachineStateWhereUniqueInput[]
    connect?: UnifiedMachineStateWhereUniqueInput | UnifiedMachineStateWhereUniqueInput[]
    update?: UnifiedMachineStateUpdateWithWhereUniqueWithoutMachineInput | UnifiedMachineStateUpdateWithWhereUniqueWithoutMachineInput[]
    updateMany?: UnifiedMachineStateUpdateManyWithWhereWithoutMachineInput | UnifiedMachineStateUpdateManyWithWhereWithoutMachineInput[]
    deleteMany?: UnifiedMachineStateScalarWhereInput | UnifiedMachineStateScalarWhereInput[]
  }

  export type CurrentReadingUncheckedUpdateManyWithoutMachineNestedInput = {
    create?: XOR<CurrentReadingCreateWithoutMachineInput, CurrentReadingUncheckedCreateWithoutMachineInput> | CurrentReadingCreateWithoutMachineInput[] | CurrentReadingUncheckedCreateWithoutMachineInput[]
    connectOrCreate?: CurrentReadingCreateOrConnectWithoutMachineInput | CurrentReadingCreateOrConnectWithoutMachineInput[]
    upsert?: CurrentReadingUpsertWithWhereUniqueWithoutMachineInput | CurrentReadingUpsertWithWhereUniqueWithoutMachineInput[]
    createMany?: CurrentReadingCreateManyMachineInputEnvelope
    set?: CurrentReadingWhereUniqueInput | CurrentReadingWhereUniqueInput[]
    disconnect?: CurrentReadingWhereUniqueInput | CurrentReadingWhereUniqueInput[]
    delete?: CurrentReadingWhereUniqueInput | CurrentReadingWhereUniqueInput[]
    connect?: CurrentReadingWhereUniqueInput | CurrentReadingWhereUniqueInput[]
    update?: CurrentReadingUpdateWithWhereUniqueWithoutMachineInput | CurrentReadingUpdateWithWhereUniqueWithoutMachineInput[]
    updateMany?: CurrentReadingUpdateManyWithWhereWithoutMachineInput | CurrentReadingUpdateManyWithWhereWithoutMachineInput[]
    deleteMany?: CurrentReadingScalarWhereInput | CurrentReadingScalarWhereInput[]
  }

  export type OilLevelReadingUncheckedUpdateManyWithoutMachineNestedInput = {
    create?: XOR<OilLevelReadingCreateWithoutMachineInput, OilLevelReadingUncheckedCreateWithoutMachineInput> | OilLevelReadingCreateWithoutMachineInput[] | OilLevelReadingUncheckedCreateWithoutMachineInput[]
    connectOrCreate?: OilLevelReadingCreateOrConnectWithoutMachineInput | OilLevelReadingCreateOrConnectWithoutMachineInput[]
    upsert?: OilLevelReadingUpsertWithWhereUniqueWithoutMachineInput | OilLevelReadingUpsertWithWhereUniqueWithoutMachineInput[]
    createMany?: OilLevelReadingCreateManyMachineInputEnvelope
    set?: OilLevelReadingWhereUniqueInput | OilLevelReadingWhereUniqueInput[]
    disconnect?: OilLevelReadingWhereUniqueInput | OilLevelReadingWhereUniqueInput[]
    delete?: OilLevelReadingWhereUniqueInput | OilLevelReadingWhereUniqueInput[]
    connect?: OilLevelReadingWhereUniqueInput | OilLevelReadingWhereUniqueInput[]
    update?: OilLevelReadingUpdateWithWhereUniqueWithoutMachineInput | OilLevelReadingUpdateWithWhereUniqueWithoutMachineInput[]
    updateMany?: OilLevelReadingUpdateManyWithWhereWithoutMachineInput | OilLevelReadingUpdateManyWithWhereWithoutMachineInput[]
    deleteMany?: OilLevelReadingScalarWhereInput | OilLevelReadingScalarWhereInput[]
  }

  export type OilTemperatureReadingUncheckedUpdateManyWithoutMachineNestedInput = {
    create?: XOR<OilTemperatureReadingCreateWithoutMachineInput, OilTemperatureReadingUncheckedCreateWithoutMachineInput> | OilTemperatureReadingCreateWithoutMachineInput[] | OilTemperatureReadingUncheckedCreateWithoutMachineInput[]
    connectOrCreate?: OilTemperatureReadingCreateOrConnectWithoutMachineInput | OilTemperatureReadingCreateOrConnectWithoutMachineInput[]
    upsert?: OilTemperatureReadingUpsertWithWhereUniqueWithoutMachineInput | OilTemperatureReadingUpsertWithWhereUniqueWithoutMachineInput[]
    createMany?: OilTemperatureReadingCreateManyMachineInputEnvelope
    set?: OilTemperatureReadingWhereUniqueInput | OilTemperatureReadingWhereUniqueInput[]
    disconnect?: OilTemperatureReadingWhereUniqueInput | OilTemperatureReadingWhereUniqueInput[]
    delete?: OilTemperatureReadingWhereUniqueInput | OilTemperatureReadingWhereUniqueInput[]
    connect?: OilTemperatureReadingWhereUniqueInput | OilTemperatureReadingWhereUniqueInput[]
    update?: OilTemperatureReadingUpdateWithWhereUniqueWithoutMachineInput | OilTemperatureReadingUpdateWithWhereUniqueWithoutMachineInput[]
    updateMany?: OilTemperatureReadingUpdateManyWithWhereWithoutMachineInput | OilTemperatureReadingUpdateManyWithWhereWithoutMachineInput[]
    deleteMany?: OilTemperatureReadingScalarWhereInput | OilTemperatureReadingScalarWhereInput[]
  }

  export type RpmReadingUncheckedUpdateManyWithoutMachineNestedInput = {
    create?: XOR<RpmReadingCreateWithoutMachineInput, RpmReadingUncheckedCreateWithoutMachineInput> | RpmReadingCreateWithoutMachineInput[] | RpmReadingUncheckedCreateWithoutMachineInput[]
    connectOrCreate?: RpmReadingCreateOrConnectWithoutMachineInput | RpmReadingCreateOrConnectWithoutMachineInput[]
    upsert?: RpmReadingUpsertWithWhereUniqueWithoutMachineInput | RpmReadingUpsertWithWhereUniqueWithoutMachineInput[]
    createMany?: RpmReadingCreateManyMachineInputEnvelope
    set?: RpmReadingWhereUniqueInput | RpmReadingWhereUniqueInput[]
    disconnect?: RpmReadingWhereUniqueInput | RpmReadingWhereUniqueInput[]
    delete?: RpmReadingWhereUniqueInput | RpmReadingWhereUniqueInput[]
    connect?: RpmReadingWhereUniqueInput | RpmReadingWhereUniqueInput[]
    update?: RpmReadingUpdateWithWhereUniqueWithoutMachineInput | RpmReadingUpdateWithWhereUniqueWithoutMachineInput[]
    updateMany?: RpmReadingUpdateManyWithWhereWithoutMachineInput | RpmReadingUpdateManyWithWhereWithoutMachineInput[]
    deleteMany?: RpmReadingScalarWhereInput | RpmReadingScalarWhereInput[]
  }

  export type MachineCreateNestedOneWithoutUnifiedMachineStateInput = {
    create?: XOR<MachineCreateWithoutUnifiedMachineStateInput, MachineUncheckedCreateWithoutUnifiedMachineStateInput>
    connectOrCreate?: MachineCreateOrConnectWithoutUnifiedMachineStateInput
    connect?: MachineWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type MachineUpdateOneRequiredWithoutUnifiedMachineStateNestedInput = {
    create?: XOR<MachineCreateWithoutUnifiedMachineStateInput, MachineUncheckedCreateWithoutUnifiedMachineStateInput>
    connectOrCreate?: MachineCreateOrConnectWithoutUnifiedMachineStateInput
    upsert?: MachineUpsertWithoutUnifiedMachineStateInput
    connect?: MachineWhereUniqueInput
    update?: XOR<XOR<MachineUpdateToOneWithWhereWithoutUnifiedMachineStateInput, MachineUpdateWithoutUnifiedMachineStateInput>, MachineUncheckedUpdateWithoutUnifiedMachineStateInput>
  }

  export type GatewayCreateNestedOneWithoutResponsibleForInput = {
    create?: XOR<GatewayCreateWithoutResponsibleForInput, GatewayUncheckedCreateWithoutResponsibleForInput>
    connectOrCreate?: GatewayCreateOrConnectWithoutResponsibleForInput
    connect?: GatewayWhereUniqueInput
  }

  export type MachineCreateNestedOneWithoutDeviceInput = {
    create?: XOR<MachineCreateWithoutDeviceInput, MachineUncheckedCreateWithoutDeviceInput>
    connectOrCreate?: MachineCreateOrConnectWithoutDeviceInput
    connect?: MachineWhereUniqueInput
  }

  export type ClientCreateNestedOneWithoutDevicesInput = {
    create?: XOR<ClientCreateWithoutDevicesInput, ClientUncheckedCreateWithoutDevicesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutDevicesInput
    connect?: ClientWhereUniqueInput
  }

  export type MachineUncheckedCreateNestedOneWithoutDeviceInput = {
    create?: XOR<MachineCreateWithoutDeviceInput, MachineUncheckedCreateWithoutDeviceInput>
    connectOrCreate?: MachineCreateOrConnectWithoutDeviceInput
    connect?: MachineWhereUniqueInput
  }

  export type EnumDeviceStatusFieldUpdateOperationsInput = {
    set?: $Enums.DeviceStatus
  }

  export type GatewayUpdateOneWithoutResponsibleForNestedInput = {
    create?: XOR<GatewayCreateWithoutResponsibleForInput, GatewayUncheckedCreateWithoutResponsibleForInput>
    connectOrCreate?: GatewayCreateOrConnectWithoutResponsibleForInput
    upsert?: GatewayUpsertWithoutResponsibleForInput
    disconnect?: GatewayWhereInput | boolean
    delete?: GatewayWhereInput | boolean
    connect?: GatewayWhereUniqueInput
    update?: XOR<XOR<GatewayUpdateToOneWithWhereWithoutResponsibleForInput, GatewayUpdateWithoutResponsibleForInput>, GatewayUncheckedUpdateWithoutResponsibleForInput>
  }

  export type MachineUpdateOneWithoutDeviceNestedInput = {
    create?: XOR<MachineCreateWithoutDeviceInput, MachineUncheckedCreateWithoutDeviceInput>
    connectOrCreate?: MachineCreateOrConnectWithoutDeviceInput
    upsert?: MachineUpsertWithoutDeviceInput
    disconnect?: MachineWhereInput | boolean
    delete?: MachineWhereInput | boolean
    connect?: MachineWhereUniqueInput
    update?: XOR<XOR<MachineUpdateToOneWithWhereWithoutDeviceInput, MachineUpdateWithoutDeviceInput>, MachineUncheckedUpdateWithoutDeviceInput>
  }

  export type ClientUpdateOneRequiredWithoutDevicesNestedInput = {
    create?: XOR<ClientCreateWithoutDevicesInput, ClientUncheckedCreateWithoutDevicesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutDevicesInput
    upsert?: ClientUpsertWithoutDevicesInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutDevicesInput, ClientUpdateWithoutDevicesInput>, ClientUncheckedUpdateWithoutDevicesInput>
  }

  export type MachineUncheckedUpdateOneWithoutDeviceNestedInput = {
    create?: XOR<MachineCreateWithoutDeviceInput, MachineUncheckedCreateWithoutDeviceInput>
    connectOrCreate?: MachineCreateOrConnectWithoutDeviceInput
    upsert?: MachineUpsertWithoutDeviceInput
    disconnect?: MachineWhereInput | boolean
    delete?: MachineWhereInput | boolean
    connect?: MachineWhereUniqueInput
    update?: XOR<XOR<MachineUpdateToOneWithWhereWithoutDeviceInput, MachineUpdateWithoutDeviceInput>, MachineUncheckedUpdateWithoutDeviceInput>
  }

  export type DeviceCreateNestedManyWithoutGatewayInput = {
    create?: XOR<DeviceCreateWithoutGatewayInput, DeviceUncheckedCreateWithoutGatewayInput> | DeviceCreateWithoutGatewayInput[] | DeviceUncheckedCreateWithoutGatewayInput[]
    connectOrCreate?: DeviceCreateOrConnectWithoutGatewayInput | DeviceCreateOrConnectWithoutGatewayInput[]
    createMany?: DeviceCreateManyGatewayInputEnvelope
    connect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
  }

  export type ClientCreateNestedOneWithoutGatewaysInput = {
    create?: XOR<ClientCreateWithoutGatewaysInput, ClientUncheckedCreateWithoutGatewaysInput>
    connectOrCreate?: ClientCreateOrConnectWithoutGatewaysInput
    connect?: ClientWhereUniqueInput
  }

  export type DeviceUncheckedCreateNestedManyWithoutGatewayInput = {
    create?: XOR<DeviceCreateWithoutGatewayInput, DeviceUncheckedCreateWithoutGatewayInput> | DeviceCreateWithoutGatewayInput[] | DeviceUncheckedCreateWithoutGatewayInput[]
    connectOrCreate?: DeviceCreateOrConnectWithoutGatewayInput | DeviceCreateOrConnectWithoutGatewayInput[]
    createMany?: DeviceCreateManyGatewayInputEnvelope
    connect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
  }

  export type DeviceUpdateManyWithoutGatewayNestedInput = {
    create?: XOR<DeviceCreateWithoutGatewayInput, DeviceUncheckedCreateWithoutGatewayInput> | DeviceCreateWithoutGatewayInput[] | DeviceUncheckedCreateWithoutGatewayInput[]
    connectOrCreate?: DeviceCreateOrConnectWithoutGatewayInput | DeviceCreateOrConnectWithoutGatewayInput[]
    upsert?: DeviceUpsertWithWhereUniqueWithoutGatewayInput | DeviceUpsertWithWhereUniqueWithoutGatewayInput[]
    createMany?: DeviceCreateManyGatewayInputEnvelope
    set?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    disconnect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    delete?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    connect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    update?: DeviceUpdateWithWhereUniqueWithoutGatewayInput | DeviceUpdateWithWhereUniqueWithoutGatewayInput[]
    updateMany?: DeviceUpdateManyWithWhereWithoutGatewayInput | DeviceUpdateManyWithWhereWithoutGatewayInput[]
    deleteMany?: DeviceScalarWhereInput | DeviceScalarWhereInput[]
  }

  export type ClientUpdateOneRequiredWithoutGatewaysNestedInput = {
    create?: XOR<ClientCreateWithoutGatewaysInput, ClientUncheckedCreateWithoutGatewaysInput>
    connectOrCreate?: ClientCreateOrConnectWithoutGatewaysInput
    upsert?: ClientUpsertWithoutGatewaysInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutGatewaysInput, ClientUpdateWithoutGatewaysInput>, ClientUncheckedUpdateWithoutGatewaysInput>
  }

  export type DeviceUncheckedUpdateManyWithoutGatewayNestedInput = {
    create?: XOR<DeviceCreateWithoutGatewayInput, DeviceUncheckedCreateWithoutGatewayInput> | DeviceCreateWithoutGatewayInput[] | DeviceUncheckedCreateWithoutGatewayInput[]
    connectOrCreate?: DeviceCreateOrConnectWithoutGatewayInput | DeviceCreateOrConnectWithoutGatewayInput[]
    upsert?: DeviceUpsertWithWhereUniqueWithoutGatewayInput | DeviceUpsertWithWhereUniqueWithoutGatewayInput[]
    createMany?: DeviceCreateManyGatewayInputEnvelope
    set?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    disconnect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    delete?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    connect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    update?: DeviceUpdateWithWhereUniqueWithoutGatewayInput | DeviceUpdateWithWhereUniqueWithoutGatewayInput[]
    updateMany?: DeviceUpdateManyWithWhereWithoutGatewayInput | DeviceUpdateManyWithWhereWithoutGatewayInput[]
    deleteMany?: DeviceScalarWhereInput | DeviceScalarWhereInput[]
  }

  export type MachineCreateNestedOneWithoutRpmReadingsInput = {
    create?: XOR<MachineCreateWithoutRpmReadingsInput, MachineUncheckedCreateWithoutRpmReadingsInput>
    connectOrCreate?: MachineCreateOrConnectWithoutRpmReadingsInput
    connect?: MachineWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRpmReadingsInput = {
    create?: XOR<UserCreateWithoutRpmReadingsInput, UserUncheckedCreateWithoutRpmReadingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRpmReadingsInput
    connect?: UserWhereUniqueInput
  }

  export type MachineUpdateOneRequiredWithoutRpmReadingsNestedInput = {
    create?: XOR<MachineCreateWithoutRpmReadingsInput, MachineUncheckedCreateWithoutRpmReadingsInput>
    connectOrCreate?: MachineCreateOrConnectWithoutRpmReadingsInput
    upsert?: MachineUpsertWithoutRpmReadingsInput
    connect?: MachineWhereUniqueInput
    update?: XOR<XOR<MachineUpdateToOneWithWhereWithoutRpmReadingsInput, MachineUpdateWithoutRpmReadingsInput>, MachineUncheckedUpdateWithoutRpmReadingsInput>
  }

  export type UserUpdateOneWithoutRpmReadingsNestedInput = {
    create?: XOR<UserCreateWithoutRpmReadingsInput, UserUncheckedCreateWithoutRpmReadingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRpmReadingsInput
    upsert?: UserUpsertWithoutRpmReadingsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRpmReadingsInput, UserUpdateWithoutRpmReadingsInput>, UserUncheckedUpdateWithoutRpmReadingsInput>
  }

  export type MachineCreateNestedOneWithoutOilTemperatureReadingsInput = {
    create?: XOR<MachineCreateWithoutOilTemperatureReadingsInput, MachineUncheckedCreateWithoutOilTemperatureReadingsInput>
    connectOrCreate?: MachineCreateOrConnectWithoutOilTemperatureReadingsInput
    connect?: MachineWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOilTemperatureReadingsInput = {
    create?: XOR<UserCreateWithoutOilTemperatureReadingsInput, UserUncheckedCreateWithoutOilTemperatureReadingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOilTemperatureReadingsInput
    connect?: UserWhereUniqueInput
  }

  export type MachineUpdateOneRequiredWithoutOilTemperatureReadingsNestedInput = {
    create?: XOR<MachineCreateWithoutOilTemperatureReadingsInput, MachineUncheckedCreateWithoutOilTemperatureReadingsInput>
    connectOrCreate?: MachineCreateOrConnectWithoutOilTemperatureReadingsInput
    upsert?: MachineUpsertWithoutOilTemperatureReadingsInput
    connect?: MachineWhereUniqueInput
    update?: XOR<XOR<MachineUpdateToOneWithWhereWithoutOilTemperatureReadingsInput, MachineUpdateWithoutOilTemperatureReadingsInput>, MachineUncheckedUpdateWithoutOilTemperatureReadingsInput>
  }

  export type UserUpdateOneWithoutOilTemperatureReadingsNestedInput = {
    create?: XOR<UserCreateWithoutOilTemperatureReadingsInput, UserUncheckedCreateWithoutOilTemperatureReadingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOilTemperatureReadingsInput
    upsert?: UserUpsertWithoutOilTemperatureReadingsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOilTemperatureReadingsInput, UserUpdateWithoutOilTemperatureReadingsInput>, UserUncheckedUpdateWithoutOilTemperatureReadingsInput>
  }

  export type MachineCreateNestedOneWithoutOilLevelReadingsInput = {
    create?: XOR<MachineCreateWithoutOilLevelReadingsInput, MachineUncheckedCreateWithoutOilLevelReadingsInput>
    connectOrCreate?: MachineCreateOrConnectWithoutOilLevelReadingsInput
    connect?: MachineWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOilLevelReadingsInput = {
    create?: XOR<UserCreateWithoutOilLevelReadingsInput, UserUncheckedCreateWithoutOilLevelReadingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOilLevelReadingsInput
    connect?: UserWhereUniqueInput
  }

  export type MachineUpdateOneRequiredWithoutOilLevelReadingsNestedInput = {
    create?: XOR<MachineCreateWithoutOilLevelReadingsInput, MachineUncheckedCreateWithoutOilLevelReadingsInput>
    connectOrCreate?: MachineCreateOrConnectWithoutOilLevelReadingsInput
    upsert?: MachineUpsertWithoutOilLevelReadingsInput
    connect?: MachineWhereUniqueInput
    update?: XOR<XOR<MachineUpdateToOneWithWhereWithoutOilLevelReadingsInput, MachineUpdateWithoutOilLevelReadingsInput>, MachineUncheckedUpdateWithoutOilLevelReadingsInput>
  }

  export type UserUpdateOneWithoutOilLevelReadingsNestedInput = {
    create?: XOR<UserCreateWithoutOilLevelReadingsInput, UserUncheckedCreateWithoutOilLevelReadingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOilLevelReadingsInput
    upsert?: UserUpsertWithoutOilLevelReadingsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOilLevelReadingsInput, UserUpdateWithoutOilLevelReadingsInput>, UserUncheckedUpdateWithoutOilLevelReadingsInput>
  }

  export type MachineCreateNestedOneWithoutCurrentReadingsInput = {
    create?: XOR<MachineCreateWithoutCurrentReadingsInput, MachineUncheckedCreateWithoutCurrentReadingsInput>
    connectOrCreate?: MachineCreateOrConnectWithoutCurrentReadingsInput
    connect?: MachineWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCurrentReadingsInput = {
    create?: XOR<UserCreateWithoutCurrentReadingsInput, UserUncheckedCreateWithoutCurrentReadingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCurrentReadingsInput
    connect?: UserWhereUniqueInput
  }

  export type MachineUpdateOneRequiredWithoutCurrentReadingsNestedInput = {
    create?: XOR<MachineCreateWithoutCurrentReadingsInput, MachineUncheckedCreateWithoutCurrentReadingsInput>
    connectOrCreate?: MachineCreateOrConnectWithoutCurrentReadingsInput
    upsert?: MachineUpsertWithoutCurrentReadingsInput
    connect?: MachineWhereUniqueInput
    update?: XOR<XOR<MachineUpdateToOneWithWhereWithoutCurrentReadingsInput, MachineUpdateWithoutCurrentReadingsInput>, MachineUncheckedUpdateWithoutCurrentReadingsInput>
  }

  export type UserUpdateOneWithoutCurrentReadingsNestedInput = {
    create?: XOR<UserCreateWithoutCurrentReadingsInput, UserUncheckedCreateWithoutCurrentReadingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCurrentReadingsInput
    upsert?: UserUpsertWithoutCurrentReadingsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCurrentReadingsInput, UserUpdateWithoutCurrentReadingsInput>, UserUncheckedUpdateWithoutCurrentReadingsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusFilter<$PrismaModel> | $Enums.Status
  }

  export type NestedEnumStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusWithAggregatesFilter<$PrismaModel> | $Enums.Status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusFilter<$PrismaModel>
    _max?: NestedEnumStatusFilter<$PrismaModel>
  }

  export type NestedEnumUserTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.UserType | EnumUserTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTypeFilter<$PrismaModel> | $Enums.UserType
  }

  export type NestedEnumUserTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserType | EnumUserTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTypeWithAggregatesFilter<$PrismaModel> | $Enums.UserType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserTypeFilter<$PrismaModel>
    _max?: NestedEnumUserTypeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumDeviceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DeviceStatus | EnumDeviceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DeviceStatus[] | ListEnumDeviceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeviceStatus[] | ListEnumDeviceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDeviceStatusFilter<$PrismaModel> | $Enums.DeviceStatus
  }

  export type NestedEnumDeviceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeviceStatus | EnumDeviceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DeviceStatus[] | ListEnumDeviceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeviceStatus[] | ListEnumDeviceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDeviceStatusWithAggregatesFilter<$PrismaModel> | $Enums.DeviceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDeviceStatusFilter<$PrismaModel>
    _max?: NestedEnumDeviceStatusFilter<$PrismaModel>
  }

  export type HyperparameterArmCreateWithoutInteracoesInput = {
    id?: string
    modelName?: string | null
    version?: string | null
    temperature: number
    topP: number
    topK: number
    maxOutputTokens: number
    responseMimeType: string
    successes?: number | null
    failures?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HyperparameterArmUncheckedCreateWithoutInteracoesInput = {
    id?: string
    modelName?: string | null
    version?: string | null
    temperature: number
    topP: number
    topK: number
    maxOutputTokens: number
    responseMimeType: string
    successes?: number | null
    failures?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HyperparameterArmCreateOrConnectWithoutInteracoesInput = {
    where: HyperparameterArmWhereUniqueInput
    create: XOR<HyperparameterArmCreateWithoutInteracoesInput, HyperparameterArmUncheckedCreateWithoutInteracoesInput>
  }

  export type HyperparameterArmUpsertWithoutInteracoesInput = {
    update: XOR<HyperparameterArmUpdateWithoutInteracoesInput, HyperparameterArmUncheckedUpdateWithoutInteracoesInput>
    create: XOR<HyperparameterArmCreateWithoutInteracoesInput, HyperparameterArmUncheckedCreateWithoutInteracoesInput>
    where?: HyperparameterArmWhereInput
  }

  export type HyperparameterArmUpdateToOneWithWhereWithoutInteracoesInput = {
    where?: HyperparameterArmWhereInput
    data: XOR<HyperparameterArmUpdateWithoutInteracoesInput, HyperparameterArmUncheckedUpdateWithoutInteracoesInput>
  }

  export type HyperparameterArmUpdateWithoutInteracoesInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: FloatFieldUpdateOperationsInput | number
    topP?: FloatFieldUpdateOperationsInput | number
    topK?: IntFieldUpdateOperationsInput | number
    maxOutputTokens?: IntFieldUpdateOperationsInput | number
    responseMimeType?: StringFieldUpdateOperationsInput | string
    successes?: NullableIntFieldUpdateOperationsInput | number | null
    failures?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HyperparameterArmUncheckedUpdateWithoutInteracoesInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: FloatFieldUpdateOperationsInput | number
    topP?: FloatFieldUpdateOperationsInput | number
    topK?: IntFieldUpdateOperationsInput | number
    maxOutputTokens?: IntFieldUpdateOperationsInput | number
    responseMimeType?: StringFieldUpdateOperationsInput | string
    successes?: NullableIntFieldUpdateOperationsInput | number | null
    failures?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InteracaoIACreateWithoutHyperparameterArmInput = {
    perguntaUsuario: string
    queryMontada: string
    respostaHumanizada: string
    feedbackUsuario?: number | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type InteracaoIAUncheckedCreateWithoutHyperparameterArmInput = {
    id?: number
    perguntaUsuario: string
    queryMontada: string
    respostaHumanizada: string
    feedbackUsuario?: number | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type InteracaoIACreateOrConnectWithoutHyperparameterArmInput = {
    where: InteracaoIAWhereUniqueInput
    create: XOR<InteracaoIACreateWithoutHyperparameterArmInput, InteracaoIAUncheckedCreateWithoutHyperparameterArmInput>
  }

  export type InteracaoIACreateManyHyperparameterArmInputEnvelope = {
    data: InteracaoIACreateManyHyperparameterArmInput | InteracaoIACreateManyHyperparameterArmInput[]
    skipDuplicates?: boolean
  }

  export type InteracaoIAUpsertWithWhereUniqueWithoutHyperparameterArmInput = {
    where: InteracaoIAWhereUniqueInput
    update: XOR<InteracaoIAUpdateWithoutHyperparameterArmInput, InteracaoIAUncheckedUpdateWithoutHyperparameterArmInput>
    create: XOR<InteracaoIACreateWithoutHyperparameterArmInput, InteracaoIAUncheckedCreateWithoutHyperparameterArmInput>
  }

  export type InteracaoIAUpdateWithWhereUniqueWithoutHyperparameterArmInput = {
    where: InteracaoIAWhereUniqueInput
    data: XOR<InteracaoIAUpdateWithoutHyperparameterArmInput, InteracaoIAUncheckedUpdateWithoutHyperparameterArmInput>
  }

  export type InteracaoIAUpdateManyWithWhereWithoutHyperparameterArmInput = {
    where: InteracaoIAScalarWhereInput
    data: XOR<InteracaoIAUpdateManyMutationInput, InteracaoIAUncheckedUpdateManyWithoutHyperparameterArmInput>
  }

  export type InteracaoIAScalarWhereInput = {
    AND?: InteracaoIAScalarWhereInput | InteracaoIAScalarWhereInput[]
    OR?: InteracaoIAScalarWhereInput[]
    NOT?: InteracaoIAScalarWhereInput | InteracaoIAScalarWhereInput[]
    id?: IntFilter<"InteracaoIA"> | number
    perguntaUsuario?: StringFilter<"InteracaoIA"> | string
    queryMontada?: StringFilter<"InteracaoIA"> | string
    respostaHumanizada?: StringFilter<"InteracaoIA"> | string
    feedbackUsuario?: IntNullableFilter<"InteracaoIA"> | number | null
    criadoEm?: DateTimeFilter<"InteracaoIA"> | Date | string
    atualizadoEm?: DateTimeFilter<"InteracaoIA"> | Date | string
    hyperparameterArmId?: StringFilter<"InteracaoIA"> | string
  }

  export type MachineCreateWithoutClientInput = {
    name: string
    model?: string | null
    manufacturer?: string | null
    serialNumber: string
    status?: $Enums.Status
    UnifiedMachineState?: UnifiedMachineStateCreateNestedManyWithoutMachineInput
    currentReadings?: CurrentReadingCreateNestedManyWithoutMachineInput
    device?: DeviceCreateNestedOneWithoutMachineInput
    responsibleUser?: UserCreateNestedOneWithoutResponsibleMachinesInput
    oilLevelReadings?: OilLevelReadingCreateNestedManyWithoutMachineInput
    oilTemperatureReadings?: OilTemperatureReadingCreateNestedManyWithoutMachineInput
    rpmReadings?: RpmReadingCreateNestedManyWithoutMachineInput
  }

  export type MachineUncheckedCreateWithoutClientInput = {
    id?: number
    name: string
    model?: string | null
    manufacturer?: string | null
    serialNumber: string
    status?: $Enums.Status
    responsibleUserId?: number | null
    deviceId?: number | null
    UnifiedMachineState?: UnifiedMachineStateUncheckedCreateNestedManyWithoutMachineInput
    currentReadings?: CurrentReadingUncheckedCreateNestedManyWithoutMachineInput
    oilLevelReadings?: OilLevelReadingUncheckedCreateNestedManyWithoutMachineInput
    oilTemperatureReadings?: OilTemperatureReadingUncheckedCreateNestedManyWithoutMachineInput
    rpmReadings?: RpmReadingUncheckedCreateNestedManyWithoutMachineInput
  }

  export type MachineCreateOrConnectWithoutClientInput = {
    where: MachineWhereUniqueInput
    create: XOR<MachineCreateWithoutClientInput, MachineUncheckedCreateWithoutClientInput>
  }

  export type MachineCreateManyClientInputEnvelope = {
    data: MachineCreateManyClientInput | MachineCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutClientInput = {
    name: string
    email: string
    password: string
    userType: $Enums.UserType
    status?: $Enums.Status
    createdAt?: Date | string
    currentReadings?: CurrentReadingCreateNestedManyWithoutUserInput
    responsibleMachines?: MachineCreateNestedManyWithoutResponsibleUserInput
    oilLevelReadings?: OilLevelReadingCreateNestedManyWithoutUserInput
    oilTemperatureReadings?: OilTemperatureReadingCreateNestedManyWithoutUserInput
    rpmReadings?: RpmReadingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutClientInput = {
    id?: number
    name: string
    email: string
    password: string
    userType: $Enums.UserType
    status?: $Enums.Status
    createdAt?: Date | string
    currentReadings?: CurrentReadingUncheckedCreateNestedManyWithoutUserInput
    responsibleMachines?: MachineUncheckedCreateNestedManyWithoutResponsibleUserInput
    oilLevelReadings?: OilLevelReadingUncheckedCreateNestedManyWithoutUserInput
    oilTemperatureReadings?: OilTemperatureReadingUncheckedCreateNestedManyWithoutUserInput
    rpmReadings?: RpmReadingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutClientInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClientInput, UserUncheckedCreateWithoutClientInput>
  }

  export type UserCreateManyClientInputEnvelope = {
    data: UserCreateManyClientInput | UserCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type DeviceCreateWithoutClientInput = {
    nodeId: string
    description?: string | null
    status?: $Enums.DeviceStatus
    lastHeartbeat?: Date | string
    gateway?: GatewayCreateNestedOneWithoutResponsibleForInput
    machine?: MachineCreateNestedOneWithoutDeviceInput
  }

  export type DeviceUncheckedCreateWithoutClientInput = {
    id?: number
    nodeId: string
    description?: string | null
    status?: $Enums.DeviceStatus
    lastHeartbeat?: Date | string
    gatewayId?: number | null
    machine?: MachineUncheckedCreateNestedOneWithoutDeviceInput
  }

  export type DeviceCreateOrConnectWithoutClientInput = {
    where: DeviceWhereUniqueInput
    create: XOR<DeviceCreateWithoutClientInput, DeviceUncheckedCreateWithoutClientInput>
  }

  export type DeviceCreateManyClientInputEnvelope = {
    data: DeviceCreateManyClientInput | DeviceCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type GatewayCreateWithoutClientInput = {
    gatewayId: string
    description?: string | null
    status?: $Enums.DeviceStatus
    lastHeartbeat?: Date | string
    responsibleFor?: DeviceCreateNestedManyWithoutGatewayInput
  }

  export type GatewayUncheckedCreateWithoutClientInput = {
    id?: number
    gatewayId: string
    description?: string | null
    status?: $Enums.DeviceStatus
    lastHeartbeat?: Date | string
    responsibleFor?: DeviceUncheckedCreateNestedManyWithoutGatewayInput
  }

  export type GatewayCreateOrConnectWithoutClientInput = {
    where: GatewayWhereUniqueInput
    create: XOR<GatewayCreateWithoutClientInput, GatewayUncheckedCreateWithoutClientInput>
  }

  export type GatewayCreateManyClientInputEnvelope = {
    data: GatewayCreateManyClientInput | GatewayCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type MachineUpsertWithWhereUniqueWithoutClientInput = {
    where: MachineWhereUniqueInput
    update: XOR<MachineUpdateWithoutClientInput, MachineUncheckedUpdateWithoutClientInput>
    create: XOR<MachineCreateWithoutClientInput, MachineUncheckedCreateWithoutClientInput>
  }

  export type MachineUpdateWithWhereUniqueWithoutClientInput = {
    where: MachineWhereUniqueInput
    data: XOR<MachineUpdateWithoutClientInput, MachineUncheckedUpdateWithoutClientInput>
  }

  export type MachineUpdateManyWithWhereWithoutClientInput = {
    where: MachineScalarWhereInput
    data: XOR<MachineUpdateManyMutationInput, MachineUncheckedUpdateManyWithoutClientInput>
  }

  export type MachineScalarWhereInput = {
    AND?: MachineScalarWhereInput | MachineScalarWhereInput[]
    OR?: MachineScalarWhereInput[]
    NOT?: MachineScalarWhereInput | MachineScalarWhereInput[]
    id?: IntFilter<"Machine"> | number
    name?: StringFilter<"Machine"> | string
    model?: StringNullableFilter<"Machine"> | string | null
    manufacturer?: StringNullableFilter<"Machine"> | string | null
    serialNumber?: StringFilter<"Machine"> | string
    status?: EnumStatusFilter<"Machine"> | $Enums.Status
    clientId?: IntFilter<"Machine"> | number
    responsibleUserId?: IntNullableFilter<"Machine"> | number | null
    deviceId?: IntNullableFilter<"Machine"> | number | null
  }

  export type UserUpsertWithWhereUniqueWithoutClientInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutClientInput, UserUncheckedUpdateWithoutClientInput>
    create: XOR<UserCreateWithoutClientInput, UserUncheckedCreateWithoutClientInput>
  }

  export type UserUpdateWithWhereUniqueWithoutClientInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutClientInput, UserUncheckedUpdateWithoutClientInput>
  }

  export type UserUpdateManyWithWhereWithoutClientInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutClientInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: IntFilter<"User"> | number
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    userType?: EnumUserTypeFilter<"User"> | $Enums.UserType
    status?: EnumStatusFilter<"User"> | $Enums.Status
    clientId?: IntFilter<"User"> | number
    createdAt?: DateTimeFilter<"User"> | Date | string
  }

  export type DeviceUpsertWithWhereUniqueWithoutClientInput = {
    where: DeviceWhereUniqueInput
    update: XOR<DeviceUpdateWithoutClientInput, DeviceUncheckedUpdateWithoutClientInput>
    create: XOR<DeviceCreateWithoutClientInput, DeviceUncheckedCreateWithoutClientInput>
  }

  export type DeviceUpdateWithWhereUniqueWithoutClientInput = {
    where: DeviceWhereUniqueInput
    data: XOR<DeviceUpdateWithoutClientInput, DeviceUncheckedUpdateWithoutClientInput>
  }

  export type DeviceUpdateManyWithWhereWithoutClientInput = {
    where: DeviceScalarWhereInput
    data: XOR<DeviceUpdateManyMutationInput, DeviceUncheckedUpdateManyWithoutClientInput>
  }

  export type DeviceScalarWhereInput = {
    AND?: DeviceScalarWhereInput | DeviceScalarWhereInput[]
    OR?: DeviceScalarWhereInput[]
    NOT?: DeviceScalarWhereInput | DeviceScalarWhereInput[]
    id?: IntFilter<"Device"> | number
    nodeId?: StringFilter<"Device"> | string
    description?: StringNullableFilter<"Device"> | string | null
    status?: EnumDeviceStatusFilter<"Device"> | $Enums.DeviceStatus
    lastHeartbeat?: DateTimeFilter<"Device"> | Date | string
    gatewayId?: IntNullableFilter<"Device"> | number | null
    clientId?: IntFilter<"Device"> | number
  }

  export type GatewayUpsertWithWhereUniqueWithoutClientInput = {
    where: GatewayWhereUniqueInput
    update: XOR<GatewayUpdateWithoutClientInput, GatewayUncheckedUpdateWithoutClientInput>
    create: XOR<GatewayCreateWithoutClientInput, GatewayUncheckedCreateWithoutClientInput>
  }

  export type GatewayUpdateWithWhereUniqueWithoutClientInput = {
    where: GatewayWhereUniqueInput
    data: XOR<GatewayUpdateWithoutClientInput, GatewayUncheckedUpdateWithoutClientInput>
  }

  export type GatewayUpdateManyWithWhereWithoutClientInput = {
    where: GatewayScalarWhereInput
    data: XOR<GatewayUpdateManyMutationInput, GatewayUncheckedUpdateManyWithoutClientInput>
  }

  export type GatewayScalarWhereInput = {
    AND?: GatewayScalarWhereInput | GatewayScalarWhereInput[]
    OR?: GatewayScalarWhereInput[]
    NOT?: GatewayScalarWhereInput | GatewayScalarWhereInput[]
    id?: IntFilter<"Gateway"> | number
    gatewayId?: StringFilter<"Gateway"> | string
    description?: StringNullableFilter<"Gateway"> | string | null
    status?: EnumDeviceStatusFilter<"Gateway"> | $Enums.DeviceStatus
    lastHeartbeat?: DateTimeFilter<"Gateway"> | Date | string
    clientId?: IntFilter<"Gateway"> | number
  }

  export type CurrentReadingCreateWithoutUserInput = {
    timestamp?: Date | string
    current: number
    machine: MachineCreateNestedOneWithoutCurrentReadingsInput
  }

  export type CurrentReadingUncheckedCreateWithoutUserInput = {
    id?: number
    timestamp?: Date | string
    current: number
    machineId: number
  }

  export type CurrentReadingCreateOrConnectWithoutUserInput = {
    where: CurrentReadingWhereUniqueInput
    create: XOR<CurrentReadingCreateWithoutUserInput, CurrentReadingUncheckedCreateWithoutUserInput>
  }

  export type CurrentReadingCreateManyUserInputEnvelope = {
    data: CurrentReadingCreateManyUserInput | CurrentReadingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MachineCreateWithoutResponsibleUserInput = {
    name: string
    model?: string | null
    manufacturer?: string | null
    serialNumber: string
    status?: $Enums.Status
    UnifiedMachineState?: UnifiedMachineStateCreateNestedManyWithoutMachineInput
    currentReadings?: CurrentReadingCreateNestedManyWithoutMachineInput
    client: ClientCreateNestedOneWithoutMachinesInput
    device?: DeviceCreateNestedOneWithoutMachineInput
    oilLevelReadings?: OilLevelReadingCreateNestedManyWithoutMachineInput
    oilTemperatureReadings?: OilTemperatureReadingCreateNestedManyWithoutMachineInput
    rpmReadings?: RpmReadingCreateNestedManyWithoutMachineInput
  }

  export type MachineUncheckedCreateWithoutResponsibleUserInput = {
    id?: number
    name: string
    model?: string | null
    manufacturer?: string | null
    serialNumber: string
    status?: $Enums.Status
    clientId: number
    deviceId?: number | null
    UnifiedMachineState?: UnifiedMachineStateUncheckedCreateNestedManyWithoutMachineInput
    currentReadings?: CurrentReadingUncheckedCreateNestedManyWithoutMachineInput
    oilLevelReadings?: OilLevelReadingUncheckedCreateNestedManyWithoutMachineInput
    oilTemperatureReadings?: OilTemperatureReadingUncheckedCreateNestedManyWithoutMachineInput
    rpmReadings?: RpmReadingUncheckedCreateNestedManyWithoutMachineInput
  }

  export type MachineCreateOrConnectWithoutResponsibleUserInput = {
    where: MachineWhereUniqueInput
    create: XOR<MachineCreateWithoutResponsibleUserInput, MachineUncheckedCreateWithoutResponsibleUserInput>
  }

  export type MachineCreateManyResponsibleUserInputEnvelope = {
    data: MachineCreateManyResponsibleUserInput | MachineCreateManyResponsibleUserInput[]
    skipDuplicates?: boolean
  }

  export type OilLevelReadingCreateWithoutUserInput = {
    timestamp?: Date | string
    level: number
    machine: MachineCreateNestedOneWithoutOilLevelReadingsInput
  }

  export type OilLevelReadingUncheckedCreateWithoutUserInput = {
    id?: number
    timestamp?: Date | string
    level: number
    machineId: number
  }

  export type OilLevelReadingCreateOrConnectWithoutUserInput = {
    where: OilLevelReadingWhereUniqueInput
    create: XOR<OilLevelReadingCreateWithoutUserInput, OilLevelReadingUncheckedCreateWithoutUserInput>
  }

  export type OilLevelReadingCreateManyUserInputEnvelope = {
    data: OilLevelReadingCreateManyUserInput | OilLevelReadingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OilTemperatureReadingCreateWithoutUserInput = {
    timestamp?: Date | string
    temperature: number
    machine: MachineCreateNestedOneWithoutOilTemperatureReadingsInput
  }

  export type OilTemperatureReadingUncheckedCreateWithoutUserInput = {
    id?: number
    timestamp?: Date | string
    temperature: number
    machineId: number
  }

  export type OilTemperatureReadingCreateOrConnectWithoutUserInput = {
    where: OilTemperatureReadingWhereUniqueInput
    create: XOR<OilTemperatureReadingCreateWithoutUserInput, OilTemperatureReadingUncheckedCreateWithoutUserInput>
  }

  export type OilTemperatureReadingCreateManyUserInputEnvelope = {
    data: OilTemperatureReadingCreateManyUserInput | OilTemperatureReadingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RpmReadingCreateWithoutUserInput = {
    timestamp?: Date | string
    rpm: number
    machine: MachineCreateNestedOneWithoutRpmReadingsInput
  }

  export type RpmReadingUncheckedCreateWithoutUserInput = {
    id?: number
    timestamp?: Date | string
    rpm: number
    machineId: number
  }

  export type RpmReadingCreateOrConnectWithoutUserInput = {
    where: RpmReadingWhereUniqueInput
    create: XOR<RpmReadingCreateWithoutUserInput, RpmReadingUncheckedCreateWithoutUserInput>
  }

  export type RpmReadingCreateManyUserInputEnvelope = {
    data: RpmReadingCreateManyUserInput | RpmReadingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ClientCreateWithoutUsersInput = {
    companyName: string
    cnpj: string
    phone?: string | null
    address?: string | null
    email: string
    password: string
    contractDate?: Date | string
    status?: $Enums.Status
    machines?: MachineCreateNestedManyWithoutClientInput
    devices?: DeviceCreateNestedManyWithoutClientInput
    gateways?: GatewayCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutUsersInput = {
    id?: number
    companyName: string
    cnpj: string
    phone?: string | null
    address?: string | null
    email: string
    password: string
    contractDate?: Date | string
    status?: $Enums.Status
    machines?: MachineUncheckedCreateNestedManyWithoutClientInput
    devices?: DeviceUncheckedCreateNestedManyWithoutClientInput
    gateways?: GatewayUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutUsersInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutUsersInput, ClientUncheckedCreateWithoutUsersInput>
  }

  export type CurrentReadingUpsertWithWhereUniqueWithoutUserInput = {
    where: CurrentReadingWhereUniqueInput
    update: XOR<CurrentReadingUpdateWithoutUserInput, CurrentReadingUncheckedUpdateWithoutUserInput>
    create: XOR<CurrentReadingCreateWithoutUserInput, CurrentReadingUncheckedCreateWithoutUserInput>
  }

  export type CurrentReadingUpdateWithWhereUniqueWithoutUserInput = {
    where: CurrentReadingWhereUniqueInput
    data: XOR<CurrentReadingUpdateWithoutUserInput, CurrentReadingUncheckedUpdateWithoutUserInput>
  }

  export type CurrentReadingUpdateManyWithWhereWithoutUserInput = {
    where: CurrentReadingScalarWhereInput
    data: XOR<CurrentReadingUpdateManyMutationInput, CurrentReadingUncheckedUpdateManyWithoutUserInput>
  }

  export type CurrentReadingScalarWhereInput = {
    AND?: CurrentReadingScalarWhereInput | CurrentReadingScalarWhereInput[]
    OR?: CurrentReadingScalarWhereInput[]
    NOT?: CurrentReadingScalarWhereInput | CurrentReadingScalarWhereInput[]
    id?: IntFilter<"CurrentReading"> | number
    timestamp?: DateTimeFilter<"CurrentReading"> | Date | string
    current?: FloatFilter<"CurrentReading"> | number
    machineId?: IntFilter<"CurrentReading"> | number
    userId?: IntNullableFilter<"CurrentReading"> | number | null
  }

  export type MachineUpsertWithWhereUniqueWithoutResponsibleUserInput = {
    where: MachineWhereUniqueInput
    update: XOR<MachineUpdateWithoutResponsibleUserInput, MachineUncheckedUpdateWithoutResponsibleUserInput>
    create: XOR<MachineCreateWithoutResponsibleUserInput, MachineUncheckedCreateWithoutResponsibleUserInput>
  }

  export type MachineUpdateWithWhereUniqueWithoutResponsibleUserInput = {
    where: MachineWhereUniqueInput
    data: XOR<MachineUpdateWithoutResponsibleUserInput, MachineUncheckedUpdateWithoutResponsibleUserInput>
  }

  export type MachineUpdateManyWithWhereWithoutResponsibleUserInput = {
    where: MachineScalarWhereInput
    data: XOR<MachineUpdateManyMutationInput, MachineUncheckedUpdateManyWithoutResponsibleUserInput>
  }

  export type OilLevelReadingUpsertWithWhereUniqueWithoutUserInput = {
    where: OilLevelReadingWhereUniqueInput
    update: XOR<OilLevelReadingUpdateWithoutUserInput, OilLevelReadingUncheckedUpdateWithoutUserInput>
    create: XOR<OilLevelReadingCreateWithoutUserInput, OilLevelReadingUncheckedCreateWithoutUserInput>
  }

  export type OilLevelReadingUpdateWithWhereUniqueWithoutUserInput = {
    where: OilLevelReadingWhereUniqueInput
    data: XOR<OilLevelReadingUpdateWithoutUserInput, OilLevelReadingUncheckedUpdateWithoutUserInput>
  }

  export type OilLevelReadingUpdateManyWithWhereWithoutUserInput = {
    where: OilLevelReadingScalarWhereInput
    data: XOR<OilLevelReadingUpdateManyMutationInput, OilLevelReadingUncheckedUpdateManyWithoutUserInput>
  }

  export type OilLevelReadingScalarWhereInput = {
    AND?: OilLevelReadingScalarWhereInput | OilLevelReadingScalarWhereInput[]
    OR?: OilLevelReadingScalarWhereInput[]
    NOT?: OilLevelReadingScalarWhereInput | OilLevelReadingScalarWhereInput[]
    id?: IntFilter<"OilLevelReading"> | number
    timestamp?: DateTimeFilter<"OilLevelReading"> | Date | string
    level?: FloatFilter<"OilLevelReading"> | number
    machineId?: IntFilter<"OilLevelReading"> | number
    userId?: IntNullableFilter<"OilLevelReading"> | number | null
  }

  export type OilTemperatureReadingUpsertWithWhereUniqueWithoutUserInput = {
    where: OilTemperatureReadingWhereUniqueInput
    update: XOR<OilTemperatureReadingUpdateWithoutUserInput, OilTemperatureReadingUncheckedUpdateWithoutUserInput>
    create: XOR<OilTemperatureReadingCreateWithoutUserInput, OilTemperatureReadingUncheckedCreateWithoutUserInput>
  }

  export type OilTemperatureReadingUpdateWithWhereUniqueWithoutUserInput = {
    where: OilTemperatureReadingWhereUniqueInput
    data: XOR<OilTemperatureReadingUpdateWithoutUserInput, OilTemperatureReadingUncheckedUpdateWithoutUserInput>
  }

  export type OilTemperatureReadingUpdateManyWithWhereWithoutUserInput = {
    where: OilTemperatureReadingScalarWhereInput
    data: XOR<OilTemperatureReadingUpdateManyMutationInput, OilTemperatureReadingUncheckedUpdateManyWithoutUserInput>
  }

  export type OilTemperatureReadingScalarWhereInput = {
    AND?: OilTemperatureReadingScalarWhereInput | OilTemperatureReadingScalarWhereInput[]
    OR?: OilTemperatureReadingScalarWhereInput[]
    NOT?: OilTemperatureReadingScalarWhereInput | OilTemperatureReadingScalarWhereInput[]
    id?: IntFilter<"OilTemperatureReading"> | number
    timestamp?: DateTimeFilter<"OilTemperatureReading"> | Date | string
    temperature?: FloatFilter<"OilTemperatureReading"> | number
    machineId?: IntFilter<"OilTemperatureReading"> | number
    userId?: IntNullableFilter<"OilTemperatureReading"> | number | null
  }

  export type RpmReadingUpsertWithWhereUniqueWithoutUserInput = {
    where: RpmReadingWhereUniqueInput
    update: XOR<RpmReadingUpdateWithoutUserInput, RpmReadingUncheckedUpdateWithoutUserInput>
    create: XOR<RpmReadingCreateWithoutUserInput, RpmReadingUncheckedCreateWithoutUserInput>
  }

  export type RpmReadingUpdateWithWhereUniqueWithoutUserInput = {
    where: RpmReadingWhereUniqueInput
    data: XOR<RpmReadingUpdateWithoutUserInput, RpmReadingUncheckedUpdateWithoutUserInput>
  }

  export type RpmReadingUpdateManyWithWhereWithoutUserInput = {
    where: RpmReadingScalarWhereInput
    data: XOR<RpmReadingUpdateManyMutationInput, RpmReadingUncheckedUpdateManyWithoutUserInput>
  }

  export type RpmReadingScalarWhereInput = {
    AND?: RpmReadingScalarWhereInput | RpmReadingScalarWhereInput[]
    OR?: RpmReadingScalarWhereInput[]
    NOT?: RpmReadingScalarWhereInput | RpmReadingScalarWhereInput[]
    id?: IntFilter<"RpmReading"> | number
    timestamp?: DateTimeFilter<"RpmReading"> | Date | string
    rpm?: IntFilter<"RpmReading"> | number
    machineId?: IntFilter<"RpmReading"> | number
    userId?: IntNullableFilter<"RpmReading"> | number | null
  }

  export type ClientUpsertWithoutUsersInput = {
    update: XOR<ClientUpdateWithoutUsersInput, ClientUncheckedUpdateWithoutUsersInput>
    create: XOR<ClientCreateWithoutUsersInput, ClientUncheckedCreateWithoutUsersInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutUsersInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutUsersInput, ClientUncheckedUpdateWithoutUsersInput>
  }

  export type ClientUpdateWithoutUsersInput = {
    companyName?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    contractDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    machines?: MachineUpdateManyWithoutClientNestedInput
    devices?: DeviceUpdateManyWithoutClientNestedInput
    gateways?: GatewayUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyName?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    contractDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    machines?: MachineUncheckedUpdateManyWithoutClientNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutClientNestedInput
    gateways?: GatewayUncheckedUpdateManyWithoutClientNestedInput
  }

  export type UnifiedMachineStateCreateWithoutMachineInput = {
    id?: string
    timestamp: Date | string
    current?: number | null
    rpm?: number | null
    oilTemperature?: number | null
    oilLevel?: number | null
    clusterPredict?: number | null
    clusterStrength?: number | null
    currentIsMissing?: boolean
    rpmIsMissing?: boolean
    oilTemperatureIsMissing?: boolean
    oilLevelIsMissing?: boolean
  }

  export type UnifiedMachineStateUncheckedCreateWithoutMachineInput = {
    id?: string
    timestamp: Date | string
    current?: number | null
    rpm?: number | null
    oilTemperature?: number | null
    oilLevel?: number | null
    clusterPredict?: number | null
    clusterStrength?: number | null
    currentIsMissing?: boolean
    rpmIsMissing?: boolean
    oilTemperatureIsMissing?: boolean
    oilLevelIsMissing?: boolean
  }

  export type UnifiedMachineStateCreateOrConnectWithoutMachineInput = {
    where: UnifiedMachineStateWhereUniqueInput
    create: XOR<UnifiedMachineStateCreateWithoutMachineInput, UnifiedMachineStateUncheckedCreateWithoutMachineInput>
  }

  export type UnifiedMachineStateCreateManyMachineInputEnvelope = {
    data: UnifiedMachineStateCreateManyMachineInput | UnifiedMachineStateCreateManyMachineInput[]
    skipDuplicates?: boolean
  }

  export type CurrentReadingCreateWithoutMachineInput = {
    timestamp?: Date | string
    current: number
    user?: UserCreateNestedOneWithoutCurrentReadingsInput
  }

  export type CurrentReadingUncheckedCreateWithoutMachineInput = {
    id?: number
    timestamp?: Date | string
    current: number
    userId?: number | null
  }

  export type CurrentReadingCreateOrConnectWithoutMachineInput = {
    where: CurrentReadingWhereUniqueInput
    create: XOR<CurrentReadingCreateWithoutMachineInput, CurrentReadingUncheckedCreateWithoutMachineInput>
  }

  export type CurrentReadingCreateManyMachineInputEnvelope = {
    data: CurrentReadingCreateManyMachineInput | CurrentReadingCreateManyMachineInput[]
    skipDuplicates?: boolean
  }

  export type ClientCreateWithoutMachinesInput = {
    companyName: string
    cnpj: string
    phone?: string | null
    address?: string | null
    email: string
    password: string
    contractDate?: Date | string
    status?: $Enums.Status
    users?: UserCreateNestedManyWithoutClientInput
    devices?: DeviceCreateNestedManyWithoutClientInput
    gateways?: GatewayCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutMachinesInput = {
    id?: number
    companyName: string
    cnpj: string
    phone?: string | null
    address?: string | null
    email: string
    password: string
    contractDate?: Date | string
    status?: $Enums.Status
    users?: UserUncheckedCreateNestedManyWithoutClientInput
    devices?: DeviceUncheckedCreateNestedManyWithoutClientInput
    gateways?: GatewayUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutMachinesInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutMachinesInput, ClientUncheckedCreateWithoutMachinesInput>
  }

  export type DeviceCreateWithoutMachineInput = {
    nodeId: string
    description?: string | null
    status?: $Enums.DeviceStatus
    lastHeartbeat?: Date | string
    gateway?: GatewayCreateNestedOneWithoutResponsibleForInput
    client: ClientCreateNestedOneWithoutDevicesInput
  }

  export type DeviceUncheckedCreateWithoutMachineInput = {
    id?: number
    nodeId: string
    description?: string | null
    status?: $Enums.DeviceStatus
    lastHeartbeat?: Date | string
    gatewayId?: number | null
    clientId: number
  }

  export type DeviceCreateOrConnectWithoutMachineInput = {
    where: DeviceWhereUniqueInput
    create: XOR<DeviceCreateWithoutMachineInput, DeviceUncheckedCreateWithoutMachineInput>
  }

  export type UserCreateWithoutResponsibleMachinesInput = {
    name: string
    email: string
    password: string
    userType: $Enums.UserType
    status?: $Enums.Status
    createdAt?: Date | string
    currentReadings?: CurrentReadingCreateNestedManyWithoutUserInput
    oilLevelReadings?: OilLevelReadingCreateNestedManyWithoutUserInput
    oilTemperatureReadings?: OilTemperatureReadingCreateNestedManyWithoutUserInput
    rpmReadings?: RpmReadingCreateNestedManyWithoutUserInput
    client: ClientCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutResponsibleMachinesInput = {
    id?: number
    name: string
    email: string
    password: string
    userType: $Enums.UserType
    status?: $Enums.Status
    clientId: number
    createdAt?: Date | string
    currentReadings?: CurrentReadingUncheckedCreateNestedManyWithoutUserInput
    oilLevelReadings?: OilLevelReadingUncheckedCreateNestedManyWithoutUserInput
    oilTemperatureReadings?: OilTemperatureReadingUncheckedCreateNestedManyWithoutUserInput
    rpmReadings?: RpmReadingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutResponsibleMachinesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutResponsibleMachinesInput, UserUncheckedCreateWithoutResponsibleMachinesInput>
  }

  export type OilLevelReadingCreateWithoutMachineInput = {
    timestamp?: Date | string
    level: number
    user?: UserCreateNestedOneWithoutOilLevelReadingsInput
  }

  export type OilLevelReadingUncheckedCreateWithoutMachineInput = {
    id?: number
    timestamp?: Date | string
    level: number
    userId?: number | null
  }

  export type OilLevelReadingCreateOrConnectWithoutMachineInput = {
    where: OilLevelReadingWhereUniqueInput
    create: XOR<OilLevelReadingCreateWithoutMachineInput, OilLevelReadingUncheckedCreateWithoutMachineInput>
  }

  export type OilLevelReadingCreateManyMachineInputEnvelope = {
    data: OilLevelReadingCreateManyMachineInput | OilLevelReadingCreateManyMachineInput[]
    skipDuplicates?: boolean
  }

  export type OilTemperatureReadingCreateWithoutMachineInput = {
    timestamp?: Date | string
    temperature: number
    user?: UserCreateNestedOneWithoutOilTemperatureReadingsInput
  }

  export type OilTemperatureReadingUncheckedCreateWithoutMachineInput = {
    id?: number
    timestamp?: Date | string
    temperature: number
    userId?: number | null
  }

  export type OilTemperatureReadingCreateOrConnectWithoutMachineInput = {
    where: OilTemperatureReadingWhereUniqueInput
    create: XOR<OilTemperatureReadingCreateWithoutMachineInput, OilTemperatureReadingUncheckedCreateWithoutMachineInput>
  }

  export type OilTemperatureReadingCreateManyMachineInputEnvelope = {
    data: OilTemperatureReadingCreateManyMachineInput | OilTemperatureReadingCreateManyMachineInput[]
    skipDuplicates?: boolean
  }

  export type RpmReadingCreateWithoutMachineInput = {
    timestamp?: Date | string
    rpm: number
    user?: UserCreateNestedOneWithoutRpmReadingsInput
  }

  export type RpmReadingUncheckedCreateWithoutMachineInput = {
    id?: number
    timestamp?: Date | string
    rpm: number
    userId?: number | null
  }

  export type RpmReadingCreateOrConnectWithoutMachineInput = {
    where: RpmReadingWhereUniqueInput
    create: XOR<RpmReadingCreateWithoutMachineInput, RpmReadingUncheckedCreateWithoutMachineInput>
  }

  export type RpmReadingCreateManyMachineInputEnvelope = {
    data: RpmReadingCreateManyMachineInput | RpmReadingCreateManyMachineInput[]
    skipDuplicates?: boolean
  }

  export type UnifiedMachineStateUpsertWithWhereUniqueWithoutMachineInput = {
    where: UnifiedMachineStateWhereUniqueInput
    update: XOR<UnifiedMachineStateUpdateWithoutMachineInput, UnifiedMachineStateUncheckedUpdateWithoutMachineInput>
    create: XOR<UnifiedMachineStateCreateWithoutMachineInput, UnifiedMachineStateUncheckedCreateWithoutMachineInput>
  }

  export type UnifiedMachineStateUpdateWithWhereUniqueWithoutMachineInput = {
    where: UnifiedMachineStateWhereUniqueInput
    data: XOR<UnifiedMachineStateUpdateWithoutMachineInput, UnifiedMachineStateUncheckedUpdateWithoutMachineInput>
  }

  export type UnifiedMachineStateUpdateManyWithWhereWithoutMachineInput = {
    where: UnifiedMachineStateScalarWhereInput
    data: XOR<UnifiedMachineStateUpdateManyMutationInput, UnifiedMachineStateUncheckedUpdateManyWithoutMachineInput>
  }

  export type UnifiedMachineStateScalarWhereInput = {
    AND?: UnifiedMachineStateScalarWhereInput | UnifiedMachineStateScalarWhereInput[]
    OR?: UnifiedMachineStateScalarWhereInput[]
    NOT?: UnifiedMachineStateScalarWhereInput | UnifiedMachineStateScalarWhereInput[]
    id?: StringFilter<"UnifiedMachineState"> | string
    timestamp?: DateTimeFilter<"UnifiedMachineState"> | Date | string
    machineId?: IntFilter<"UnifiedMachineState"> | number
    current?: FloatNullableFilter<"UnifiedMachineState"> | number | null
    rpm?: IntNullableFilter<"UnifiedMachineState"> | number | null
    oilTemperature?: FloatNullableFilter<"UnifiedMachineState"> | number | null
    oilLevel?: FloatNullableFilter<"UnifiedMachineState"> | number | null
    clusterPredict?: IntNullableFilter<"UnifiedMachineState"> | number | null
    clusterStrength?: FloatNullableFilter<"UnifiedMachineState"> | number | null
    currentIsMissing?: BoolFilter<"UnifiedMachineState"> | boolean
    rpmIsMissing?: BoolFilter<"UnifiedMachineState"> | boolean
    oilTemperatureIsMissing?: BoolFilter<"UnifiedMachineState"> | boolean
    oilLevelIsMissing?: BoolFilter<"UnifiedMachineState"> | boolean
  }

  export type CurrentReadingUpsertWithWhereUniqueWithoutMachineInput = {
    where: CurrentReadingWhereUniqueInput
    update: XOR<CurrentReadingUpdateWithoutMachineInput, CurrentReadingUncheckedUpdateWithoutMachineInput>
    create: XOR<CurrentReadingCreateWithoutMachineInput, CurrentReadingUncheckedCreateWithoutMachineInput>
  }

  export type CurrentReadingUpdateWithWhereUniqueWithoutMachineInput = {
    where: CurrentReadingWhereUniqueInput
    data: XOR<CurrentReadingUpdateWithoutMachineInput, CurrentReadingUncheckedUpdateWithoutMachineInput>
  }

  export type CurrentReadingUpdateManyWithWhereWithoutMachineInput = {
    where: CurrentReadingScalarWhereInput
    data: XOR<CurrentReadingUpdateManyMutationInput, CurrentReadingUncheckedUpdateManyWithoutMachineInput>
  }

  export type ClientUpsertWithoutMachinesInput = {
    update: XOR<ClientUpdateWithoutMachinesInput, ClientUncheckedUpdateWithoutMachinesInput>
    create: XOR<ClientCreateWithoutMachinesInput, ClientUncheckedCreateWithoutMachinesInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutMachinesInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutMachinesInput, ClientUncheckedUpdateWithoutMachinesInput>
  }

  export type ClientUpdateWithoutMachinesInput = {
    companyName?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    contractDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    users?: UserUpdateManyWithoutClientNestedInput
    devices?: DeviceUpdateManyWithoutClientNestedInput
    gateways?: GatewayUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutMachinesInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyName?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    contractDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    users?: UserUncheckedUpdateManyWithoutClientNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutClientNestedInput
    gateways?: GatewayUncheckedUpdateManyWithoutClientNestedInput
  }

  export type DeviceUpsertWithoutMachineInput = {
    update: XOR<DeviceUpdateWithoutMachineInput, DeviceUncheckedUpdateWithoutMachineInput>
    create: XOR<DeviceCreateWithoutMachineInput, DeviceUncheckedCreateWithoutMachineInput>
    where?: DeviceWhereInput
  }

  export type DeviceUpdateToOneWithWhereWithoutMachineInput = {
    where?: DeviceWhereInput
    data: XOR<DeviceUpdateWithoutMachineInput, DeviceUncheckedUpdateWithoutMachineInput>
  }

  export type DeviceUpdateWithoutMachineInput = {
    nodeId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    lastHeartbeat?: DateTimeFieldUpdateOperationsInput | Date | string
    gateway?: GatewayUpdateOneWithoutResponsibleForNestedInput
    client?: ClientUpdateOneRequiredWithoutDevicesNestedInput
  }

  export type DeviceUncheckedUpdateWithoutMachineInput = {
    id?: IntFieldUpdateOperationsInput | number
    nodeId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    lastHeartbeat?: DateTimeFieldUpdateOperationsInput | Date | string
    gatewayId?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: IntFieldUpdateOperationsInput | number
  }

  export type UserUpsertWithoutResponsibleMachinesInput = {
    update: XOR<UserUpdateWithoutResponsibleMachinesInput, UserUncheckedUpdateWithoutResponsibleMachinesInput>
    create: XOR<UserCreateWithoutResponsibleMachinesInput, UserUncheckedCreateWithoutResponsibleMachinesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutResponsibleMachinesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutResponsibleMachinesInput, UserUncheckedUpdateWithoutResponsibleMachinesInput>
  }

  export type UserUpdateWithoutResponsibleMachinesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentReadings?: CurrentReadingUpdateManyWithoutUserNestedInput
    oilLevelReadings?: OilLevelReadingUpdateManyWithoutUserNestedInput
    oilTemperatureReadings?: OilTemperatureReadingUpdateManyWithoutUserNestedInput
    rpmReadings?: RpmReadingUpdateManyWithoutUserNestedInput
    client?: ClientUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutResponsibleMachinesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    clientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentReadings?: CurrentReadingUncheckedUpdateManyWithoutUserNestedInput
    oilLevelReadings?: OilLevelReadingUncheckedUpdateManyWithoutUserNestedInput
    oilTemperatureReadings?: OilTemperatureReadingUncheckedUpdateManyWithoutUserNestedInput
    rpmReadings?: RpmReadingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OilLevelReadingUpsertWithWhereUniqueWithoutMachineInput = {
    where: OilLevelReadingWhereUniqueInput
    update: XOR<OilLevelReadingUpdateWithoutMachineInput, OilLevelReadingUncheckedUpdateWithoutMachineInput>
    create: XOR<OilLevelReadingCreateWithoutMachineInput, OilLevelReadingUncheckedCreateWithoutMachineInput>
  }

  export type OilLevelReadingUpdateWithWhereUniqueWithoutMachineInput = {
    where: OilLevelReadingWhereUniqueInput
    data: XOR<OilLevelReadingUpdateWithoutMachineInput, OilLevelReadingUncheckedUpdateWithoutMachineInput>
  }

  export type OilLevelReadingUpdateManyWithWhereWithoutMachineInput = {
    where: OilLevelReadingScalarWhereInput
    data: XOR<OilLevelReadingUpdateManyMutationInput, OilLevelReadingUncheckedUpdateManyWithoutMachineInput>
  }

  export type OilTemperatureReadingUpsertWithWhereUniqueWithoutMachineInput = {
    where: OilTemperatureReadingWhereUniqueInput
    update: XOR<OilTemperatureReadingUpdateWithoutMachineInput, OilTemperatureReadingUncheckedUpdateWithoutMachineInput>
    create: XOR<OilTemperatureReadingCreateWithoutMachineInput, OilTemperatureReadingUncheckedCreateWithoutMachineInput>
  }

  export type OilTemperatureReadingUpdateWithWhereUniqueWithoutMachineInput = {
    where: OilTemperatureReadingWhereUniqueInput
    data: XOR<OilTemperatureReadingUpdateWithoutMachineInput, OilTemperatureReadingUncheckedUpdateWithoutMachineInput>
  }

  export type OilTemperatureReadingUpdateManyWithWhereWithoutMachineInput = {
    where: OilTemperatureReadingScalarWhereInput
    data: XOR<OilTemperatureReadingUpdateManyMutationInput, OilTemperatureReadingUncheckedUpdateManyWithoutMachineInput>
  }

  export type RpmReadingUpsertWithWhereUniqueWithoutMachineInput = {
    where: RpmReadingWhereUniqueInput
    update: XOR<RpmReadingUpdateWithoutMachineInput, RpmReadingUncheckedUpdateWithoutMachineInput>
    create: XOR<RpmReadingCreateWithoutMachineInput, RpmReadingUncheckedCreateWithoutMachineInput>
  }

  export type RpmReadingUpdateWithWhereUniqueWithoutMachineInput = {
    where: RpmReadingWhereUniqueInput
    data: XOR<RpmReadingUpdateWithoutMachineInput, RpmReadingUncheckedUpdateWithoutMachineInput>
  }

  export type RpmReadingUpdateManyWithWhereWithoutMachineInput = {
    where: RpmReadingScalarWhereInput
    data: XOR<RpmReadingUpdateManyMutationInput, RpmReadingUncheckedUpdateManyWithoutMachineInput>
  }

  export type MachineCreateWithoutUnifiedMachineStateInput = {
    name: string
    model?: string | null
    manufacturer?: string | null
    serialNumber: string
    status?: $Enums.Status
    currentReadings?: CurrentReadingCreateNestedManyWithoutMachineInput
    client: ClientCreateNestedOneWithoutMachinesInput
    device?: DeviceCreateNestedOneWithoutMachineInput
    responsibleUser?: UserCreateNestedOneWithoutResponsibleMachinesInput
    oilLevelReadings?: OilLevelReadingCreateNestedManyWithoutMachineInput
    oilTemperatureReadings?: OilTemperatureReadingCreateNestedManyWithoutMachineInput
    rpmReadings?: RpmReadingCreateNestedManyWithoutMachineInput
  }

  export type MachineUncheckedCreateWithoutUnifiedMachineStateInput = {
    id?: number
    name: string
    model?: string | null
    manufacturer?: string | null
    serialNumber: string
    status?: $Enums.Status
    clientId: number
    responsibleUserId?: number | null
    deviceId?: number | null
    currentReadings?: CurrentReadingUncheckedCreateNestedManyWithoutMachineInput
    oilLevelReadings?: OilLevelReadingUncheckedCreateNestedManyWithoutMachineInput
    oilTemperatureReadings?: OilTemperatureReadingUncheckedCreateNestedManyWithoutMachineInput
    rpmReadings?: RpmReadingUncheckedCreateNestedManyWithoutMachineInput
  }

  export type MachineCreateOrConnectWithoutUnifiedMachineStateInput = {
    where: MachineWhereUniqueInput
    create: XOR<MachineCreateWithoutUnifiedMachineStateInput, MachineUncheckedCreateWithoutUnifiedMachineStateInput>
  }

  export type MachineUpsertWithoutUnifiedMachineStateInput = {
    update: XOR<MachineUpdateWithoutUnifiedMachineStateInput, MachineUncheckedUpdateWithoutUnifiedMachineStateInput>
    create: XOR<MachineCreateWithoutUnifiedMachineStateInput, MachineUncheckedCreateWithoutUnifiedMachineStateInput>
    where?: MachineWhereInput
  }

  export type MachineUpdateToOneWithWhereWithoutUnifiedMachineStateInput = {
    where?: MachineWhereInput
    data: XOR<MachineUpdateWithoutUnifiedMachineStateInput, MachineUncheckedUpdateWithoutUnifiedMachineStateInput>
  }

  export type MachineUpdateWithoutUnifiedMachineStateInput = {
    name?: StringFieldUpdateOperationsInput | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    currentReadings?: CurrentReadingUpdateManyWithoutMachineNestedInput
    client?: ClientUpdateOneRequiredWithoutMachinesNestedInput
    device?: DeviceUpdateOneWithoutMachineNestedInput
    responsibleUser?: UserUpdateOneWithoutResponsibleMachinesNestedInput
    oilLevelReadings?: OilLevelReadingUpdateManyWithoutMachineNestedInput
    oilTemperatureReadings?: OilTemperatureReadingUpdateManyWithoutMachineNestedInput
    rpmReadings?: RpmReadingUpdateManyWithoutMachineNestedInput
  }

  export type MachineUncheckedUpdateWithoutUnifiedMachineStateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    clientId?: IntFieldUpdateOperationsInput | number
    responsibleUserId?: NullableIntFieldUpdateOperationsInput | number | null
    deviceId?: NullableIntFieldUpdateOperationsInput | number | null
    currentReadings?: CurrentReadingUncheckedUpdateManyWithoutMachineNestedInput
    oilLevelReadings?: OilLevelReadingUncheckedUpdateManyWithoutMachineNestedInput
    oilTemperatureReadings?: OilTemperatureReadingUncheckedUpdateManyWithoutMachineNestedInput
    rpmReadings?: RpmReadingUncheckedUpdateManyWithoutMachineNestedInput
  }

  export type GatewayCreateWithoutResponsibleForInput = {
    gatewayId: string
    description?: string | null
    status?: $Enums.DeviceStatus
    lastHeartbeat?: Date | string
    client: ClientCreateNestedOneWithoutGatewaysInput
  }

  export type GatewayUncheckedCreateWithoutResponsibleForInput = {
    id?: number
    gatewayId: string
    description?: string | null
    status?: $Enums.DeviceStatus
    lastHeartbeat?: Date | string
    clientId: number
  }

  export type GatewayCreateOrConnectWithoutResponsibleForInput = {
    where: GatewayWhereUniqueInput
    create: XOR<GatewayCreateWithoutResponsibleForInput, GatewayUncheckedCreateWithoutResponsibleForInput>
  }

  export type MachineCreateWithoutDeviceInput = {
    name: string
    model?: string | null
    manufacturer?: string | null
    serialNumber: string
    status?: $Enums.Status
    UnifiedMachineState?: UnifiedMachineStateCreateNestedManyWithoutMachineInput
    currentReadings?: CurrentReadingCreateNestedManyWithoutMachineInput
    client: ClientCreateNestedOneWithoutMachinesInput
    responsibleUser?: UserCreateNestedOneWithoutResponsibleMachinesInput
    oilLevelReadings?: OilLevelReadingCreateNestedManyWithoutMachineInput
    oilTemperatureReadings?: OilTemperatureReadingCreateNestedManyWithoutMachineInput
    rpmReadings?: RpmReadingCreateNestedManyWithoutMachineInput
  }

  export type MachineUncheckedCreateWithoutDeviceInput = {
    id?: number
    name: string
    model?: string | null
    manufacturer?: string | null
    serialNumber: string
    status?: $Enums.Status
    clientId: number
    responsibleUserId?: number | null
    UnifiedMachineState?: UnifiedMachineStateUncheckedCreateNestedManyWithoutMachineInput
    currentReadings?: CurrentReadingUncheckedCreateNestedManyWithoutMachineInput
    oilLevelReadings?: OilLevelReadingUncheckedCreateNestedManyWithoutMachineInput
    oilTemperatureReadings?: OilTemperatureReadingUncheckedCreateNestedManyWithoutMachineInput
    rpmReadings?: RpmReadingUncheckedCreateNestedManyWithoutMachineInput
  }

  export type MachineCreateOrConnectWithoutDeviceInput = {
    where: MachineWhereUniqueInput
    create: XOR<MachineCreateWithoutDeviceInput, MachineUncheckedCreateWithoutDeviceInput>
  }

  export type ClientCreateWithoutDevicesInput = {
    companyName: string
    cnpj: string
    phone?: string | null
    address?: string | null
    email: string
    password: string
    contractDate?: Date | string
    status?: $Enums.Status
    machines?: MachineCreateNestedManyWithoutClientInput
    users?: UserCreateNestedManyWithoutClientInput
    gateways?: GatewayCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutDevicesInput = {
    id?: number
    companyName: string
    cnpj: string
    phone?: string | null
    address?: string | null
    email: string
    password: string
    contractDate?: Date | string
    status?: $Enums.Status
    machines?: MachineUncheckedCreateNestedManyWithoutClientInput
    users?: UserUncheckedCreateNestedManyWithoutClientInput
    gateways?: GatewayUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutDevicesInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutDevicesInput, ClientUncheckedCreateWithoutDevicesInput>
  }

  export type GatewayUpsertWithoutResponsibleForInput = {
    update: XOR<GatewayUpdateWithoutResponsibleForInput, GatewayUncheckedUpdateWithoutResponsibleForInput>
    create: XOR<GatewayCreateWithoutResponsibleForInput, GatewayUncheckedCreateWithoutResponsibleForInput>
    where?: GatewayWhereInput
  }

  export type GatewayUpdateToOneWithWhereWithoutResponsibleForInput = {
    where?: GatewayWhereInput
    data: XOR<GatewayUpdateWithoutResponsibleForInput, GatewayUncheckedUpdateWithoutResponsibleForInput>
  }

  export type GatewayUpdateWithoutResponsibleForInput = {
    gatewayId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    lastHeartbeat?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutGatewaysNestedInput
  }

  export type GatewayUncheckedUpdateWithoutResponsibleForInput = {
    id?: IntFieldUpdateOperationsInput | number
    gatewayId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    lastHeartbeat?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: IntFieldUpdateOperationsInput | number
  }

  export type MachineUpsertWithoutDeviceInput = {
    update: XOR<MachineUpdateWithoutDeviceInput, MachineUncheckedUpdateWithoutDeviceInput>
    create: XOR<MachineCreateWithoutDeviceInput, MachineUncheckedCreateWithoutDeviceInput>
    where?: MachineWhereInput
  }

  export type MachineUpdateToOneWithWhereWithoutDeviceInput = {
    where?: MachineWhereInput
    data: XOR<MachineUpdateWithoutDeviceInput, MachineUncheckedUpdateWithoutDeviceInput>
  }

  export type MachineUpdateWithoutDeviceInput = {
    name?: StringFieldUpdateOperationsInput | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    UnifiedMachineState?: UnifiedMachineStateUpdateManyWithoutMachineNestedInput
    currentReadings?: CurrentReadingUpdateManyWithoutMachineNestedInput
    client?: ClientUpdateOneRequiredWithoutMachinesNestedInput
    responsibleUser?: UserUpdateOneWithoutResponsibleMachinesNestedInput
    oilLevelReadings?: OilLevelReadingUpdateManyWithoutMachineNestedInput
    oilTemperatureReadings?: OilTemperatureReadingUpdateManyWithoutMachineNestedInput
    rpmReadings?: RpmReadingUpdateManyWithoutMachineNestedInput
  }

  export type MachineUncheckedUpdateWithoutDeviceInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    clientId?: IntFieldUpdateOperationsInput | number
    responsibleUserId?: NullableIntFieldUpdateOperationsInput | number | null
    UnifiedMachineState?: UnifiedMachineStateUncheckedUpdateManyWithoutMachineNestedInput
    currentReadings?: CurrentReadingUncheckedUpdateManyWithoutMachineNestedInput
    oilLevelReadings?: OilLevelReadingUncheckedUpdateManyWithoutMachineNestedInput
    oilTemperatureReadings?: OilTemperatureReadingUncheckedUpdateManyWithoutMachineNestedInput
    rpmReadings?: RpmReadingUncheckedUpdateManyWithoutMachineNestedInput
  }

  export type ClientUpsertWithoutDevicesInput = {
    update: XOR<ClientUpdateWithoutDevicesInput, ClientUncheckedUpdateWithoutDevicesInput>
    create: XOR<ClientCreateWithoutDevicesInput, ClientUncheckedCreateWithoutDevicesInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutDevicesInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutDevicesInput, ClientUncheckedUpdateWithoutDevicesInput>
  }

  export type ClientUpdateWithoutDevicesInput = {
    companyName?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    contractDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    machines?: MachineUpdateManyWithoutClientNestedInput
    users?: UserUpdateManyWithoutClientNestedInput
    gateways?: GatewayUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutDevicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyName?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    contractDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    machines?: MachineUncheckedUpdateManyWithoutClientNestedInput
    users?: UserUncheckedUpdateManyWithoutClientNestedInput
    gateways?: GatewayUncheckedUpdateManyWithoutClientNestedInput
  }

  export type DeviceCreateWithoutGatewayInput = {
    nodeId: string
    description?: string | null
    status?: $Enums.DeviceStatus
    lastHeartbeat?: Date | string
    machine?: MachineCreateNestedOneWithoutDeviceInput
    client: ClientCreateNestedOneWithoutDevicesInput
  }

  export type DeviceUncheckedCreateWithoutGatewayInput = {
    id?: number
    nodeId: string
    description?: string | null
    status?: $Enums.DeviceStatus
    lastHeartbeat?: Date | string
    clientId: number
    machine?: MachineUncheckedCreateNestedOneWithoutDeviceInput
  }

  export type DeviceCreateOrConnectWithoutGatewayInput = {
    where: DeviceWhereUniqueInput
    create: XOR<DeviceCreateWithoutGatewayInput, DeviceUncheckedCreateWithoutGatewayInput>
  }

  export type DeviceCreateManyGatewayInputEnvelope = {
    data: DeviceCreateManyGatewayInput | DeviceCreateManyGatewayInput[]
    skipDuplicates?: boolean
  }

  export type ClientCreateWithoutGatewaysInput = {
    companyName: string
    cnpj: string
    phone?: string | null
    address?: string | null
    email: string
    password: string
    contractDate?: Date | string
    status?: $Enums.Status
    machines?: MachineCreateNestedManyWithoutClientInput
    users?: UserCreateNestedManyWithoutClientInput
    devices?: DeviceCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutGatewaysInput = {
    id?: number
    companyName: string
    cnpj: string
    phone?: string | null
    address?: string | null
    email: string
    password: string
    contractDate?: Date | string
    status?: $Enums.Status
    machines?: MachineUncheckedCreateNestedManyWithoutClientInput
    users?: UserUncheckedCreateNestedManyWithoutClientInput
    devices?: DeviceUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutGatewaysInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutGatewaysInput, ClientUncheckedCreateWithoutGatewaysInput>
  }

  export type DeviceUpsertWithWhereUniqueWithoutGatewayInput = {
    where: DeviceWhereUniqueInput
    update: XOR<DeviceUpdateWithoutGatewayInput, DeviceUncheckedUpdateWithoutGatewayInput>
    create: XOR<DeviceCreateWithoutGatewayInput, DeviceUncheckedCreateWithoutGatewayInput>
  }

  export type DeviceUpdateWithWhereUniqueWithoutGatewayInput = {
    where: DeviceWhereUniqueInput
    data: XOR<DeviceUpdateWithoutGatewayInput, DeviceUncheckedUpdateWithoutGatewayInput>
  }

  export type DeviceUpdateManyWithWhereWithoutGatewayInput = {
    where: DeviceScalarWhereInput
    data: XOR<DeviceUpdateManyMutationInput, DeviceUncheckedUpdateManyWithoutGatewayInput>
  }

  export type ClientUpsertWithoutGatewaysInput = {
    update: XOR<ClientUpdateWithoutGatewaysInput, ClientUncheckedUpdateWithoutGatewaysInput>
    create: XOR<ClientCreateWithoutGatewaysInput, ClientUncheckedCreateWithoutGatewaysInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutGatewaysInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutGatewaysInput, ClientUncheckedUpdateWithoutGatewaysInput>
  }

  export type ClientUpdateWithoutGatewaysInput = {
    companyName?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    contractDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    machines?: MachineUpdateManyWithoutClientNestedInput
    users?: UserUpdateManyWithoutClientNestedInput
    devices?: DeviceUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutGatewaysInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyName?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    contractDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    machines?: MachineUncheckedUpdateManyWithoutClientNestedInput
    users?: UserUncheckedUpdateManyWithoutClientNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutClientNestedInput
  }

  export type MachineCreateWithoutRpmReadingsInput = {
    name: string
    model?: string | null
    manufacturer?: string | null
    serialNumber: string
    status?: $Enums.Status
    UnifiedMachineState?: UnifiedMachineStateCreateNestedManyWithoutMachineInput
    currentReadings?: CurrentReadingCreateNestedManyWithoutMachineInput
    client: ClientCreateNestedOneWithoutMachinesInput
    device?: DeviceCreateNestedOneWithoutMachineInput
    responsibleUser?: UserCreateNestedOneWithoutResponsibleMachinesInput
    oilLevelReadings?: OilLevelReadingCreateNestedManyWithoutMachineInput
    oilTemperatureReadings?: OilTemperatureReadingCreateNestedManyWithoutMachineInput
  }

  export type MachineUncheckedCreateWithoutRpmReadingsInput = {
    id?: number
    name: string
    model?: string | null
    manufacturer?: string | null
    serialNumber: string
    status?: $Enums.Status
    clientId: number
    responsibleUserId?: number | null
    deviceId?: number | null
    UnifiedMachineState?: UnifiedMachineStateUncheckedCreateNestedManyWithoutMachineInput
    currentReadings?: CurrentReadingUncheckedCreateNestedManyWithoutMachineInput
    oilLevelReadings?: OilLevelReadingUncheckedCreateNestedManyWithoutMachineInput
    oilTemperatureReadings?: OilTemperatureReadingUncheckedCreateNestedManyWithoutMachineInput
  }

  export type MachineCreateOrConnectWithoutRpmReadingsInput = {
    where: MachineWhereUniqueInput
    create: XOR<MachineCreateWithoutRpmReadingsInput, MachineUncheckedCreateWithoutRpmReadingsInput>
  }

  export type UserCreateWithoutRpmReadingsInput = {
    name: string
    email: string
    password: string
    userType: $Enums.UserType
    status?: $Enums.Status
    createdAt?: Date | string
    currentReadings?: CurrentReadingCreateNestedManyWithoutUserInput
    responsibleMachines?: MachineCreateNestedManyWithoutResponsibleUserInput
    oilLevelReadings?: OilLevelReadingCreateNestedManyWithoutUserInput
    oilTemperatureReadings?: OilTemperatureReadingCreateNestedManyWithoutUserInput
    client: ClientCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutRpmReadingsInput = {
    id?: number
    name: string
    email: string
    password: string
    userType: $Enums.UserType
    status?: $Enums.Status
    clientId: number
    createdAt?: Date | string
    currentReadings?: CurrentReadingUncheckedCreateNestedManyWithoutUserInput
    responsibleMachines?: MachineUncheckedCreateNestedManyWithoutResponsibleUserInput
    oilLevelReadings?: OilLevelReadingUncheckedCreateNestedManyWithoutUserInput
    oilTemperatureReadings?: OilTemperatureReadingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRpmReadingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRpmReadingsInput, UserUncheckedCreateWithoutRpmReadingsInput>
  }

  export type MachineUpsertWithoutRpmReadingsInput = {
    update: XOR<MachineUpdateWithoutRpmReadingsInput, MachineUncheckedUpdateWithoutRpmReadingsInput>
    create: XOR<MachineCreateWithoutRpmReadingsInput, MachineUncheckedCreateWithoutRpmReadingsInput>
    where?: MachineWhereInput
  }

  export type MachineUpdateToOneWithWhereWithoutRpmReadingsInput = {
    where?: MachineWhereInput
    data: XOR<MachineUpdateWithoutRpmReadingsInput, MachineUncheckedUpdateWithoutRpmReadingsInput>
  }

  export type MachineUpdateWithoutRpmReadingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    UnifiedMachineState?: UnifiedMachineStateUpdateManyWithoutMachineNestedInput
    currentReadings?: CurrentReadingUpdateManyWithoutMachineNestedInput
    client?: ClientUpdateOneRequiredWithoutMachinesNestedInput
    device?: DeviceUpdateOneWithoutMachineNestedInput
    responsibleUser?: UserUpdateOneWithoutResponsibleMachinesNestedInput
    oilLevelReadings?: OilLevelReadingUpdateManyWithoutMachineNestedInput
    oilTemperatureReadings?: OilTemperatureReadingUpdateManyWithoutMachineNestedInput
  }

  export type MachineUncheckedUpdateWithoutRpmReadingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    clientId?: IntFieldUpdateOperationsInput | number
    responsibleUserId?: NullableIntFieldUpdateOperationsInput | number | null
    deviceId?: NullableIntFieldUpdateOperationsInput | number | null
    UnifiedMachineState?: UnifiedMachineStateUncheckedUpdateManyWithoutMachineNestedInput
    currentReadings?: CurrentReadingUncheckedUpdateManyWithoutMachineNestedInput
    oilLevelReadings?: OilLevelReadingUncheckedUpdateManyWithoutMachineNestedInput
    oilTemperatureReadings?: OilTemperatureReadingUncheckedUpdateManyWithoutMachineNestedInput
  }

  export type UserUpsertWithoutRpmReadingsInput = {
    update: XOR<UserUpdateWithoutRpmReadingsInput, UserUncheckedUpdateWithoutRpmReadingsInput>
    create: XOR<UserCreateWithoutRpmReadingsInput, UserUncheckedCreateWithoutRpmReadingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRpmReadingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRpmReadingsInput, UserUncheckedUpdateWithoutRpmReadingsInput>
  }

  export type UserUpdateWithoutRpmReadingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentReadings?: CurrentReadingUpdateManyWithoutUserNestedInput
    responsibleMachines?: MachineUpdateManyWithoutResponsibleUserNestedInput
    oilLevelReadings?: OilLevelReadingUpdateManyWithoutUserNestedInput
    oilTemperatureReadings?: OilTemperatureReadingUpdateManyWithoutUserNestedInput
    client?: ClientUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutRpmReadingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    clientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentReadings?: CurrentReadingUncheckedUpdateManyWithoutUserNestedInput
    responsibleMachines?: MachineUncheckedUpdateManyWithoutResponsibleUserNestedInput
    oilLevelReadings?: OilLevelReadingUncheckedUpdateManyWithoutUserNestedInput
    oilTemperatureReadings?: OilTemperatureReadingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MachineCreateWithoutOilTemperatureReadingsInput = {
    name: string
    model?: string | null
    manufacturer?: string | null
    serialNumber: string
    status?: $Enums.Status
    UnifiedMachineState?: UnifiedMachineStateCreateNestedManyWithoutMachineInput
    currentReadings?: CurrentReadingCreateNestedManyWithoutMachineInput
    client: ClientCreateNestedOneWithoutMachinesInput
    device?: DeviceCreateNestedOneWithoutMachineInput
    responsibleUser?: UserCreateNestedOneWithoutResponsibleMachinesInput
    oilLevelReadings?: OilLevelReadingCreateNestedManyWithoutMachineInput
    rpmReadings?: RpmReadingCreateNestedManyWithoutMachineInput
  }

  export type MachineUncheckedCreateWithoutOilTemperatureReadingsInput = {
    id?: number
    name: string
    model?: string | null
    manufacturer?: string | null
    serialNumber: string
    status?: $Enums.Status
    clientId: number
    responsibleUserId?: number | null
    deviceId?: number | null
    UnifiedMachineState?: UnifiedMachineStateUncheckedCreateNestedManyWithoutMachineInput
    currentReadings?: CurrentReadingUncheckedCreateNestedManyWithoutMachineInput
    oilLevelReadings?: OilLevelReadingUncheckedCreateNestedManyWithoutMachineInput
    rpmReadings?: RpmReadingUncheckedCreateNestedManyWithoutMachineInput
  }

  export type MachineCreateOrConnectWithoutOilTemperatureReadingsInput = {
    where: MachineWhereUniqueInput
    create: XOR<MachineCreateWithoutOilTemperatureReadingsInput, MachineUncheckedCreateWithoutOilTemperatureReadingsInput>
  }

  export type UserCreateWithoutOilTemperatureReadingsInput = {
    name: string
    email: string
    password: string
    userType: $Enums.UserType
    status?: $Enums.Status
    createdAt?: Date | string
    currentReadings?: CurrentReadingCreateNestedManyWithoutUserInput
    responsibleMachines?: MachineCreateNestedManyWithoutResponsibleUserInput
    oilLevelReadings?: OilLevelReadingCreateNestedManyWithoutUserInput
    rpmReadings?: RpmReadingCreateNestedManyWithoutUserInput
    client: ClientCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutOilTemperatureReadingsInput = {
    id?: number
    name: string
    email: string
    password: string
    userType: $Enums.UserType
    status?: $Enums.Status
    clientId: number
    createdAt?: Date | string
    currentReadings?: CurrentReadingUncheckedCreateNestedManyWithoutUserInput
    responsibleMachines?: MachineUncheckedCreateNestedManyWithoutResponsibleUserInput
    oilLevelReadings?: OilLevelReadingUncheckedCreateNestedManyWithoutUserInput
    rpmReadings?: RpmReadingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOilTemperatureReadingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOilTemperatureReadingsInput, UserUncheckedCreateWithoutOilTemperatureReadingsInput>
  }

  export type MachineUpsertWithoutOilTemperatureReadingsInput = {
    update: XOR<MachineUpdateWithoutOilTemperatureReadingsInput, MachineUncheckedUpdateWithoutOilTemperatureReadingsInput>
    create: XOR<MachineCreateWithoutOilTemperatureReadingsInput, MachineUncheckedCreateWithoutOilTemperatureReadingsInput>
    where?: MachineWhereInput
  }

  export type MachineUpdateToOneWithWhereWithoutOilTemperatureReadingsInput = {
    where?: MachineWhereInput
    data: XOR<MachineUpdateWithoutOilTemperatureReadingsInput, MachineUncheckedUpdateWithoutOilTemperatureReadingsInput>
  }

  export type MachineUpdateWithoutOilTemperatureReadingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    UnifiedMachineState?: UnifiedMachineStateUpdateManyWithoutMachineNestedInput
    currentReadings?: CurrentReadingUpdateManyWithoutMachineNestedInput
    client?: ClientUpdateOneRequiredWithoutMachinesNestedInput
    device?: DeviceUpdateOneWithoutMachineNestedInput
    responsibleUser?: UserUpdateOneWithoutResponsibleMachinesNestedInput
    oilLevelReadings?: OilLevelReadingUpdateManyWithoutMachineNestedInput
    rpmReadings?: RpmReadingUpdateManyWithoutMachineNestedInput
  }

  export type MachineUncheckedUpdateWithoutOilTemperatureReadingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    clientId?: IntFieldUpdateOperationsInput | number
    responsibleUserId?: NullableIntFieldUpdateOperationsInput | number | null
    deviceId?: NullableIntFieldUpdateOperationsInput | number | null
    UnifiedMachineState?: UnifiedMachineStateUncheckedUpdateManyWithoutMachineNestedInput
    currentReadings?: CurrentReadingUncheckedUpdateManyWithoutMachineNestedInput
    oilLevelReadings?: OilLevelReadingUncheckedUpdateManyWithoutMachineNestedInput
    rpmReadings?: RpmReadingUncheckedUpdateManyWithoutMachineNestedInput
  }

  export type UserUpsertWithoutOilTemperatureReadingsInput = {
    update: XOR<UserUpdateWithoutOilTemperatureReadingsInput, UserUncheckedUpdateWithoutOilTemperatureReadingsInput>
    create: XOR<UserCreateWithoutOilTemperatureReadingsInput, UserUncheckedCreateWithoutOilTemperatureReadingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOilTemperatureReadingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOilTemperatureReadingsInput, UserUncheckedUpdateWithoutOilTemperatureReadingsInput>
  }

  export type UserUpdateWithoutOilTemperatureReadingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentReadings?: CurrentReadingUpdateManyWithoutUserNestedInput
    responsibleMachines?: MachineUpdateManyWithoutResponsibleUserNestedInput
    oilLevelReadings?: OilLevelReadingUpdateManyWithoutUserNestedInput
    rpmReadings?: RpmReadingUpdateManyWithoutUserNestedInput
    client?: ClientUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutOilTemperatureReadingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    clientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentReadings?: CurrentReadingUncheckedUpdateManyWithoutUserNestedInput
    responsibleMachines?: MachineUncheckedUpdateManyWithoutResponsibleUserNestedInput
    oilLevelReadings?: OilLevelReadingUncheckedUpdateManyWithoutUserNestedInput
    rpmReadings?: RpmReadingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MachineCreateWithoutOilLevelReadingsInput = {
    name: string
    model?: string | null
    manufacturer?: string | null
    serialNumber: string
    status?: $Enums.Status
    UnifiedMachineState?: UnifiedMachineStateCreateNestedManyWithoutMachineInput
    currentReadings?: CurrentReadingCreateNestedManyWithoutMachineInput
    client: ClientCreateNestedOneWithoutMachinesInput
    device?: DeviceCreateNestedOneWithoutMachineInput
    responsibleUser?: UserCreateNestedOneWithoutResponsibleMachinesInput
    oilTemperatureReadings?: OilTemperatureReadingCreateNestedManyWithoutMachineInput
    rpmReadings?: RpmReadingCreateNestedManyWithoutMachineInput
  }

  export type MachineUncheckedCreateWithoutOilLevelReadingsInput = {
    id?: number
    name: string
    model?: string | null
    manufacturer?: string | null
    serialNumber: string
    status?: $Enums.Status
    clientId: number
    responsibleUserId?: number | null
    deviceId?: number | null
    UnifiedMachineState?: UnifiedMachineStateUncheckedCreateNestedManyWithoutMachineInput
    currentReadings?: CurrentReadingUncheckedCreateNestedManyWithoutMachineInput
    oilTemperatureReadings?: OilTemperatureReadingUncheckedCreateNestedManyWithoutMachineInput
    rpmReadings?: RpmReadingUncheckedCreateNestedManyWithoutMachineInput
  }

  export type MachineCreateOrConnectWithoutOilLevelReadingsInput = {
    where: MachineWhereUniqueInput
    create: XOR<MachineCreateWithoutOilLevelReadingsInput, MachineUncheckedCreateWithoutOilLevelReadingsInput>
  }

  export type UserCreateWithoutOilLevelReadingsInput = {
    name: string
    email: string
    password: string
    userType: $Enums.UserType
    status?: $Enums.Status
    createdAt?: Date | string
    currentReadings?: CurrentReadingCreateNestedManyWithoutUserInput
    responsibleMachines?: MachineCreateNestedManyWithoutResponsibleUserInput
    oilTemperatureReadings?: OilTemperatureReadingCreateNestedManyWithoutUserInput
    rpmReadings?: RpmReadingCreateNestedManyWithoutUserInput
    client: ClientCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutOilLevelReadingsInput = {
    id?: number
    name: string
    email: string
    password: string
    userType: $Enums.UserType
    status?: $Enums.Status
    clientId: number
    createdAt?: Date | string
    currentReadings?: CurrentReadingUncheckedCreateNestedManyWithoutUserInput
    responsibleMachines?: MachineUncheckedCreateNestedManyWithoutResponsibleUserInput
    oilTemperatureReadings?: OilTemperatureReadingUncheckedCreateNestedManyWithoutUserInput
    rpmReadings?: RpmReadingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOilLevelReadingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOilLevelReadingsInput, UserUncheckedCreateWithoutOilLevelReadingsInput>
  }

  export type MachineUpsertWithoutOilLevelReadingsInput = {
    update: XOR<MachineUpdateWithoutOilLevelReadingsInput, MachineUncheckedUpdateWithoutOilLevelReadingsInput>
    create: XOR<MachineCreateWithoutOilLevelReadingsInput, MachineUncheckedCreateWithoutOilLevelReadingsInput>
    where?: MachineWhereInput
  }

  export type MachineUpdateToOneWithWhereWithoutOilLevelReadingsInput = {
    where?: MachineWhereInput
    data: XOR<MachineUpdateWithoutOilLevelReadingsInput, MachineUncheckedUpdateWithoutOilLevelReadingsInput>
  }

  export type MachineUpdateWithoutOilLevelReadingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    UnifiedMachineState?: UnifiedMachineStateUpdateManyWithoutMachineNestedInput
    currentReadings?: CurrentReadingUpdateManyWithoutMachineNestedInput
    client?: ClientUpdateOneRequiredWithoutMachinesNestedInput
    device?: DeviceUpdateOneWithoutMachineNestedInput
    responsibleUser?: UserUpdateOneWithoutResponsibleMachinesNestedInput
    oilTemperatureReadings?: OilTemperatureReadingUpdateManyWithoutMachineNestedInput
    rpmReadings?: RpmReadingUpdateManyWithoutMachineNestedInput
  }

  export type MachineUncheckedUpdateWithoutOilLevelReadingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    clientId?: IntFieldUpdateOperationsInput | number
    responsibleUserId?: NullableIntFieldUpdateOperationsInput | number | null
    deviceId?: NullableIntFieldUpdateOperationsInput | number | null
    UnifiedMachineState?: UnifiedMachineStateUncheckedUpdateManyWithoutMachineNestedInput
    currentReadings?: CurrentReadingUncheckedUpdateManyWithoutMachineNestedInput
    oilTemperatureReadings?: OilTemperatureReadingUncheckedUpdateManyWithoutMachineNestedInput
    rpmReadings?: RpmReadingUncheckedUpdateManyWithoutMachineNestedInput
  }

  export type UserUpsertWithoutOilLevelReadingsInput = {
    update: XOR<UserUpdateWithoutOilLevelReadingsInput, UserUncheckedUpdateWithoutOilLevelReadingsInput>
    create: XOR<UserCreateWithoutOilLevelReadingsInput, UserUncheckedCreateWithoutOilLevelReadingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOilLevelReadingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOilLevelReadingsInput, UserUncheckedUpdateWithoutOilLevelReadingsInput>
  }

  export type UserUpdateWithoutOilLevelReadingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentReadings?: CurrentReadingUpdateManyWithoutUserNestedInput
    responsibleMachines?: MachineUpdateManyWithoutResponsibleUserNestedInput
    oilTemperatureReadings?: OilTemperatureReadingUpdateManyWithoutUserNestedInput
    rpmReadings?: RpmReadingUpdateManyWithoutUserNestedInput
    client?: ClientUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutOilLevelReadingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    clientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentReadings?: CurrentReadingUncheckedUpdateManyWithoutUserNestedInput
    responsibleMachines?: MachineUncheckedUpdateManyWithoutResponsibleUserNestedInput
    oilTemperatureReadings?: OilTemperatureReadingUncheckedUpdateManyWithoutUserNestedInput
    rpmReadings?: RpmReadingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MachineCreateWithoutCurrentReadingsInput = {
    name: string
    model?: string | null
    manufacturer?: string | null
    serialNumber: string
    status?: $Enums.Status
    UnifiedMachineState?: UnifiedMachineStateCreateNestedManyWithoutMachineInput
    client: ClientCreateNestedOneWithoutMachinesInput
    device?: DeviceCreateNestedOneWithoutMachineInput
    responsibleUser?: UserCreateNestedOneWithoutResponsibleMachinesInput
    oilLevelReadings?: OilLevelReadingCreateNestedManyWithoutMachineInput
    oilTemperatureReadings?: OilTemperatureReadingCreateNestedManyWithoutMachineInput
    rpmReadings?: RpmReadingCreateNestedManyWithoutMachineInput
  }

  export type MachineUncheckedCreateWithoutCurrentReadingsInput = {
    id?: number
    name: string
    model?: string | null
    manufacturer?: string | null
    serialNumber: string
    status?: $Enums.Status
    clientId: number
    responsibleUserId?: number | null
    deviceId?: number | null
    UnifiedMachineState?: UnifiedMachineStateUncheckedCreateNestedManyWithoutMachineInput
    oilLevelReadings?: OilLevelReadingUncheckedCreateNestedManyWithoutMachineInput
    oilTemperatureReadings?: OilTemperatureReadingUncheckedCreateNestedManyWithoutMachineInput
    rpmReadings?: RpmReadingUncheckedCreateNestedManyWithoutMachineInput
  }

  export type MachineCreateOrConnectWithoutCurrentReadingsInput = {
    where: MachineWhereUniqueInput
    create: XOR<MachineCreateWithoutCurrentReadingsInput, MachineUncheckedCreateWithoutCurrentReadingsInput>
  }

  export type UserCreateWithoutCurrentReadingsInput = {
    name: string
    email: string
    password: string
    userType: $Enums.UserType
    status?: $Enums.Status
    createdAt?: Date | string
    responsibleMachines?: MachineCreateNestedManyWithoutResponsibleUserInput
    oilLevelReadings?: OilLevelReadingCreateNestedManyWithoutUserInput
    oilTemperatureReadings?: OilTemperatureReadingCreateNestedManyWithoutUserInput
    rpmReadings?: RpmReadingCreateNestedManyWithoutUserInput
    client: ClientCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutCurrentReadingsInput = {
    id?: number
    name: string
    email: string
    password: string
    userType: $Enums.UserType
    status?: $Enums.Status
    clientId: number
    createdAt?: Date | string
    responsibleMachines?: MachineUncheckedCreateNestedManyWithoutResponsibleUserInput
    oilLevelReadings?: OilLevelReadingUncheckedCreateNestedManyWithoutUserInput
    oilTemperatureReadings?: OilTemperatureReadingUncheckedCreateNestedManyWithoutUserInput
    rpmReadings?: RpmReadingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCurrentReadingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCurrentReadingsInput, UserUncheckedCreateWithoutCurrentReadingsInput>
  }

  export type MachineUpsertWithoutCurrentReadingsInput = {
    update: XOR<MachineUpdateWithoutCurrentReadingsInput, MachineUncheckedUpdateWithoutCurrentReadingsInput>
    create: XOR<MachineCreateWithoutCurrentReadingsInput, MachineUncheckedCreateWithoutCurrentReadingsInput>
    where?: MachineWhereInput
  }

  export type MachineUpdateToOneWithWhereWithoutCurrentReadingsInput = {
    where?: MachineWhereInput
    data: XOR<MachineUpdateWithoutCurrentReadingsInput, MachineUncheckedUpdateWithoutCurrentReadingsInput>
  }

  export type MachineUpdateWithoutCurrentReadingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    UnifiedMachineState?: UnifiedMachineStateUpdateManyWithoutMachineNestedInput
    client?: ClientUpdateOneRequiredWithoutMachinesNestedInput
    device?: DeviceUpdateOneWithoutMachineNestedInput
    responsibleUser?: UserUpdateOneWithoutResponsibleMachinesNestedInput
    oilLevelReadings?: OilLevelReadingUpdateManyWithoutMachineNestedInput
    oilTemperatureReadings?: OilTemperatureReadingUpdateManyWithoutMachineNestedInput
    rpmReadings?: RpmReadingUpdateManyWithoutMachineNestedInput
  }

  export type MachineUncheckedUpdateWithoutCurrentReadingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    clientId?: IntFieldUpdateOperationsInput | number
    responsibleUserId?: NullableIntFieldUpdateOperationsInput | number | null
    deviceId?: NullableIntFieldUpdateOperationsInput | number | null
    UnifiedMachineState?: UnifiedMachineStateUncheckedUpdateManyWithoutMachineNestedInput
    oilLevelReadings?: OilLevelReadingUncheckedUpdateManyWithoutMachineNestedInput
    oilTemperatureReadings?: OilTemperatureReadingUncheckedUpdateManyWithoutMachineNestedInput
    rpmReadings?: RpmReadingUncheckedUpdateManyWithoutMachineNestedInput
  }

  export type UserUpsertWithoutCurrentReadingsInput = {
    update: XOR<UserUpdateWithoutCurrentReadingsInput, UserUncheckedUpdateWithoutCurrentReadingsInput>
    create: XOR<UserCreateWithoutCurrentReadingsInput, UserUncheckedCreateWithoutCurrentReadingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCurrentReadingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCurrentReadingsInput, UserUncheckedUpdateWithoutCurrentReadingsInput>
  }

  export type UserUpdateWithoutCurrentReadingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responsibleMachines?: MachineUpdateManyWithoutResponsibleUserNestedInput
    oilLevelReadings?: OilLevelReadingUpdateManyWithoutUserNestedInput
    oilTemperatureReadings?: OilTemperatureReadingUpdateManyWithoutUserNestedInput
    rpmReadings?: RpmReadingUpdateManyWithoutUserNestedInput
    client?: ClientUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutCurrentReadingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    clientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responsibleMachines?: MachineUncheckedUpdateManyWithoutResponsibleUserNestedInput
    oilLevelReadings?: OilLevelReadingUncheckedUpdateManyWithoutUserNestedInput
    oilTemperatureReadings?: OilTemperatureReadingUncheckedUpdateManyWithoutUserNestedInput
    rpmReadings?: RpmReadingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type InteracaoIACreateManyHyperparameterArmInput = {
    id?: number
    perguntaUsuario: string
    queryMontada: string
    respostaHumanizada: string
    feedbackUsuario?: number | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type InteracaoIAUpdateWithoutHyperparameterArmInput = {
    perguntaUsuario?: StringFieldUpdateOperationsInput | string
    queryMontada?: StringFieldUpdateOperationsInput | string
    respostaHumanizada?: StringFieldUpdateOperationsInput | string
    feedbackUsuario?: NullableIntFieldUpdateOperationsInput | number | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InteracaoIAUncheckedUpdateWithoutHyperparameterArmInput = {
    id?: IntFieldUpdateOperationsInput | number
    perguntaUsuario?: StringFieldUpdateOperationsInput | string
    queryMontada?: StringFieldUpdateOperationsInput | string
    respostaHumanizada?: StringFieldUpdateOperationsInput | string
    feedbackUsuario?: NullableIntFieldUpdateOperationsInput | number | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InteracaoIAUncheckedUpdateManyWithoutHyperparameterArmInput = {
    id?: IntFieldUpdateOperationsInput | number
    perguntaUsuario?: StringFieldUpdateOperationsInput | string
    queryMontada?: StringFieldUpdateOperationsInput | string
    respostaHumanizada?: StringFieldUpdateOperationsInput | string
    feedbackUsuario?: NullableIntFieldUpdateOperationsInput | number | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineCreateManyClientInput = {
    id?: number
    name: string
    model?: string | null
    manufacturer?: string | null
    serialNumber: string
    status?: $Enums.Status
    responsibleUserId?: number | null
    deviceId?: number | null
  }

  export type UserCreateManyClientInput = {
    id?: number
    name: string
    email: string
    password: string
    userType: $Enums.UserType
    status?: $Enums.Status
    createdAt?: Date | string
  }

  export type DeviceCreateManyClientInput = {
    id?: number
    nodeId: string
    description?: string | null
    status?: $Enums.DeviceStatus
    lastHeartbeat?: Date | string
    gatewayId?: number | null
  }

  export type GatewayCreateManyClientInput = {
    id?: number
    gatewayId: string
    description?: string | null
    status?: $Enums.DeviceStatus
    lastHeartbeat?: Date | string
  }

  export type MachineUpdateWithoutClientInput = {
    name?: StringFieldUpdateOperationsInput | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    UnifiedMachineState?: UnifiedMachineStateUpdateManyWithoutMachineNestedInput
    currentReadings?: CurrentReadingUpdateManyWithoutMachineNestedInput
    device?: DeviceUpdateOneWithoutMachineNestedInput
    responsibleUser?: UserUpdateOneWithoutResponsibleMachinesNestedInput
    oilLevelReadings?: OilLevelReadingUpdateManyWithoutMachineNestedInput
    oilTemperatureReadings?: OilTemperatureReadingUpdateManyWithoutMachineNestedInput
    rpmReadings?: RpmReadingUpdateManyWithoutMachineNestedInput
  }

  export type MachineUncheckedUpdateWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    responsibleUserId?: NullableIntFieldUpdateOperationsInput | number | null
    deviceId?: NullableIntFieldUpdateOperationsInput | number | null
    UnifiedMachineState?: UnifiedMachineStateUncheckedUpdateManyWithoutMachineNestedInput
    currentReadings?: CurrentReadingUncheckedUpdateManyWithoutMachineNestedInput
    oilLevelReadings?: OilLevelReadingUncheckedUpdateManyWithoutMachineNestedInput
    oilTemperatureReadings?: OilTemperatureReadingUncheckedUpdateManyWithoutMachineNestedInput
    rpmReadings?: RpmReadingUncheckedUpdateManyWithoutMachineNestedInput
  }

  export type MachineUncheckedUpdateManyWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    responsibleUserId?: NullableIntFieldUpdateOperationsInput | number | null
    deviceId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserUpdateWithoutClientInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentReadings?: CurrentReadingUpdateManyWithoutUserNestedInput
    responsibleMachines?: MachineUpdateManyWithoutResponsibleUserNestedInput
    oilLevelReadings?: OilLevelReadingUpdateManyWithoutUserNestedInput
    oilTemperatureReadings?: OilTemperatureReadingUpdateManyWithoutUserNestedInput
    rpmReadings?: RpmReadingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentReadings?: CurrentReadingUncheckedUpdateManyWithoutUserNestedInput
    responsibleMachines?: MachineUncheckedUpdateManyWithoutResponsibleUserNestedInput
    oilLevelReadings?: OilLevelReadingUncheckedUpdateManyWithoutUserNestedInput
    oilTemperatureReadings?: OilTemperatureReadingUncheckedUpdateManyWithoutUserNestedInput
    rpmReadings?: RpmReadingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceUpdateWithoutClientInput = {
    nodeId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    lastHeartbeat?: DateTimeFieldUpdateOperationsInput | Date | string
    gateway?: GatewayUpdateOneWithoutResponsibleForNestedInput
    machine?: MachineUpdateOneWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    nodeId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    lastHeartbeat?: DateTimeFieldUpdateOperationsInput | Date | string
    gatewayId?: NullableIntFieldUpdateOperationsInput | number | null
    machine?: MachineUncheckedUpdateOneWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateManyWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    nodeId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    lastHeartbeat?: DateTimeFieldUpdateOperationsInput | Date | string
    gatewayId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type GatewayUpdateWithoutClientInput = {
    gatewayId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    lastHeartbeat?: DateTimeFieldUpdateOperationsInput | Date | string
    responsibleFor?: DeviceUpdateManyWithoutGatewayNestedInput
  }

  export type GatewayUncheckedUpdateWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    gatewayId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    lastHeartbeat?: DateTimeFieldUpdateOperationsInput | Date | string
    responsibleFor?: DeviceUncheckedUpdateManyWithoutGatewayNestedInput
  }

  export type GatewayUncheckedUpdateManyWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    gatewayId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    lastHeartbeat?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CurrentReadingCreateManyUserInput = {
    id?: number
    timestamp?: Date | string
    current: number
    machineId: number
  }

  export type MachineCreateManyResponsibleUserInput = {
    id?: number
    name: string
    model?: string | null
    manufacturer?: string | null
    serialNumber: string
    status?: $Enums.Status
    clientId: number
    deviceId?: number | null
  }

  export type OilLevelReadingCreateManyUserInput = {
    id?: number
    timestamp?: Date | string
    level: number
    machineId: number
  }

  export type OilTemperatureReadingCreateManyUserInput = {
    id?: number
    timestamp?: Date | string
    temperature: number
    machineId: number
  }

  export type RpmReadingCreateManyUserInput = {
    id?: number
    timestamp?: Date | string
    rpm: number
    machineId: number
  }

  export type CurrentReadingUpdateWithoutUserInput = {
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    current?: FloatFieldUpdateOperationsInput | number
    machine?: MachineUpdateOneRequiredWithoutCurrentReadingsNestedInput
  }

  export type CurrentReadingUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    current?: FloatFieldUpdateOperationsInput | number
    machineId?: IntFieldUpdateOperationsInput | number
  }

  export type CurrentReadingUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    current?: FloatFieldUpdateOperationsInput | number
    machineId?: IntFieldUpdateOperationsInput | number
  }

  export type MachineUpdateWithoutResponsibleUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    UnifiedMachineState?: UnifiedMachineStateUpdateManyWithoutMachineNestedInput
    currentReadings?: CurrentReadingUpdateManyWithoutMachineNestedInput
    client?: ClientUpdateOneRequiredWithoutMachinesNestedInput
    device?: DeviceUpdateOneWithoutMachineNestedInput
    oilLevelReadings?: OilLevelReadingUpdateManyWithoutMachineNestedInput
    oilTemperatureReadings?: OilTemperatureReadingUpdateManyWithoutMachineNestedInput
    rpmReadings?: RpmReadingUpdateManyWithoutMachineNestedInput
  }

  export type MachineUncheckedUpdateWithoutResponsibleUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    clientId?: IntFieldUpdateOperationsInput | number
    deviceId?: NullableIntFieldUpdateOperationsInput | number | null
    UnifiedMachineState?: UnifiedMachineStateUncheckedUpdateManyWithoutMachineNestedInput
    currentReadings?: CurrentReadingUncheckedUpdateManyWithoutMachineNestedInput
    oilLevelReadings?: OilLevelReadingUncheckedUpdateManyWithoutMachineNestedInput
    oilTemperatureReadings?: OilTemperatureReadingUncheckedUpdateManyWithoutMachineNestedInput
    rpmReadings?: RpmReadingUncheckedUpdateManyWithoutMachineNestedInput
  }

  export type MachineUncheckedUpdateManyWithoutResponsibleUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    clientId?: IntFieldUpdateOperationsInput | number
    deviceId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OilLevelReadingUpdateWithoutUserInput = {
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    level?: FloatFieldUpdateOperationsInput | number
    machine?: MachineUpdateOneRequiredWithoutOilLevelReadingsNestedInput
  }

  export type OilLevelReadingUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    level?: FloatFieldUpdateOperationsInput | number
    machineId?: IntFieldUpdateOperationsInput | number
  }

  export type OilLevelReadingUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    level?: FloatFieldUpdateOperationsInput | number
    machineId?: IntFieldUpdateOperationsInput | number
  }

  export type OilTemperatureReadingUpdateWithoutUserInput = {
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    temperature?: FloatFieldUpdateOperationsInput | number
    machine?: MachineUpdateOneRequiredWithoutOilTemperatureReadingsNestedInput
  }

  export type OilTemperatureReadingUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    temperature?: FloatFieldUpdateOperationsInput | number
    machineId?: IntFieldUpdateOperationsInput | number
  }

  export type OilTemperatureReadingUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    temperature?: FloatFieldUpdateOperationsInput | number
    machineId?: IntFieldUpdateOperationsInput | number
  }

  export type RpmReadingUpdateWithoutUserInput = {
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    rpm?: IntFieldUpdateOperationsInput | number
    machine?: MachineUpdateOneRequiredWithoutRpmReadingsNestedInput
  }

  export type RpmReadingUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    rpm?: IntFieldUpdateOperationsInput | number
    machineId?: IntFieldUpdateOperationsInput | number
  }

  export type RpmReadingUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    rpm?: IntFieldUpdateOperationsInput | number
    machineId?: IntFieldUpdateOperationsInput | number
  }

  export type UnifiedMachineStateCreateManyMachineInput = {
    id?: string
    timestamp: Date | string
    current?: number | null
    rpm?: number | null
    oilTemperature?: number | null
    oilLevel?: number | null
    clusterPredict?: number | null
    clusterStrength?: number | null
    currentIsMissing?: boolean
    rpmIsMissing?: boolean
    oilTemperatureIsMissing?: boolean
    oilLevelIsMissing?: boolean
  }

  export type CurrentReadingCreateManyMachineInput = {
    id?: number
    timestamp?: Date | string
    current: number
    userId?: number | null
  }

  export type OilLevelReadingCreateManyMachineInput = {
    id?: number
    timestamp?: Date | string
    level: number
    userId?: number | null
  }

  export type OilTemperatureReadingCreateManyMachineInput = {
    id?: number
    timestamp?: Date | string
    temperature: number
    userId?: number | null
  }

  export type RpmReadingCreateManyMachineInput = {
    id?: number
    timestamp?: Date | string
    rpm: number
    userId?: number | null
  }

  export type UnifiedMachineStateUpdateWithoutMachineInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    current?: NullableFloatFieldUpdateOperationsInput | number | null
    rpm?: NullableIntFieldUpdateOperationsInput | number | null
    oilTemperature?: NullableFloatFieldUpdateOperationsInput | number | null
    oilLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    clusterPredict?: NullableIntFieldUpdateOperationsInput | number | null
    clusterStrength?: NullableFloatFieldUpdateOperationsInput | number | null
    currentIsMissing?: BoolFieldUpdateOperationsInput | boolean
    rpmIsMissing?: BoolFieldUpdateOperationsInput | boolean
    oilTemperatureIsMissing?: BoolFieldUpdateOperationsInput | boolean
    oilLevelIsMissing?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UnifiedMachineStateUncheckedUpdateWithoutMachineInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    current?: NullableFloatFieldUpdateOperationsInput | number | null
    rpm?: NullableIntFieldUpdateOperationsInput | number | null
    oilTemperature?: NullableFloatFieldUpdateOperationsInput | number | null
    oilLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    clusterPredict?: NullableIntFieldUpdateOperationsInput | number | null
    clusterStrength?: NullableFloatFieldUpdateOperationsInput | number | null
    currentIsMissing?: BoolFieldUpdateOperationsInput | boolean
    rpmIsMissing?: BoolFieldUpdateOperationsInput | boolean
    oilTemperatureIsMissing?: BoolFieldUpdateOperationsInput | boolean
    oilLevelIsMissing?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UnifiedMachineStateUncheckedUpdateManyWithoutMachineInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    current?: NullableFloatFieldUpdateOperationsInput | number | null
    rpm?: NullableIntFieldUpdateOperationsInput | number | null
    oilTemperature?: NullableFloatFieldUpdateOperationsInput | number | null
    oilLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    clusterPredict?: NullableIntFieldUpdateOperationsInput | number | null
    clusterStrength?: NullableFloatFieldUpdateOperationsInput | number | null
    currentIsMissing?: BoolFieldUpdateOperationsInput | boolean
    rpmIsMissing?: BoolFieldUpdateOperationsInput | boolean
    oilTemperatureIsMissing?: BoolFieldUpdateOperationsInput | boolean
    oilLevelIsMissing?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CurrentReadingUpdateWithoutMachineInput = {
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    current?: FloatFieldUpdateOperationsInput | number
    user?: UserUpdateOneWithoutCurrentReadingsNestedInput
  }

  export type CurrentReadingUncheckedUpdateWithoutMachineInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    current?: FloatFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CurrentReadingUncheckedUpdateManyWithoutMachineInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    current?: FloatFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OilLevelReadingUpdateWithoutMachineInput = {
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    level?: FloatFieldUpdateOperationsInput | number
    user?: UserUpdateOneWithoutOilLevelReadingsNestedInput
  }

  export type OilLevelReadingUncheckedUpdateWithoutMachineInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    level?: FloatFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OilLevelReadingUncheckedUpdateManyWithoutMachineInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    level?: FloatFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OilTemperatureReadingUpdateWithoutMachineInput = {
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    temperature?: FloatFieldUpdateOperationsInput | number
    user?: UserUpdateOneWithoutOilTemperatureReadingsNestedInput
  }

  export type OilTemperatureReadingUncheckedUpdateWithoutMachineInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    temperature?: FloatFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OilTemperatureReadingUncheckedUpdateManyWithoutMachineInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    temperature?: FloatFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RpmReadingUpdateWithoutMachineInput = {
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    rpm?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneWithoutRpmReadingsNestedInput
  }

  export type RpmReadingUncheckedUpdateWithoutMachineInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    rpm?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RpmReadingUncheckedUpdateManyWithoutMachineInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    rpm?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DeviceCreateManyGatewayInput = {
    id?: number
    nodeId: string
    description?: string | null
    status?: $Enums.DeviceStatus
    lastHeartbeat?: Date | string
    clientId: number
  }

  export type DeviceUpdateWithoutGatewayInput = {
    nodeId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    lastHeartbeat?: DateTimeFieldUpdateOperationsInput | Date | string
    machine?: MachineUpdateOneWithoutDeviceNestedInput
    client?: ClientUpdateOneRequiredWithoutDevicesNestedInput
  }

  export type DeviceUncheckedUpdateWithoutGatewayInput = {
    id?: IntFieldUpdateOperationsInput | number
    nodeId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    lastHeartbeat?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: IntFieldUpdateOperationsInput | number
    machine?: MachineUncheckedUpdateOneWithoutDeviceNestedInput
  }

  export type DeviceUncheckedUpdateManyWithoutGatewayInput = {
    id?: IntFieldUpdateOperationsInput | number
    nodeId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeviceStatusFieldUpdateOperationsInput | $Enums.DeviceStatus
    lastHeartbeat?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}