generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}



model InteracaoIA {
  id                  Int               @id @default(autoincrement())
  perguntaUsuario     String
  queryMontada        String
  respostaHumanizada  String            @db.Text
  feedbackUsuario     Int?
  criadoEm            DateTime          @default(now())
  atualizadoEm        DateTime          @updatedAt
  hyperparameterArmId String
  hyperparameterArm   HyperparameterArm @relation(fields: [hyperparameterArmId], references: [id])
}

model HyperparameterArm {
  id               String   @id @default(uuid())
  modelName        String?
  version          String?
  temperature      Float
  topP             Float
  topK             Int
  maxOutputTokens  Int
  responseMimeType String
  successes        Int?      @default(0)
  failures         Int?     @default(0)
  interacoes       InteracaoIA[]
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
}

/// Representa a empresa cliente que contrata o serviço IoTurn.
model Client {
  id                Int        @id @default(autoincrement())
  companyName       String
  cnpj              String     @unique
  phone             String?
  address           String?
  email             String     @unique
  contractDate      DateTime   @default(now())
  status            Status     @default(ACTIVE)
  
  // Relações
  users             User[]
  machines          Machine[]

  @@map("clients")
}

/// Usuários que podem acessar a plataforma, associados a um cliente.
model User {
  id                Int        @id @default(autoincrement())
  name              String
  email             String     @unique
  password          String
  userType          UserType
  status            Status     @default(ACTIVE)

  // Relação: Um usuário pertence a um cliente.
  clientId          Int
  client            Client     @relation(fields: [clientId], references: [id])

  // Relação: Um usuário pode ser responsável por várias máquinas.
  responsibleFor    Machine[]

  // Relação: Um usuário pode estar associado a vários registros de sensores.
  sensorReadings    SensorReading[]

  @@map("users")
}

/// Representa uma máquina industrial monitorada.
model Machine {
  id                Int        @id @default(autoincrement())
  name              String
  model             String?
  manufacturer      String?
  serialNumber      String     @unique
  status            Status     @default(ACTIVE)

  // Relação: A máquina pertence a um cliente.
  clientId          Int
  client            Client     @relation(fields: [clientId], references: [id])

  // Relação: A máquina tem um usuário responsável.
  responsibleUserId Int
  responsibleUser   User       @relation(fields: [responsibleUserId], references: [id])

  // Relação: Uma máquina possui múltiplos registros de sensores.
  sensorReadings    SensorReading[]

  deviceId          Int      @unique
  device            Device   @relation(fields: [deviceId], references: [id])
  @@map("machines")
}

model Device {
  id            Int      @id @default(autoincrement())
  
  // Este é o campo mais importante! Armazena o ID único do hardware.
  nodeId        String   @unique // Ex: "207D5CDAB734"
  
  description   String?  // Ex: "Sensor Heltec V2 instalado no setor A"
  status        DeviceStatus @default(PROVISIONING)
  lastHeartbeat DateTime @updatedAt
  machine         Machine?

  // Relação N-para-1: Este dispositivo pertence a UM Gateway.
  gatewayId     Int?
  gateway       Gateway?  @relation(fields: [gatewayId], references: [id])

  @@map("devices")
}

/// Representa o hardware físico do Gateway (ESP32 com Wi-Fi).
model Gateway {
  id             Int        @id @default(autoincrement())
  
  // O ID único do hardware do Gateway (o Chip ID dele).
  gatewayId      String     @unique
  
  description    String?    // Ex: "Gateway do Setor A - Próximo à doca 3"
  status         DeviceStatus @default(OFFLINE)
  lastHeartbeat  DateTime   @updatedAt

  // Relação 1-para-N: Um Gateway é responsável por muitos dispositivos (Nós Sensores).
  responsibleFor Device[]

  @@map("gateways")
}
/// Armazena as leituras dos sensores de uma máquina em um ponto no tempo.
model SensorReading {
  id                Int        @id @default(autoincrement())
  timestamp         DateTime   @default(now())
  rpm               Int
  oilTemperature    Float
  oilLevel          Float
  current           Float
  vibration         Float
  status            String     // Status da leitura, ex: "Normal", "Alerta"

  // Relação: A leitura pertence a uma máquina específica.
  machineId         Int
  machine           Machine    @relation(fields: [machineId], references: [id])

  // Relação: A leitura foi registrada por um usuário (opcional, se aplicável).
  userId            Int
  user              User       @relation(fields: [userId], references: [id])

  @@map("sensor_readings")
}

// -- Enums para manter a integridade dos dados --

/// Status geral para clientes, usuários e máquinas.
enum Status {
  ACTIVE
  SUSPENDED
  CANCELED
}

/// Tipos de perfil de usuário dentro da plataforma.
enum UserType {
  ADMIN
  TECHNICIAN
  VIEWER
}

///Enum para o status do dispositivo
enum DeviceStatus {
  ONLINE
  OFFLINE
  PROVISIONING // Estado inicial, antes de ser associado a uma máquina
  ERROR
}